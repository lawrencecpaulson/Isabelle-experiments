section \<open>Abstract Metric Spaces\<close>

theory Abstract_Metric_Spaces
  imports
    "HOL-Analysis.Analysis" "HOL-ex.Sketch_and_Explore"
begin

thm compact_space_imp_nest (*NEEDS decseq*)

lemma inverse_Suc: "inverse (Suc n) > 0"
  by simp

lemma Archimedean_eventually_inverse:
  fixes \<epsilon>::real shows "(\<forall>\<^sub>F n in sequentially. inverse (real (Suc n)) < \<epsilon>) \<longleftrightarrow> 0 < \<epsilon>"
  (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (meson eventually_sequentially inverse_nonnegative_iff_nonnegative nle_le of_nat_0_le_iff order_le_less_trans)
next
  assume ?rhs
  then obtain N where "inverse (Suc N) < \<epsilon>"
    using reals_Archimedean by blast
  then have "inverse (Suc n) < \<epsilon>" if "n \<ge> N" for n
    using that \<open>\<epsilon> > 0\<close> apply (simp add: field_simps)
    by (smt (verit) mult_less_cancel_left_pos of_nat_mono)
  then show ?lhs
    using eventually_sequentially by blast
qed


(*Elementary_Metric_Spaces
lemma ball_iff_cball: "(\<exists>r>0. ball x r \<subseteq> U) = (\<exists>r>0. cball x r \<subseteq> U)"
  by (meson mem_interior mem_interior_cball)
*)

(*REPLACE ORIGINAL DEFINITION TO USE ABBREVIATION, LIKE AT / AT_WITHIN
    ("atin (_) (_)/ within (_)" [1000, 60] 60)*)
thm atin_def at_within_def
definition atin_within :: "['a topology, 'a, 'a set] \<Rightarrow> 'a filter"
  where "atin_within X a S = inf (nhdsin X a) (principal (topspace X \<inter> S - {a}))"

lemma atin_within_UNIV [simp]:
  shows "atin_within X a UNIV = atin X a"
  by (simp add: atin_def atin_within_def)

lemma eventually_atin_subtopology:
  assumes "a \<in> topspace X"
  shows "eventually P (atin (subtopology X S) a) \<longleftrightarrow> 
    (a \<in> S \<longrightarrow> (\<exists>U. openin (subtopology X S) U \<and> a \<in> U \<and> (\<forall>x\<in>U - {a}. P x)))"
  using assms by (simp add: eventually_atin)

lemma eventually_atin_within:
  "eventually P (atin_within X a S) \<longleftrightarrow> a \<notin> topspace X \<or>
   (\<exists>T. openin X T \<and> a \<in> T \<and> (\<forall>x\<in>T. x \<in> S \<and> x \<noteq> a \<longrightarrow> P x))"
proof (cases "a \<in> topspace X")
  case True
  hence "eventually P (atin_within X a S) \<longleftrightarrow> 
         (\<exists>T. openin X T \<and> a \<in> T \<and>
          (\<forall>x\<in>T. x \<in> topspace X \<and> x \<in> S \<and> x \<noteq> a \<longrightarrow> P x))"
    by (simp add: atin_within_def eventually_inf_principal eventually_nhdsin)
  also have "\<dots> \<longleftrightarrow> (\<exists>T. openin X T \<and> a \<in> T \<and> (\<forall>x\<in>T. x \<in> S \<and> x \<noteq> a \<longrightarrow> P x))"
    using openin_subset by (intro ex_cong) auto
  finally show ?thesis by (simp add: True)
qed (simp add: atin_within_def)

lemma atin_subtopology_within:
  assumes "a \<in> S"
  shows "atin (subtopology X S) a = atin_within X a S"
proof -
  have "eventually P (atin (subtopology X S) a) \<longleftrightarrow> eventually P (atin_within X a S)" for P
    unfolding eventually_atin eventually_atin_within openin_subtopology
    using assms by auto
  then show ?thesis
    by (meson le_filter_def order.eq_iff)
qed

lemma limit_continuous_map_within:
   "\<lbrakk>continuous_map (subtopology X S) Y f; a \<in> S; a \<in> topspace X\<rbrakk>
    \<Longrightarrow> limitin Y f (f a) (atin_within X a S)"
  by (metis Int_iff atin_subtopology_within continuous_map_atin topspace_subtopology)

lemma atin_subtopology_within_if:
  shows "atin (subtopology X S) a = (if a \<in> S then atin_within X a S else bot)"
  by (simp add: atin_subtopology_within)

lemma trivial_limit_atpointof_within:
   "trivial_limit(atin_within X a S) \<longleftrightarrow>
        (a \<notin> X derived_set_of S)"
  by (auto simp: trivial_limit_def eventually_atin_within in_derived_set_of)

lemma derived_set_of_trivial_limit:
   "a \<in> X derived_set_of S \<longleftrightarrow> \<not> trivial_limit(atin_within X a S)"
  by (simp add: trivial_limit_atpointof_within)


subsection \<open>Misc other\<close>

lemma Sup_unique:
  fixes b :: "'a :: {conditionally_complete_lattice, no_bot}"
  assumes "\<And>c. (\<forall>x \<in> s. x \<le> c) \<longleftrightarrow> b \<le> c"
  shows "Sup s = b"
  by (metis assms cSup_eq order.refl)

lemma Inf_unique:
  fixes b :: "'a :: {conditionally_complete_lattice, no_top}"
  assumes "\<And>c. (\<forall>x \<in> s. x \<ge> c) \<longleftrightarrow> b \<ge> c"
  shows "Inf s = b"
  by (meson assms cInf_eq order.refl)

thm retract_of_space_retraction_maps
lemma retract_of_space_trans:
  assumes "S retract_of_space X"  "T retract_of_space subtopology X S"
  shows "T retract_of_space X"
  using assms
  apply (simp add: retract_of_space_retraction_maps)
  by (metis id_comp inf.absorb_iff2 retraction_maps_compose subtopology_subtopology)

lemma retract_of_space_subtopology:
  assumes "S retract_of_space X"  "S \<subseteq> U"
  shows "S retract_of_space subtopology X U"
  using assms
  apply (clarsimp simp: retract_of_space_def)
  by (metis continuous_map_from_subtopology inf.absorb2 subtopology_subtopology)


lemma limitinD: "\<lbrakk>limitin X f l F; openin X U; l \<in> U\<rbrakk> \<Longrightarrow> eventually (\<lambda>x. f x \<in> U) F"
  by (simp add: limitin_def)


thm retract_of_space_disjoint_union

lemma hereditary_imp_retractive_property:
  assumes "\<And>X S. P X \<Longrightarrow> P(subtopology X S)" 
          "\<And>X X'. X homeomorphic_space X' \<Longrightarrow> (P X \<longleftrightarrow> Q X')"
  assumes "retraction_map X X' r" "P X"
  shows "Q X'"
  by (meson assms retraction_map_def retraction_maps_section_image2)


lemmas connectedin_Int_frontier_of = connectedin_inter_frontier_of

lemma embedding_imp_closed_map_eq:
   "embedding_map X Y f \<Longrightarrow> (closed_map X Y f \<longleftrightarrow> closedin Y (f ` topspace X))"
  using closed_map_def embedding_imp_closed_map by blast

lemma connectedinD:
     "\<lbrakk>connectedin X S; openin X E1; openin X E2; S \<subseteq> E1 \<union> E2; E1 \<inter> E2 \<inter> S = {}; E1 \<inter> S \<noteq> {}; E2 \<inter> S \<noteq> {}\<rbrakk> \<Longrightarrow> False"
  by (meson connectedin)


lemma separatedin_full:
   "S \<union> T = topspace X
   \<Longrightarrow> separatedin X S T \<longleftrightarrow>
       disjnt S T \<and> closedin X S \<and> openin X S \<and> closedin X T \<and> openin X T"
  by (metis separatedin_open_sets separation_closedin_Un_gen separation_openin_Un_gen subtopology_topspace)


lemma Hausdorff_space_closed_neighbourhood:
   "Hausdorff_space X \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<exists>u c. openin X u \<and> closedin X c \<and>
                      Hausdorff_space(subtopology X c) \<and> x \<in> u \<and> u \<subseteq> c)" (is "_ = ?rhs")
proof
  assume R: ?rhs
  show "Hausdorff_space X"
    unfolding Hausdorff_space_def
  proof clarify
    fix x y
    assume x: "x \<in> topspace X" and y: "y \<in> topspace X" and "x \<noteq> y"
    obtain T C where *: "openin X T" "closedin X C" "x \<in> T" "T \<subseteq> C"
                 and C: "Hausdorff_space (subtopology X C)"
      by (meson R \<open>x \<in> topspace X\<close>)
    show "\<exists>U V. openin X U \<and> openin X V \<and> x \<in> U \<and> y \<in> V \<and> disjnt U V"
    proof (cases "y \<in> C")
      case True
      with * obtain U V where U: "openin (subtopology X C) U"
                        and V: "openin (subtopology X C) V"
                        and "x \<in> U" "y \<in> V" "disjnt U V"
        by (metis C Hausdorff_space_def \<open>x \<noteq> y\<close> closedin_subset subsetD topspace_subtopology_subset)
      then obtain U' V' where UV': "U = U' \<inter> C" "openin X U'" "V = V' \<inter> C" "openin X V'"
        by (meson openin_subtopology)
      have "disjnt (T \<inter> U') V'"
        using \<open>disjnt U V\<close> UV' \<open>T \<subseteq> C\<close> by (force simp: disjnt_iff)
      with \<open>T \<subseteq> C\<close> have "disjnt (T \<inter> U') (V' \<union> (topspace X - C))"
        by (metis Diff_Diff_Int disjnt_Diff1 disjnt_Un2)
      moreover
      have "openin X (T \<inter> U')"
        by (simp add: "*"(1) \<open>openin X U'\<close> openin_Int)
      moreover have "openin X (V' \<union> (topspace X - C))"
        using "*"(2) \<open>openin X V'\<close> by auto
      ultimately show ?thesis
        using "*"(3) UV' \<open>x \<in> U\<close> \<open>y \<in> V\<close> by blast
    next
      case False
      with * y show ?thesis
        by (force simp: closedin_def disjnt_def)
    qed
  qed
qed fastforce

lemma infinite_perfect_set:
   "\<lbrakk>Hausdorff_space X; S \<subseteq> X derived_set_of S; S \<noteq> {}\<rbrakk> \<Longrightarrow> infinite S"
  using derived_set_of_finite by blast


subsection \<open>after quotient_map_saturated_open\<close>
thm quotient_map_saturated_open

lemma quotient_map_saturated_closed:
     "quotient_map X Y f \<longleftrightarrow>
        continuous_map X Y f \<and> f ` (topspace X) = topspace Y \<and>
        (\<forall>U. closedin X U \<and> {x \<in> topspace X. f x \<in> f ` U} \<subseteq> U \<longrightarrow> closedin Y (f ` U))"
     (is "?lhs = ?rhs")
proof
  assume L: ?lhs
  then obtain fim: "f ` topspace X = topspace Y"
    and Y: "\<And>U. U \<subseteq> topspace Y \<Longrightarrow> closedin Y U = closedin X {x \<in> topspace X. f x \<in> U}"
    by (simp add: quotient_map_closedin)
  show ?rhs
  proof (intro conjI allI impI)
    show "continuous_map X Y f"
      by (simp add: L quotient_imp_continuous_map)
    show "f ` topspace X = topspace Y"
      by (simp add: fim)
  next
    fix U :: "'a set"
    assume U: "closedin X U \<and> {x \<in> topspace X. f x \<in> f ` U} \<subseteq> U"
    then have sub:  "f ` U \<subseteq> topspace Y" and eq: "{x \<in> topspace X. f x \<in> f ` U} = U"
      using fim closedin_subset by fastforce+
    show "closedin Y (f ` U)"
      by (simp add: sub Y eq U)
  qed
next
  assume ?rhs
  then obtain YX: "\<And>U. closedin Y U \<Longrightarrow> closedin X {x \<in> topspace X. f x \<in> U}"
    and fim: "f ` topspace X = topspace Y"
    and XY: "\<And>U. \<lbrakk>closedin X U; {x \<in> topspace X. f x \<in> f ` U} \<subseteq> U\<rbrakk> \<Longrightarrow> closedin Y (f ` U)"
    by (simp add: continuous_map_closedin)
  show ?lhs
  proof (simp add: quotient_map_closedin fim, intro allI impI iffI)
    fix U :: "'b set"
    assume "U \<subseteq> topspace Y" and X: "closedin X {x \<in> topspace X. f x \<in> U}"
    have feq: "f ` {x \<in> topspace X. f x \<in> U} = U"
      using \<open>U \<subseteq> topspace Y\<close> fim by auto
    show "closedin Y U"
      using XY [OF X] by (simp add: feq)
  next
    fix U :: "'b set"
    assume "U \<subseteq> topspace Y" and Y: "closedin Y U"
    show "closedin X {x \<in> topspace X. f x \<in> U}"
      by (metis YX [OF Y])
  qed
qed

lemma quotient_map_onto_image:
  assumes "f ` topspace X \<subseteq> topspace Y" and U: "\<And>U. U \<subseteq> topspace Y \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U} = openin Y U"
  shows "quotient_map X (subtopology Y (f ` topspace X)) f"
  unfolding quotient_map_def topspace_subtopology
proof (intro conjI strip)
  fix U
  assume "U \<subseteq> topspace Y \<inter> f ` topspace X"
  with U have "openin X {x \<in> topspace X. f x \<in> U} \<Longrightarrow> \<exists>x. openin Y x \<and> U = f ` topspace X \<inter> x"
    by fastforce
  moreover have "\<exists>x. openin Y x \<and> U = f ` topspace X \<inter> x \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U}"
    by (metis (mono_tags, lifting) Collect_cong IntE IntI U image_eqI openin_subset)
  ultimately show "openin X {x \<in> topspace X. f x \<in> U} = openin (subtopology Y (f ` topspace X)) U"
    by (force simp: openin_subtopology_alt image_iff)
qed (use assms in auto)

lemma quotient_map_lift_exists:
  assumes f: "quotient_map X Y f" and h: "continuous_map X Z h" 
    and "\<And>x y. \<lbrakk>x \<in> topspace X; y \<in> topspace X; f x = f y\<rbrakk> \<Longrightarrow> h x = h y"
  obtains g where "continuous_map Y Z g" "g ` topspace Y = h ` topspace X"
                  "\<And>x. x \<in> topspace X \<Longrightarrow> g(f x) = h x"
proof -
  obtain g where g: "\<And>x. x \<in> topspace X \<Longrightarrow> h x = g(f x)"
    using function_factors_left_gen[of "\<lambda>x. x \<in> topspace X" f h] assms by blast
  show ?thesis
  proof
    show "g ` topspace Y = h ` topspace X"
      using f g by (force dest!: quotient_imp_surjective_map)
    show "continuous_map Y Z g"
      by (smt (verit)  f g h continuous_compose_quotient_map_eq continuous_map_eq o_def)
  qed (simp add: g)
qed


subsection \<open>for set idioms theory\<close>

thm openin_relative_to
lemma closedin_relative_to:
   "(closedin X relative_to S) = closedin (subtopology X S)"
  by (force simp: relative_to_def closedin_subtopology)

lemma countable_union_of_empty [simp]: "(countable union_of P) {}"
  by (simp add: union_of_empty)

lemma countable_intersection_of_empty [simp]: "(countable intersection_of P) UNIV"
  by (simp add: intersection_of_empty)

lemma countable_union_of_inc: "P S \<Longrightarrow> (countable union_of P) S"
  by (simp add: union_of_inc)

lemma countable_intersection_of_inc: "P S \<Longrightarrow> (countable intersection_of P) S"
  by (simp add: intersection_of_inc)

lemma countable_union_of_complement:
  "(countable union_of P) S \<longleftrightarrow> (countable intersection_of (\<lambda>S. P(-S))) (-S)" 
  (is "?lhs=?rhs")
proof
  assume ?lhs
  then obtain \<U> where "countable \<U>" and \<U>: "\<U> \<subseteq> Collect P" "\<Union>\<U> = S"
    by (metis union_of_def)
  define \<U>' where "\<U>' \<equiv> (\<lambda>C. -C) ` \<U>"
  have "\<U>' \<subseteq> {S. P (- S)}" "\<Inter>\<U>' = -S"
    using \<U>'_def \<U> by auto
  then show ?rhs
    unfolding intersection_of_def by (metis \<U>'_def \<open>countable \<U>\<close> countable_image)
next
  assume ?rhs
  then obtain \<U> where "countable \<U>" and \<U>: "\<U> \<subseteq> {S. P (- S)}" "\<Inter>\<U> = -S"
    by (metis intersection_of_def)
  define \<U>' where "\<U>' \<equiv> (\<lambda>C. -C) ` \<U>"
  have "\<U>' \<subseteq> Collect P" "\<Union> \<U>' = S"
    using \<U>'_def \<U> by auto
  then show ?lhs
    unfolding union_of_def
    by (metis \<U>'_def \<open>countable \<U>\<close> countable_image)
qed

lemma countable_intersection_of_complement:
   "(countable intersection_of P) S \<longleftrightarrow> (countable union_of (\<lambda>S. P(- S))) (- S)"
  by (simp add: countable_union_of_complement)

lemma countable_union_of_explicit:
  assumes "P {}"
  shows "(countable union_of P) S \<longleftrightarrow>
         (\<exists>T. (\<forall>n::nat. P(T n)) \<and> \<Union>(range T) = S)" (is "?lhs=?rhs")
proof
  assume ?lhs
  then obtain \<U> where "countable \<U>" and \<U>: "\<U> \<subseteq> Collect P" "\<Union>\<U> = S"
    by (metis union_of_def)
  then show ?rhs
    by (metis SUP_bot Sup_empty assms from_nat_into mem_Collect_eq range_from_nat_into subsetD)
next
  assume ?rhs
  then show ?lhs
    by (metis countableI_type countable_image image_subset_iff mem_Collect_eq union_of_def)
qed

lemma countable_union_of_ascending:
  assumes empty: "P {}" and Un: "\<And>T U. \<lbrakk>P T; P U\<rbrakk> \<Longrightarrow> P(T \<union> U)"
  shows "(countable union_of P) S \<longleftrightarrow>
         (\<exists>T. (\<forall>n. P(T n)) \<and> (\<forall>n. T n \<subseteq> T(Suc n)) \<and> \<Union>(range T) = S)" (is "?lhs=?rhs")
proof
  assume ?lhs
  then obtain T where T: "\<And>n::nat. P(T n)" "\<Union>(range T) = S"
    by (meson empty countable_union_of_explicit)
  have "P (\<Union> (T ` {..n}))" for n
    by (induction n) (auto simp: atMost_Suc Un T)
  with T show ?rhs
    by (rule_tac x="\<lambda>n. \<Union>k\<le>n. T k" in exI) force
next
  assume ?rhs
  then show ?lhs
    using empty countable_union_of_explicit by auto
qed

lemma countable_union_of_idem [simp]:
  "countable union_of countable union_of P = countable union_of P"  (is "?lhs=?rhs")
proof
  fix S
  show "(countable union_of countable union_of P) S = (countable union_of P) S"
  proof
    assume L: "?lhs S"
    then obtain \<U> where "countable \<U>" and \<U>: "\<U> \<subseteq> Collect (countable union_of P)" "\<Union>\<U> = S"
      by (metis union_of_def)
    then have "\<forall>U \<in> \<U>. \<exists>\<V>. countable \<V> \<and> \<V> \<subseteq> Collect P \<and> U = \<Union>\<V>"
      by (metis Ball_Collect union_of_def)
    then obtain \<F> where \<F>: "\<forall>U \<in> \<U>. countable (\<F> U) \<and> \<F> U \<subseteq> Collect P \<and> U = \<Union>(\<F> U)"
      by metis
    have "countable (\<Union> (\<F> ` \<U>))"
      using \<F> \<open>countable \<U>\<close> by blast
    moreover have "\<Union> (\<F> ` \<U>) \<subseteq> Collect P"
      by (simp add: Sup_le_iff \<F>)
    moreover have "\<Union> (\<Union> (\<F> ` \<U>)) = S"
      by auto (metis Union_iff \<F> \<U>(2))+
    ultimately show "?rhs S"
      by (meson union_of_def)
  qed (simp add: countable_union_of_inc)
qed

lemma countable_intersection_of_idem [simp]:
   "countable intersection_of countable intersection_of P =
        countable intersection_of P"
  by (force simp: countable_intersection_of_complement)

lemma countable_union_of_Union:
   "\<lbrakk>countable \<U>; \<And>S. S \<in> \<U> \<Longrightarrow> (countable union_of P) S\<rbrakk>
        \<Longrightarrow> (countable union_of P) (\<Union> \<U>)"
  by (metis Ball_Collect countable_union_of_idem union_of_def)

lemma countable_union_of_UN:
   "\<lbrakk>countable I; \<And>i. i \<in> I \<Longrightarrow> (countable union_of P) (U i)\<rbrakk>
        \<Longrightarrow> (countable union_of P) (\<Union>i\<in>I. U i)"
  by (metis (mono_tags, lifting) countable_image countable_union_of_Union imageE)

lemma countable_union_of_Un:
  "\<lbrakk>(countable union_of P) S; (countable union_of P) T\<rbrakk>
           \<Longrightarrow> (countable union_of P) (S \<union> T)"
  by (smt (verit) Union_Un_distrib countable_Un le_sup_iff union_of_def)

lemma countable_intersection_of_Inter:
   "\<lbrakk>countable \<U>; \<And>S. S \<in> \<U> \<Longrightarrow> (countable intersection_of P) S\<rbrakk>
        \<Longrightarrow> (countable intersection_of P) (\<Inter> \<U>)"
  by (metis countable_intersection_of_idem intersection_of_def mem_Collect_eq subsetI)

lemma countable_intersection_of_INT:
   "\<lbrakk>countable I; \<And>i. i \<in> I \<Longrightarrow> (countable intersection_of P) (U i)\<rbrakk>
        \<Longrightarrow> (countable intersection_of P) (\<Inter>i\<in>I. U i)"
  by (metis (mono_tags, lifting) countable_image countable_intersection_of_Inter imageE)

lemma countable_intersection_of_inter:
   "\<lbrakk>(countable intersection_of P) S; (countable intersection_of P) T\<rbrakk>
           \<Longrightarrow> (countable intersection_of P) (S \<inter> T)"
  by (simp add: countable_intersection_of_complement countable_union_of_Un)

lemma countable_union_of_Int:
  assumes S: "(countable union_of P) S" and T: "(countable union_of P) T"
    and Int: "\<And>S T. P S \<and> P T \<Longrightarrow> P(S \<inter> T)"
  shows "(countable union_of P) (S \<inter> T)"
proof -
  obtain \<U> where "countable \<U>" and \<U>: "\<U> \<subseteq> Collect P" "\<Union>\<U> = S"
    using S by (metis union_of_def)
  obtain \<V> where "countable \<V>" and \<V>: "\<V> \<subseteq> Collect P" "\<Union>\<V> = T"
    using T by (metis union_of_def)
  have "\<And>U V. \<lbrakk>U \<in> \<U>; V \<in> \<V>\<rbrakk> \<Longrightarrow> (countable union_of P) (U \<inter> V)"
    using \<U> \<V> by (metis Ball_Collect countable_union_of_inc local.Int)
  then have "(countable union_of P) (\<Union>U\<in>\<U>. \<Union>V\<in>\<V>. U \<inter> V)"
    by (meson \<open>countable \<U>\<close> \<open>countable \<V>\<close> countable_union_of_UN)
  moreover have "S \<inter> T = (\<Union>U\<in>\<U>. \<Union>V\<in>\<V>. U \<inter> V)"
    by (simp add: \<U> \<V>)
  ultimately show ?thesis
    by presburger
qed


lemma countable_intersection_of_union:
  assumes S: "(countable intersection_of P) S" and T: "(countable intersection_of P) T"
    and Un: "\<And>S T. P S \<and> P T \<Longrightarrow> P(S \<union> T)"
  shows "(countable intersection_of P) (S \<union> T)"
  by (metis (mono_tags, lifting) Compl_Int S T Un compl_sup countable_intersection_of_complement countable_union_of_Int)


lemma homeomorphic_space_prod_topology_swap:
   "(prod_topology X Y) homeomorphic_space (prod_topology Y X)"
  using homeomorphic_map_swap homeomorphic_space by blast

subsection\<open> for open map and closed map\<close>

lemma closed_map_closure_of_image:
   "closed_map X Y f \<longleftrightarrow>
        f ` topspace X \<subseteq> topspace Y \<and>
        (\<forall>S. S \<subseteq> topspace X \<longrightarrow> Y closure_of (f ` S) \<subseteq> image f (X closure_of S))" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (simp add: closed_map_def closed_map_imp_subset_topspace closure_of_minimal closure_of_subset image_mono)
next
  assume ?rhs
  then show ?lhs
    by (metis closed_map_def closed_map_into_discrete_topology closure_of_eq 
        closure_of_subset_eq topspace_discrete_topology)
qed

lemma open_map_interior_of_image_subset:
  "open_map X Y f \<longleftrightarrow> (\<forall>S. image f (X interior_of S) \<subseteq> Y interior_of (f ` S))"
  by (metis image_mono interior_of_eq interior_of_maximal interior_of_subset open_map_def openin_interior_of subset_antisym)

lemma open_map_interior_of_image_subset_alt:
  "open_map X Y f \<longleftrightarrow> (\<forall>S\<subseteq>topspace X. f ` (X interior_of S) \<subseteq> Y interior_of f ` S)"
  by (metis interior_of_eq open_map_def open_map_interior_of_image_subset openin_subset subset_interior_of_eq)

lemma open_map_interior_of_image_subset_gen:
  "open_map X Y f \<longleftrightarrow>
       (f ` topspace X \<subseteq> topspace Y \<and> (\<forall>S. f ` (X interior_of S) \<subseteq> Y interior_of f ` S))"
  by (meson open_map_imp_subset_topspace open_map_interior_of_image_subset)

lemma open_map_preimage_neighbourhood:
   "open_map X Y f \<longleftrightarrow>
    (f ` topspace X \<subseteq> topspace Y \<and>
     (\<forall>U T. closedin X U \<and> T \<subseteq> topspace Y \<and>
            {x \<in> topspace X. f x \<in> T} \<subseteq> U \<longrightarrow>
            (\<exists>V. closedin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U)))" (is "?lhs=?rhs")
proof
  assume L: ?lhs
  show ?rhs
  proof (intro conjI strip)
    show "f ` topspace X \<subseteq> topspace Y"
      by (simp add: \<open>open_map X Y f\<close> open_map_imp_subset_topspace)
  next
    fix U T
    assume UT: "closedin X U \<and> T \<subseteq> topspace Y \<and> {x \<in> topspace X. f x \<in> T} \<subseteq> U"
    have "closedin Y (topspace Y - f ` (topspace X - U))"
      by (meson UT L open_map_def openin_closedin_eq openin_diff openin_topspace)
    with UT
    show "\<exists>V. closedin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U"
      using image_iff by auto
  qed
next
  assume R: ?rhs
  show ?lhs
    unfolding open_map_def
  proof (intro strip)
    fix U assume "openin X U"
    have "{x \<in> topspace X. f x \<in> topspace Y - f ` U} \<subseteq> topspace X - U"
      by blast
    then obtain V where V: "closedin Y V" 
      and sub: "topspace Y - f ` U \<subseteq> V" "{x \<in> topspace X. f x \<in> V} \<subseteq> topspace X - U"
      using R \<open>openin X U\<close> by (meson Diff_subset openin_closedin_eq) 
    then have "f ` U \<subseteq> topspace Y - V"
      using R \<open>openin X U\<close> openin_subset by fastforce
    with sub have "f ` U = topspace Y - V"
      by auto
    then show "openin Y (f ` U)"
      using V(1) by auto
  qed
qed


lemma closed_map_preimage_neighbourhood:
   "closed_map X Y f \<longleftrightarrow>
        image f (topspace X) \<subseteq> topspace Y \<and>
        (\<forall>U T. openin X U \<and> T \<subseteq> topspace Y \<and>
              {x \<in> topspace X. f x \<in> T} \<subseteq> U
              \<longrightarrow> (\<exists>V. openin Y V \<and> T \<subseteq> V \<and>
                      {x \<in> topspace X. f x \<in> V} \<subseteq> U))" (is "?lhs=?rhs")
proof
  assume L: ?lhs
  show ?rhs
  proof (intro conjI strip)
    show "f ` topspace X \<subseteq> topspace Y"
      by (simp add: L closed_map_imp_subset_topspace)
  next
    fix U T
    assume UT: "openin X U \<and> T \<subseteq> topspace Y \<and> {x \<in> topspace X. f x \<in> T} \<subseteq> U"
    then have "openin Y (topspace Y - f ` (topspace X - U))"
      by (meson L closed_map_def closedin_def closedin_diff closedin_topspace)
    then show "\<exists>V. openin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U"
      using UT image_iff by auto
  qed
next
  assume R: ?rhs
  show ?lhs
    unfolding closed_map_def
  proof (intro strip)
    fix U assume "closedin X U"
    have "{x \<in> topspace X. f x \<in> topspace Y - f ` U} \<subseteq> topspace X - U"
      by blast
    then obtain V where V: "openin Y V" 
      and sub: "topspace Y - f ` U \<subseteq> V" "{x \<in> topspace X. f x \<in> V} \<subseteq> topspace X - U"
      using R Diff_subset \<open>closedin X U\<close> unfolding closedin_def
      by (smt (verit, ccfv_threshold) Collect_mem_eq Collect_mono_iff)
    then have "f ` U \<subseteq> topspace Y - V"
      using R \<open>closedin X U\<close> closedin_subset by fastforce
    with sub have "f ` U = topspace Y - V"
      by auto
    then show "closedin Y (f ` U)"
      using V(1) by auto
  qed
qed


lemma closed_map_fibre_neighbourhood:
  "closed_map X Y f \<longleftrightarrow>
     f ` (topspace X) \<subseteq> topspace Y \<and>
     (\<forall>U y. openin X U \<and> y \<in> topspace Y \<and> {x \<in> topspace X. f x = y} \<subseteq> U
     \<longrightarrow> (\<exists>V. openin Y V \<and> y \<in> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U))"
  unfolding closed_map_preimage_neighbourhood
proof (intro conj_cong refl all_cong1)
  fix U
  assume "f ` topspace X \<subseteq> topspace Y"
  show "(\<forall>T. openin X U \<and> T \<subseteq> topspace Y \<and> {x \<in> topspace X. f x \<in> T} \<subseteq> U 
         \<longrightarrow> (\<exists>V. openin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U))
      = (\<forall>y. openin X U \<and> y \<in> topspace Y \<and> {x \<in> topspace X. f x = y} \<subseteq> U 
         \<longrightarrow> (\<exists>V. openin Y V \<and> y \<in> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U))" 
    (is "(\<forall>T. ?P T) \<longleftrightarrow> (\<forall>y. ?Q y)")
  proof
    assume L [rule_format]: "\<forall>T. ?P T"
    show "\<forall>y. ?Q y"
    proof
      fix y show "?Q y"
        using L [of "{y}"] by blast
    qed
  next
    assume R: "\<forall>y. ?Q y"
    show "\<forall>T. ?P T"
    proof (cases "openin X U")
      case True
      note [[unify_search_bound=3]]
      obtain V where V: "\<And>y. \<lbrakk>y \<in> topspace Y; {x \<in> topspace X. f x = y} \<subseteq> U\<rbrakk> \<Longrightarrow>
                       openin Y (V y) \<and> y \<in> V y \<and> {x \<in> topspace X. f x \<in> V y} \<subseteq> U"
        using R by (simp add: True) meson
      show ?thesis
      proof clarify
        fix T
        assume "openin X U" and "T \<subseteq> topspace Y" and "{x \<in> topspace X. f x \<in> T} \<subseteq> U"
        with V show "\<exists>V. openin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U"
          by (rule_tac x="\<Union>y\<in>T. V y" in exI) fastforce
      qed
    qed auto
  qed
qed

lemma open_map_in_subtopology:
   "openin Y S
        \<Longrightarrow> (open_map X (subtopology Y S) f \<longleftrightarrow> open_map X Y f \<and> f ` (topspace X) \<subseteq> S)"
  by (metis le_inf_iff open_map_def open_map_imp_subset_topspace open_map_into_subtopology openin_trans_full topspace_subtopology)

lemma open_map_from_open_subtopology:
   "\<lbrakk>openin Y S; open_map X (subtopology Y S) f\<rbrakk> \<Longrightarrow> open_map X Y f"
  using open_map_in_subtopology by blast

lemma closed_map_in_subtopology:
   "closedin Y S
        \<Longrightarrow> closed_map X (subtopology Y S) f \<longleftrightarrow> (closed_map X Y f \<and> f ` topspace X \<subseteq> S)"
  by (metis closed_map_def closed_map_imp_subset_topspace closed_map_into_subtopology 
        closedin_closed_subtopology closedin_subset topspace_subtopology_subset)


lemma closed_map_from_closed_subtopology:
   "\<lbrakk>closedin Y S; closed_map X (subtopology Y S) f\<rbrakk> \<Longrightarrow> closed_map X Y f"
  using closed_map_in_subtopology by blast

lemma closed_map_from_composition_left:
  assumes cmf: "closed_map X Z (g \<circ> f)" and contf: "continuous_map X Y f" and fim: "f ` topspace X = topspace Y"
  shows "closed_map Y Z g"
  unfolding closed_map_def
proof (intro strip)
  fix U assume "closedin Y U"
  then have "closedin X {x \<in> topspace X. f x \<in> U}"
    using contf closedin_continuous_map_preimage by blast
  then have "closedin Z ((g \<circ> f) ` {x \<in> topspace X. f x \<in> U})"
    using cmf closed_map_def by blast
  moreover 
  have "\<And>y. y \<in> U \<Longrightarrow> \<exists>x \<in> topspace X. f x \<in> U \<and> g y = g (f x)"
    by (smt (verit, ccfv_SIG) \<open>closedin Y U\<close> closedin_subset fim image_iff subsetD)
  then have "(g \<circ> f) ` {x \<in> topspace X. f x \<in> U} = g`U" by auto
  ultimately show "closedin Z (g ` U)"
    by metis
qed

text \<open>identical proof as the above\<close>
lemma open_map_from_composition_left:
  assumes cmf: "open_map X Z (g \<circ> f)" and contf: "continuous_map X Y f" and fim: "f ` topspace X = topspace Y"
  shows "open_map Y Z g"
  unfolding open_map_def
proof (intro strip)
  fix U assume "openin Y U"
  then have "openin X {x \<in> topspace X. f x \<in> U}"
    using contf openin_continuous_map_preimage by blast
  then have "openin Z ((g \<circ> f) ` {x \<in> topspace X. f x \<in> U})"
    using cmf open_map_def by blast
  moreover 
  have "\<And>y. y \<in> U \<Longrightarrow> \<exists>x \<in> topspace X. f x \<in> U \<and> g y = g (f x)"
    by (smt (verit, ccfv_SIG) \<open>openin Y U\<close> openin_subset fim image_iff subsetD)
  then have "(g \<circ> f) ` {x \<in> topspace X. f x \<in> U} = g`U" by auto
  ultimately show "openin Z (g ` U)"
    by metis
qed

lemma closed_map_from_composition_right:
  assumes cmf: "closed_map X Z (g \<circ> f)" "f ` topspace X \<subseteq> topspace Y" "continuous_map Y Z g" "inj_on g (topspace Y)"
  shows "closed_map X Y f"
  unfolding closed_map_def
proof (intro strip)
  fix C assume "closedin X C"
  have "\<And>y c. \<lbrakk>y \<in> topspace Y; g y = g (f c); c \<in> C\<rbrakk> \<Longrightarrow> y \<in> f ` C"
    using \<open>closedin X C\<close> assms closedin_subset inj_onD by fastforce
  then
  have "f ` C = {x \<in> topspace Y. g x \<in> (g \<circ> f) ` C}"
    using \<open>closedin X C\<close> assms(2) closedin_subset by fastforce
  moreover have "closedin Z ((g \<circ> f) ` C)"
    using \<open>closedin X C\<close> cmf closed_map_def by blast
  ultimately show "closedin Y (f ` C)"
    using assms(3) closedin_continuous_map_preimage by fastforce
qed

text \<open>identical proof as the above\<close>
lemma open_map_from_composition_right:
  assumes "open_map X Z (g \<circ> f)" "f ` topspace X \<subseteq> topspace Y" "continuous_map Y Z g" "inj_on g (topspace Y)"
  shows "open_map X Y f"
  unfolding open_map_def
proof (intro strip)
  fix C assume "openin X C"
  have "\<And>y c. \<lbrakk>y \<in> topspace Y; g y = g (f c); c \<in> C\<rbrakk> \<Longrightarrow> y \<in> f ` C"
    using \<open>openin X C\<close> assms openin_subset inj_onD by fastforce
  then
  have "f ` C = {x \<in> topspace Y. g x \<in> (g \<circ> f) ` C}"
    using \<open>openin X C\<close> assms(2) openin_subset by fastforce
  moreover have "openin Z ((g \<circ> f) ` C)"
    using \<open>openin X C\<close> assms(1) open_map_def by blast
  ultimately show "openin Y (f ` C)"
    using assms(3) openin_continuous_map_preimage by fastforce
qed


subsection\<open> F-sigma and G-delta sets in a topological space.                          \<close>

definition fsigma_in 
  where "fsigma_in X \<equiv> countable union_of closedin X"

definition gdelta_in 
  where "gdelta_in X \<equiv> (countable intersection_of openin X) relative_to topspace X"

lemma fsigma_in_ascending:
   "fsigma_in X S \<longleftrightarrow> (\<exists>c. (\<forall>n. closedin X (c n)) \<and> (\<forall>n. c n \<subseteq> c(Suc n)) \<and> \<Union> (range c) = S)"
  unfolding fsigma_in_def
  by (metis closedin_Un countable_union_of_ascending closedin_empty)

lemma gdelta_in_alt:
   "gdelta_in X S \<longleftrightarrow> S \<subseteq> topspace X \<and> (countable intersection_of openin X) S"
proof -
  have "(countable intersection_of openin X) (topspace X)"
    by (simp add: countable_intersection_of_inc)
  then show ?thesis
    unfolding gdelta_in_def
    by (metis countable_intersection_of_inter relative_to_def relative_to_imp_subset relative_to_subset)
qed

lemma fsigma_in_subset: "fsigma_in X S \<Longrightarrow> S \<subseteq> topspace X"
  using closedin_subset by (fastforce simp add: fsigma_in_def union_of_def subset_iff)

lemma gdelta_in_subset: "gdelta_in X S \<Longrightarrow> S \<subseteq> topspace X"
  by (simp add: gdelta_in_alt)

lemma closed_imp_fsigma_in: "closedin X S \<Longrightarrow> fsigma_in X S"
  by (simp add: countable_union_of_inc fsigma_in_def)

lemma open_imp_gdelta_in: "openin X S \<Longrightarrow> gdelta_in X S"
  by (simp add: countable_intersection_of_inc gdelta_in_alt openin_subset)

lemma fsigma_in_empty [iff]: "fsigma_in X {}"
  by (simp add: closed_imp_fsigma_in)

lemma gdelta_in_empty [iff]: "gdelta_in X {}"
  by (simp add: open_imp_gdelta_in)

lemma fsigma_in_topspace [iff]: "fsigma_in X (topspace X)"
  by (simp add: closed_imp_fsigma_in)

lemma gdelta_in_topspace [iff]: "gdelta_in X (topspace X)"
  by (simp add: open_imp_gdelta_in)

lemma fsigma_in_Union:
   "\<lbrakk>countable T; \<And>S. S \<in> T \<Longrightarrow> fsigma_in X S\<rbrakk> \<Longrightarrow> fsigma_in X (\<Union> T)"
  by (simp add: countable_union_of_Union fsigma_in_def)

lemma fsigma_in_Un:
   "\<lbrakk>fsigma_in X S; fsigma_in X T\<rbrakk> \<Longrightarrow> fsigma_in X (S \<union> T)"
  by (simp add: countable_union_of_Un fsigma_in_def)

lemma fsigma_in_Int:
   "\<lbrakk>fsigma_in X S; fsigma_in X T\<rbrakk> \<Longrightarrow> fsigma_in X (S \<inter> T)"
  by (simp add: closedin_Int countable_union_of_Int fsigma_in_def)

lemma gdelta_in_Inter:
   "\<lbrakk>countable T; T\<noteq>{}; \<And>S. S \<in> T \<Longrightarrow> gdelta_in X S\<rbrakk> \<Longrightarrow> gdelta_in X (\<Inter> T)"
  by (simp add: Inf_less_eq countable_intersection_of_Inter gdelta_in_alt)

lemma gdelta_in_Int:
   "\<lbrakk>gdelta_in X S; gdelta_in X T\<rbrakk> \<Longrightarrow> gdelta_in X (S \<inter> T)"
  by (simp add: countable_intersection_of_inter gdelta_in_alt le_infI2)

lemma gdelta_in_Un:
   "\<lbrakk>gdelta_in X S; gdelta_in X T\<rbrakk> \<Longrightarrow> gdelta_in X (S \<union> T)"
  by (simp add: countable_intersection_of_union gdelta_in_alt openin_Un)

lemma fsigma_in_diff:
  assumes "fsigma_in X S" "gdelta_in X T"
  shows "fsigma_in X (S - T)"
proof -
  have [simp]: "S - (S \<inter> T) = S - T" for S T :: "'a set"
    by auto
  have [simp]: "topspace X - \<Inter>\<T> = (\<Union>T\<in>\<T>. topspace X - T)" for \<T>
    by auto
  have "\<And>\<T>. \<lbrakk>countable \<T>; \<T> \<subseteq> Collect (openin X)\<rbrakk> \<Longrightarrow>
             (countable union_of closedin X) (\<Union> ((-) (topspace X) ` \<T>))"
    by (metis Ball_Collect countable_union_of_UN countable_union_of_inc openin_closedin_eq)
  then have "\<forall>S. gdelta_in X S \<longrightarrow> fsigma_in X (topspace X - S)"
    by (simp add: fsigma_in_def gdelta_in_def all_relative_to all_intersection_of del: UN_simps)
  then show ?thesis
    by (metis Diff_Int2 Diff_Int_distrib2 assms fsigma_in_Int fsigma_in_subset inf.absorb_iff2)
qed

lemma gdelta_in_diff:
  assumes "gdelta_in X S" "fsigma_in X T"
  shows "gdelta_in X (S - T)"
proof -
  have [simp]: "topspace X - \<Union>\<T> = topspace X \<inter> (\<Inter>T\<in>\<T>. topspace X - T)" for \<T>
    by auto
  have "\<And>\<T>. \<lbrakk>countable \<T>; \<T> \<subseteq> Collect (closedin X)\<rbrakk>
         \<Longrightarrow> (countable intersection_of openin X relative_to topspace X)
              (topspace X \<inter> \<Inter> ((-) (topspace X) ` \<T>))"
    by (metis Ball_Collect closedin_def countable_intersection_of_INT countable_intersection_of_inc relative_to_inc)
  then have "\<forall>S. fsigma_in X S \<longrightarrow> gdelta_in X (topspace X - S)"
    by (simp add: fsigma_in_def gdelta_in_def all_union_of del: INT_simps)
  then show ?thesis
    by (metis Diff_Int2 Diff_Int_distrib2 assms gdelta_in_Int gdelta_in_alt inf.orderE inf_commute)
qed

lemma gdelta_in_fsigma_in:
   "gdelta_in X S \<longleftrightarrow> S \<subseteq> topspace X \<and> fsigma_in X (topspace X - S)"
  by (metis double_diff fsigma_in_diff fsigma_in_topspace gdelta_in_alt gdelta_in_diff gdelta_in_topspace)

lemma fsigma_in_gdelta_in:
   "fsigma_in X S \<longleftrightarrow> S \<subseteq> topspace X \<and> gdelta_in X (topspace X - S)"
  by (metis Diff_Diff_Int fsigma_in_subset gdelta_in_fsigma_in inf.absorb_iff2)

lemma gdelta_in_descending:
   "gdelta_in X S \<longleftrightarrow> (\<exists>c. (\<forall>n. openin X (c n)) \<and> (\<forall>n. c(Suc n) \<subseteq> c n) \<and> \<Inter>(range c) = S)" (is "?lhs=?rhs")
proof
  assume ?lhs
  then obtain c where c: "S \<subseteq> topspace X" "\<And>n. closedin X (c n)" 
                         "\<And>n. c n \<subseteq> c(Suc n)" "\<Union>(range c) = topspace X - S"
    by (meson fsigma_in_ascending gdelta_in_fsigma_in)
  define d where "d \<equiv> \<lambda>n. topspace X - c n"
  have "\<And>n. openin X (d n) \<and> d (Suc n) \<subseteq> d n"
    by (simp add: Diff_mono c d_def openin_diff)
  moreover have "\<Inter>(range d) = S"
    by (simp add: Diff_Diff_Int Int_absorb1 c d_def)
  ultimately show ?rhs
    by metis
next
  assume ?rhs
  then obtain c where "S \<subseteq> topspace X" 
                and c: "\<And>n. openin X (c n)" "\<And>n. c(Suc n) \<subseteq> c n" "\<Inter>(range c) = S"
    using openin_subset by fastforce
  define d where "d \<equiv> \<lambda>n. topspace X - c n"
  have "\<And>n. closedin X (d n) \<and> d n \<subseteq> d(Suc n)"
    by (simp add: Diff_mono c closedin_diff d_def)
  moreover have "\<Union>(range d) = topspace X - S"
    using c d_def by blast
  ultimately show ?lhs
    by (metis \<open>S \<subseteq> topspace X\<close> fsigma_in_ascending gdelta_in_fsigma_in)
qed

lemma homeomorphic_map_fsigmaness:
  assumes f: "homeomorphic_map X Y f" and "U \<subseteq> topspace X"
  shows "fsigma_in Y (f ` U) \<longleftrightarrow> fsigma_in X U"  (is "?lhs=?rhs")
proof -
  obtain g where g: "homeomorphic_maps X Y f g" and g: "homeomorphic_map Y X g"
    and 1: "(\<forall>x \<in> topspace X. g(f x) = x)" and 2: "(\<forall>y \<in> topspace Y. f(g y) = y)"
    using assms homeomorphic_map_maps by (metis homeomorphic_maps_map)
  show ?thesis
  proof
    assume ?lhs
    then obtain \<V> where "countable \<V>" and \<V>: "\<V> \<subseteq> Collect (closedin Y)" "\<Union>\<V> = f`U"
      by (force simp: fsigma_in_def union_of_def)
    define \<U> where "\<U> \<equiv> image (image g) \<V>"
    have "countable \<U>"
      using \<U>_def \<open>countable \<V>\<close> by blast
    moreover have "\<U> \<subseteq> Collect (closedin X)"
      using f g homeomorphic_map_closedness_eq \<V> unfolding \<U>_def by blast
    moreover have "\<Union>\<U> \<subseteq> U"
      unfolding \<U>_def  by (smt (verit) assms 1 \<V> image_Union image_iff in_mono subsetI)
    moreover have "U \<subseteq> \<Union>\<U>"
      unfolding \<U>_def using assms \<V>
      by (smt (verit, del_insts) "1" imageI image_Union subset_iff)
    ultimately show ?rhs
      by (metis fsigma_in_def subset_antisym union_of_def)
  next
    assume ?rhs
    then obtain \<V> where "countable \<V>" and \<V>: "\<V> \<subseteq> Collect (closedin X)" "\<Union>\<V> = U"
      by (auto simp: fsigma_in_def union_of_def)
    define \<U> where "\<U> \<equiv> image (image f) \<V>"
    have "countable \<U>"
      using \<U>_def \<open>countable \<V>\<close> by blast
    moreover have "\<U> \<subseteq> Collect (closedin Y)"
      using f g homeomorphic_map_closedness_eq \<V> unfolding \<U>_def by blast
    moreover have "\<Union>\<U> = f`U"
      unfolding \<U>_def using \<V> by blast
    ultimately show ?lhs
      by (metis fsigma_in_def union_of_def)
  qed
qed

lemma homeomorphic_map_fsigmaness_eq:
   "homeomorphic_map X Y f
        \<Longrightarrow> (fsigma_in X U \<longleftrightarrow> U \<subseteq> topspace X \<and> fsigma_in Y (f ` U))"
  by (metis fsigma_in_subset homeomorphic_map_fsigmaness)

lemma homeomorphic_map_gdeltaness:
  assumes "homeomorphic_map X Y f" "U \<subseteq> topspace X"
  shows "gdelta_in Y (f ` U) \<longleftrightarrow> gdelta_in X U"
proof -
  have "topspace Y - f ` U = f ` (topspace X - U)"
    by (metis (no_types, lifting) Diff_subset assms homeomorphic_eq_everything_map inj_on_image_set_diff)
  then show ?thesis
    using assms homeomorphic_imp_surjective_map
    by (fastforce simp: gdelta_in_fsigma_in homeomorphic_map_fsigmaness_eq)
qed

lemma homeomorphic_map_gdeltaness_eq:
   "homeomorphic_map X Y f
        \<Longrightarrow> (gdelta_in X U \<longleftrightarrow>
             U \<subseteq> topspace X \<and> gdelta_in Y (f ` U))"
  by (meson gdelta_in_subset homeomorphic_map_gdeltaness)

lemma fsigma_in_relative_to:
   "(fsigma_in X relative_to S) = fsigma_in (subtopology X S)"
  by (simp add: fsigma_in_def countable_union_of_relative_to closedin_relative_to)

lemma fsigma_in_subtopology:
   "fsigma_in (subtopology X U) S \<longleftrightarrow> (\<exists>T. fsigma_in X T \<and> S = T \<inter> U)"
  by (metis fsigma_in_relative_to inf_commute relative_to_def)

lemma gdelta_in_relative_to:
   "(gdelta_in X relative_to S) = gdelta_in (subtopology X S)"
  apply (simp add: gdelta_in_def)
  by (metis countable_intersection_of_relative_to openin_relative_to subtopology_restrict)

lemma gdelta_in_subtopology:
   "gdelta_in (subtopology X U) S \<longleftrightarrow> (\<exists>T. gdelta_in X T \<and> S = T \<inter> U)"
  by (metis gdelta_in_relative_to inf_commute relative_to_def)

lemma fsigma_in_fsigma_subtopology:
   "fsigma_in X S \<Longrightarrow> (fsigma_in (subtopology X S) T \<longleftrightarrow> fsigma_in X T \<and> T \<subseteq> S)"
  by (metis fsigma_in_Int fsigma_in_gdelta_in fsigma_in_subtopology inf.orderE topspace_subtopology_subset)

lemma gdelta_in_gdelta_subtopology:
   "gdelta_in X S \<Longrightarrow> (gdelta_in (subtopology X S) T \<longleftrightarrow> gdelta_in X T \<and> T \<subseteq> S)"
  by (metis gdelta_in_Int gdelta_in_subset gdelta_in_subtopology inf.orderE topspace_subtopology_subset)


subsection\<open> Disjoint sum of arbitarily many spaces\<close>

definition sum_topology :: "('a \<Rightarrow> 'b topology) \<Rightarrow> 'a set \<Rightarrow> ('a \<times> 'b) topology" where
  "sum_topology X I \<equiv>
    topology (\<lambda>U. U \<subseteq> Sigma I (topspace \<circ> X) \<and> (\<forall>i \<in> I. openin (X i) {x. (i,x) \<in> U}))"

lemma is_sum_topology: "istopology (\<lambda>U. U \<subseteq> Sigma I (topspace \<circ> X) \<and> (\<forall>i\<in>I. openin (X i) {x. (i, x) \<in> U}))"
proof -
  have 1: "{x. (i, x) \<in> S \<inter> T} = {x. (i, x) \<in> S} \<inter> {x::'b. (i, x) \<in> T}" for S T and i::'a
    by auto
  have 2: "{x. (i, x) \<in> \<Union> \<K>} = (\<Union>K\<in>\<K>. {x::'b. (i, x) \<in> K})" for \<K> and i::'a
    by auto
  show ?thesis
    unfolding istopology_def 1 2 by blast
qed

lemma openin_sum_topology:
   "openin (sum_topology X I) U \<longleftrightarrow>
        U \<subseteq> Sigma I (topspace \<circ> X) \<and> (\<forall>i \<in> I. openin (X i) {x. (i,x) \<in> U})"
  by (auto simp: sum_topology_def is_sum_topology)

lemma openin_disjoint_union:
   "openin (sum_topology X I) (Sigma I U) \<longleftrightarrow> (\<forall>i \<in> I. openin (X i) (U i))"
  using openin_subset by (force simp: openin_sum_topology)

lemma topspace_sum_topology [simp]:
   "topspace(sum_topology X I) = Sigma I (topspace \<circ> X)"
  by (metis comp_apply openin_disjoint_union openin_subset openin_sum_topology openin_topspace subset_antisym)

lemma openin_sum_topology_alt:
   "openin (sum_topology X I) U \<longleftrightarrow> (\<exists>T. U = Sigma I T \<and> (\<forall>i \<in> I. openin (X i) (T i)))"
  by (bestsimp simp add: openin_sum_topology dest: openin_subset)

lemma forall_openin_sum_topology:
   "(\<forall>U. openin (sum_topology X I) U \<longrightarrow> P U) \<longleftrightarrow> (\<forall>T. (\<forall>i \<in> I. openin (X i) (T i)) \<longrightarrow> P(Sigma I T))"
  by (auto simp add: openin_sum_topology_alt)

lemma exists_openin_sum_topology:
   "(\<exists>U. openin (sum_topology X I) U \<and> P U) \<longleftrightarrow>
    (\<exists>T. (\<forall>i \<in> I. openin (X i) (T i)) \<and> P(Sigma I T))"
  by (auto simp add: openin_sum_topology_alt)

lemma closedin_sum_topology:
   "closedin (sum_topology X I) U \<longleftrightarrow> U \<subseteq> Sigma I (topspace \<circ> X) \<and> (\<forall>i \<in> I. closedin (X i) {x. (i,x) \<in> U})"
     (is "?lhs = ?rhs")
proof
  assume L: ?lhs
  then have U: "U \<subseteq> Sigma I (topspace \<circ> X)"
    using closedin_subset by fastforce
  then have "\<forall>i\<in>I. {x. (i, x) \<in> U} \<subseteq> topspace (X i)"
    by fastforce
  moreover have "openin (X i) (topspace (X i) - {x. (i, x) \<in> U})" if "i\<in>I" for i
    apply (subst openin_subopen)
    using L that unfolding closedin_def openin_sum_topology
    by (bestsimp simp: o_def subset_iff)
  ultimately show ?rhs
    by (simp add: U closedin_def)
next
  assume R: ?rhs
  then have "openin (X i) {x. (i, x) \<in> topspace (sum_topology X I) - U}" if "i\<in>I" for i
    apply (subst openin_subopen)
    using that unfolding closedin_def openin_sum_topology
    by (bestsimp simp: o_def subset_iff)
  then show ?lhs
    by (simp add: R closedin_def openin_sum_topology)
qed

lemma closedin_disjoint_union:
   "closedin (sum_topology X I) (Sigma I U) \<longleftrightarrow> (\<forall>i \<in> I. closedin (X i) (U i))"
  using closedin_subset by (force simp: closedin_sum_topology)

lemma closedin_sum_topology_alt:
   "closedin (sum_topology X I) U \<longleftrightarrow> (\<exists>T. U = Sigma I T \<and> (\<forall>i \<in> I. closedin (X i) (T i)))"
  using closedin_subset unfolding closedin_sum_topology by auto blast

lemma forall_closedin_sum_topology:
   "(\<forall>U. closedin (sum_topology X I) U \<longrightarrow> P U) \<longleftrightarrow>
        (\<forall>t. (\<forall>i \<in> I. closedin (X i) (t i)) \<longrightarrow> P(Sigma I t))"
  by (metis closedin_sum_topology_alt)

lemma exists_closedin_sum_topology:
   "(\<exists>U. closedin (sum_topology X I) U \<and> P U) \<longleftrightarrow>
    (\<exists>T. (\<forall>i \<in> I. closedin (X i) (T i)) \<and> P(Sigma I T))"
  by (simp add: closedin_sum_topology_alt) blast

lemma open_map_component_injection:
   "i \<in> I \<Longrightarrow> open_map (X i) (sum_topology X I) (\<lambda>x. (i,x))"
  unfolding open_map_def openin_sum_topology
  using openin_subset openin_subopen by (force simp: image_iff)

lemma closed_map_component_injection:
  assumes "i \<in> I"
  shows "closed_map(X i) (sum_topology X I) (\<lambda>x. (i,x))"
proof -
  have "closedin (X j) {x. j = i \<and> x \<in> U}"
    if "\<And>U S. closedin U S \<Longrightarrow> S \<subseteq> topspace U" and "closedin (X i) U" and "j \<in> I" for U j
    using that by (cases "j=i") auto
  then show ?thesis
    using closedin_subset assms by (force simp: closed_map_def closedin_sum_topology image_iff)
qed

lemma continuous_map_component_injection:
   "i \<in> I \<Longrightarrow> continuous_map(X i) (sum_topology X I) (\<lambda>x. (i,x))"
  apply (clarsimp simp: continuous_map_def openin_sum_topology)
  by (smt (verit, best) Collect_cong mem_Collect_eq openin_subset subsetD)

lemma subtopology_sum_topology:
  "subtopology (sum_topology X I) (Sigma I S) =
        sum_topology (\<lambda>i. subtopology (X i) (S i)) I"
  unfolding topology_eq
proof (intro strip iffI)
  fix T
  assume *: "openin (subtopology (sum_topology X I) (Sigma I S)) T"
  then obtain U where U: "\<forall>i\<in>I. openin (X i) (U i) \<and> T = Sigma I U \<inter> Sigma I S" 
    by (auto simp: openin_subtopology openin_sum_topology_alt)
  have "T = (SIGMA i:I. U i \<inter> S i)"
  proof
    show "T \<subseteq> (SIGMA i:I. U i \<inter> S i)"
      by (metis "*" SigmaE Sigma_Int_distrib2 U openin_imp_subset subset_iff)
    show "(SIGMA i:I. U i \<inter> S i) \<subseteq> T"
      using U by fastforce
  qed
  then show "openin (sum_topology (\<lambda>i. subtopology (X i) (S i)) I) T"
    by (simp add: U openin_disjoint_union openin_subtopology_Int)
next
  fix T
  assume *: "openin (sum_topology (\<lambda>i. subtopology (X i) (S i)) I) T"
  then obtain U where "\<forall>i\<in>I. \<exists>T. openin (X i) T \<and> U i = T \<inter> S i" and Teq: "T = Sigma I U"
    by (auto simp: openin_subtopology openin_sum_topology_alt)
  then obtain B where "\<And>i. i\<in>I \<Longrightarrow> openin (X i) (B i) \<and> U i = B i \<inter> S i"
    by metis
  then show "openin (subtopology (sum_topology X I) (Sigma I S)) T"
    by (auto simp: openin_subtopology openin_sum_topology_alt Teq)
qed

lemma embedding_map_component_injection:
   "i \<in> I \<Longrightarrow> embedding_map (X i) (sum_topology X I) (\<lambda>x. (i,x))"
  by (metis injective_open_imp_embedding_map continuous_map_component_injection
            open_map_component_injection inj_onI prod.inject)


subsection\<open>Metric spaces\<close>

(*Essential to avoid a clash with the existing metric_space locale (from the type class)*)
locale Metric_space =
  fixes M :: "'a set" and d :: "'a \<Rightarrow> 'a \<Rightarrow> real"
  assumes nonneg [simp]: "\<And>x y. 0 \<le> d x y"
  assumes commute: "\<And>x y. d x y = d y x"
  assumes zero [simp]: "\<And>x y. \<lbrakk>x \<in> M; y \<in> M\<rbrakk> \<Longrightarrow> d x y = 0 \<longleftrightarrow> x=y"
  assumes triangle: "\<And>x y z. \<lbrakk>x \<in> M; y \<in> M; z \<in> M\<rbrakk> \<Longrightarrow> d x z \<le> d x y + d y z"

text \<open>Link with the type class version\<close>
interpretation Met: Metric_space UNIV dist
  by (simp add: dist_commute dist_triangle Metric_space.intro)

(*NOT CLEAR WHETHER WE NEED/WANT THIS type definition*)
typedef 'a metric = "{(M::'a set,d). Metric_space M d}"
  morphisms "dest_metric" "metric"
proof -
  have "Metric_space {} (\<lambda>x y. 0)"
    by (auto simp: Metric_space_def)
  then show ?thesis
    by blast
qed

definition mspace where "mspace m = fst (dest_metric m)"

definition mdist where "mdist m = snd (dest_metric m)"

lemma metric_space_mspace_mdist: "Metric_space (mspace m) (mdist m)"
  by (metis Product_Type.Collect_case_prodD dest_metric mdist_def mspace_def)

context Metric_space
begin

(*
lemma metric [simp]:
   "mspace (metric (M,d)) = M \<and> mdist (metric (M,d)) = d"
  by (simp add: local.Metric_space_axioms mdist_def metric_inverse mspace_def)
*)

lemma subspace: "M' \<subseteq> M \<Longrightarrow> Metric_space M' d"
  by (simp add: commute in_mono Metric_space.intro triangle)

lemma abs_mdist [simp] : "\<bar>d x y\<bar> = d x y"
  by simp

lemma mdist_pos_less: "\<lbrakk>x \<noteq> y; x \<in> M; y \<in> M\<rbrakk> \<Longrightarrow> 0 < d x y"
  by (metis less_eq_real_def nonneg zero)

lemma mdist_refl [simp]: "x \<in> M \<Longrightarrow> d x x = 0"
  by simp

lemma mdist_pos_eq [simp]: "\<lbrakk>x \<in> M; y \<in> M\<rbrakk> \<Longrightarrow> 0 < d x y \<longleftrightarrow> x \<noteq> y"
  using mdist_pos_less zero by fastforce

lemma triangle': "\<lbrakk>x \<in> M; y \<in> M; z \<in> M\<rbrakk> \<Longrightarrow> d x z \<le> d x y + d z y"
  by (simp add: commute triangle)

lemma triangle'': "\<lbrakk>x \<in> M; y \<in> M; z \<in> M\<rbrakk> \<Longrightarrow> d x z \<le> d y x + d y z"
  by (simp add: commute triangle)

lemma mdist_reverse_triangle: "\<lbrakk>x \<in> M; y \<in> M; z \<in> M\<rbrakk> \<Longrightarrow> \<bar>d x y - d y z\<bar> \<le> d x z"
  by (smt (verit) commute triangle)

text\<open> Open and closed balls                                                                \<close>

definition mball where "mball x r \<equiv> {y. x \<in> M \<and> y \<in> M \<and> d x y < r}"
definition mcball where "mcball x r \<equiv> {y. x \<in> M \<and> y \<in> M \<and> d x y \<le> r}"

lemma in_mball [simp]: "y \<in> mball x r \<longleftrightarrow> x \<in> M \<and> y \<in> M \<and> d x y < r"
  by (simp add: local.Metric_space_axioms Metric_space.mball_def)

lemma centre_in_mball_iff [iff]: "x \<in> mball x r \<longleftrightarrow> x \<in> M \<and> 0 < r"
  using in_mball mdist_refl by force

lemma mball_subset_mspace: "mball x r \<subseteq> M"
  by auto

lemma mball_eq_empty: "mball x r = {} \<longleftrightarrow> (x \<notin> M) \<or> r \<le> 0"
  by (smt (verit, best) Collect_empty_eq centre_in_mball_iff mball_def nonneg)

lemma mball_subset: "\<lbrakk>d x y + a \<le> b; y \<in> M\<rbrakk> \<Longrightarrow> mball x a \<subseteq> mball y b"
  by (smt (verit) commute in_mball subsetI triangle)

lemma disjoint_mball: "r + r' \<le> d x x' \<Longrightarrow> disjnt (mball x r) (mball x' r')"
  by (smt (verit) commute disjnt_iff in_mball triangle)

lemma mball_subset_concentric: "r \<le> s \<Longrightarrow> mball x r \<subseteq> mball x s"
  by auto

lemma in_mcball [simp]: "y \<in> mcball x r \<longleftrightarrow> x \<in> M \<and> y \<in> M \<and> d x y \<le> r"
  by (simp add: local.Metric_space_axioms Metric_space.mcball_def)

lemma centre_in_mcball_iff [iff]: "x \<in> mcball x r \<longleftrightarrow> x \<in> M \<and> 0 \<le> r"
  using mdist_refl by force

lemma mcball_eq_empty: "mcball x r = {} \<longleftrightarrow> (x \<notin> M) \<or> r < 0"
  by (smt (verit, best) Collect_empty_eq centre_in_mcball_iff empty_iff mcball_def nonneg)

lemma mcball_subset_mspace: "mcball x r \<subseteq> M"
  by auto

lemma mball_subset_mcball: "mball x r \<subseteq> mcball x r"
  by auto

lemma mcball_subset: "\<lbrakk>d x y + a \<le> b; y \<in> M\<rbrakk> \<Longrightarrow> mcball x a \<subseteq> mcball y b"
  by (smt (verit) in_mcball mdist_reverse_triangle subsetI)

lemma mcball_subset_concentric: "r \<le> s \<Longrightarrow> mcball x r \<subseteq> mcball x s"
  by force

lemma mcball_subset_mball: "\<lbrakk>d x y + a < b; y \<in> M\<rbrakk> \<Longrightarrow> mcball x a \<subseteq> mball y b"
  by (smt (verit) commute in_mball in_mcball subsetI triangle)

lemma mcball_subset_mball_concentric: "a < b \<Longrightarrow> mcball x a \<subseteq> mball x b"
  by force

end



subsection\<open> Metric topology                                                           \<close>

context Metric_space
begin

definition mopen where 
  "mopen U \<equiv> U \<subseteq> M \<and> (\<forall>x. x \<in> U \<longrightarrow> (\<exists>r>0. mball x r \<subseteq> U))"

definition mtopology :: "'a topology" where 
  "mtopology \<equiv> topology mopen"

lemma is_topology_metric_topology [iff]: "istopology mopen"
proof -
  have "\<And>S T. \<lbrakk>mopen S; mopen T\<rbrakk> \<Longrightarrow> mopen (S \<inter> T)"
    by (smt (verit, del_insts) Int_iff in_mball mopen_def subset_eq)
  moreover have "\<And>\<K>. (\<forall>K\<in>\<K>. mopen K) \<longrightarrow> mopen (\<Union>\<K>)"
    using mopen_def by fastforce
  ultimately show ?thesis
    by (simp add: istopology_def)
qed

lemma openin_mtopology: "openin mtopology U \<longleftrightarrow> U \<subseteq> M \<and> (\<forall>x. x \<in> U \<longrightarrow> (\<exists>r>0. mball x r \<subseteq> U))"
  by (simp add: mopen_def mtopology_def)

lemma topspace_mtopology [simp]: "topspace mtopology = M"
  by (meson order.refl mball_subset_mspace openin_mtopology openin_subset openin_topspace subset_antisym zero_less_one)

lemma subtopology_mspace [simp]: "subtopology mtopology M = mtopology"
  by (metis subtopology_topspace topspace_mtopology)

lemma open_in_mspace [iff]: "openin mtopology M"
  by (metis openin_topspace topspace_mtopology)

lemma closedin_mspace [iff]: "closedin mtopology M"
  by (metis closedin_topspace topspace_mtopology)

lemma openin_mball [iff]: "openin mtopology (mball x r)"
proof -
  have "\<And>y. \<lbrakk>x \<in> M; d x y < r\<rbrakk> \<Longrightarrow> \<exists>s>0. mball y s \<subseteq> mball x r"
    by (metis add_diff_cancel_left' add_diff_eq commute less_add_same_cancel1 mball_subset order_refl)
  then show ?thesis
    by (auto simp: openin_mtopology)
qed

lemma mcball_eq_cball [simp]: "Met.mcball = cball"
  by force

lemma mball_eq_ball [simp]: "Met.mball = ball"
  by force

lemma mopen_eq_open [simp]: "Met.mopen = open"
  by (force simp: open_contains_ball Met.mopen_def)

lemma limitin_iff_tendsto [iff]: "limitin Met.mtopology \<sigma> x F = tendsto \<sigma> x F"
  by (simp add: Met.mtopology_def)

(*
lemma metric_injective_image:
   "\<And>f m s.
        f ` s \<subseteq> M \<and>
        (\<forall>x y. x \<in> s \<and> y \<in> s \<and> f x = f y \<Longrightarrow> x = y)
        \<Longrightarrow> (mspace(metric(s,\<lambda>(x,y). d (f x) (f y))) = s) \<and>
            (d(metric(s,\<lambda>(x,y). d (f x) (f y))) =
             \<lambda>(x,y). d (f x) (f y))"
oops
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; INJECTIVE_ON_ALT] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  REWRITE_TAC[mspace; d; GSYM PAIR_EQ] THEN
  REWRITE_TAC[GSYM(CONJUNCT2 metric_tybij); is_metric_space] THEN
  REWRITE_TAC[GSYM mspace; GSYM d] THEN
  ASM_SIMP_TAC[MDIST_POS_LE; MDIST_TRIANGLE; MDIST_0] THEN
  ASM_MESON_TAC[MDIST_SYM]);;
*)

lemma mtopology_base:
   "mtopology = topology(arbitrary union_of (\<lambda>U. \<exists>x \<in> M. \<exists>r>0. U = mball x r))"
proof -
  have "\<And>S. \<exists>x r. x \<in> M \<and> 0 < r \<and> S = mball x r \<Longrightarrow> openin mtopology S"
    using openin_mball by blast
  moreover have "\<And>U x. \<lbrakk>openin mtopology U; x \<in> U\<rbrakk> \<Longrightarrow> \<exists>B. (\<exists>x r. x \<in> M \<and> 0 < r \<and> B = mball x r) \<and> x \<in> B \<and> B \<subseteq> U"
    by (metis centre_in_mball_iff in_mono openin_mtopology)
  ultimately show ?thesis
    by (smt (verit) topology_base_unique)
qed

lemma closedin_metric:
   "closedin mtopology C \<longleftrightarrow> C \<subseteq> M \<and> (\<forall>x. x \<in> M - C \<longrightarrow> (\<exists>r>0. disjnt C (mball x r)))"  (is "?lhs = ?rhs")
proof
  show "?lhs \<Longrightarrow> ?rhs"
    unfolding closedin_def openin_mtopology
    by (metis Diff_disjoint disjnt_def disjnt_subset2 topspace_mtopology)
  show "?rhs \<Longrightarrow> ?lhs"
    unfolding closedin_def openin_mtopology disjnt_def
    by (metis Diff_subset Diff_triv Int_Diff Int_commute inf.absorb_iff2 mball_subset_mspace topspace_mtopology)
qed

lemma closedin_mcball [iff]: "closedin mtopology (mcball x r)"
proof -
  have "\<exists>ra>0. disjnt (mcball x r) (mball y ra)" if "x \<notin> M" for y
    by (metis disjnt_empty1 gt_ex mcball_eq_empty that)
  moreover have "disjnt (mcball x r) (mball y (d x y - r))" if "y \<in> M" "d x y > r" for y
    using that disjnt_iff in_mball in_mcball mdist_reverse_triangle by force
  ultimately show ?thesis
    using closedin_metric mcball_subset_mspace by fastforce
qed

lemma mball_iff_mcball: "(\<exists>r>0. mball x r \<subseteq> U) = (\<exists>r>0. mcball x r \<subseteq> U)"
  by (meson dense mball_subset_mcball mcball_subset_mball_concentric order_trans)

lemma openin_mtopology_mcball:
  "openin mtopology U \<longleftrightarrow> U \<subseteq> M \<and> (\<forall>x. x \<in> U \<longrightarrow> (\<exists>r. 0 < r \<and> mcball x r \<subseteq> U))"
  using mball_iff_mcball openin_mtopology by presburger

lemma metric_derived_set_of:
  "mtopology derived_set_of S = {x \<in> M. \<forall>r>0. \<exists>y\<in>S. y\<noteq>x \<and> y \<in> mball x r}" (is "?lhs=?rhs")
proof
  show "?lhs \<subseteq> ?rhs"
    unfolding openin_mtopology derived_set_of_def 
    by clarsimp (metis in_mball openin_mball openin_mtopology zero)
  show "?rhs \<subseteq> ?lhs"
    unfolding openin_mtopology derived_set_of_def 
    by clarify (metis subsetD topspace_mtopology)
qed

lemma metric_closure_of:
   "mtopology closure_of S = {x \<in> M. \<forall>r>0. \<exists>y \<in> S. y \<in> mball x r}"
proof -
  have "\<And>x r. \<lbrakk>0 < r; x \<in> mtopology closure_of S\<rbrakk> \<Longrightarrow> \<exists>y\<in>S. y \<in> mball x r"
    by (metis centre_in_mball_iff in_closure_of openin_mball topspace_mtopology)
  moreover have "\<And>x T. \<lbrakk>x \<in> M; \<forall>r>0. \<exists>y\<in>S. y \<in> mball x r\<rbrakk> \<Longrightarrow> x \<in> mtopology closure_of S"
    by (smt (verit) in_closure_of in_mball openin_mtopology subsetD topspace_mtopology)
  ultimately show ?thesis
    by (auto simp: in_closure_of)
qed

lemma metric_closure_of_alt:
  "mtopology closure_of S = {x \<in> M. \<forall>r>0. \<exists>y \<in> S. y \<in> mcball x r}"
proof -
  have "\<And>x r. \<lbrakk>\<forall>r>0. x \<in> M \<and> (\<exists>y\<in>S. y \<in> mcball x r); 0 < r\<rbrakk> \<Longrightarrow> \<exists>y\<in>S. y \<in> M \<and> d x y < r"
    by (meson dense in_mcball le_less_trans)
  then show ?thesis
    by (fastforce simp: metric_closure_of in_closure_of)
qed

lemma metric_interior_of:
   "mtopology interior_of S = {x \<in> M. \<exists>\<epsilon>>0. mball x \<epsilon> \<subseteq> S}" (is "?lhs=?rhs")
proof
  show "?lhs \<subseteq> ?rhs"
    using interior_of_maximal_eq openin_mtopology by fastforce
  show "?rhs \<subseteq> ?lhs"
    using interior_of_def openin_mball by fastforce
qed

lemma metric_interior_of_alt:
   "mtopology interior_of S = {x \<in> M. \<exists>\<epsilon>>0. mcball x \<epsilon> \<subseteq> S}"
  by (fastforce simp: mball_iff_mcball metric_interior_of)

lemma in_interior_of_mball:
   "x \<in> mtopology interior_of S \<longleftrightarrow> x \<in> M \<and> (\<exists>\<epsilon>>0. mball x \<epsilon> \<subseteq> S)"
  using metric_interior_of by force

lemma in_interior_of_mcball:
   "x \<in> mtopology interior_of S \<longleftrightarrow> x \<in> M \<and> (\<exists>\<epsilon>>0. mcball x \<epsilon> \<subseteq> S)"
  using metric_interior_of_alt by force

lemma Hausdorff_space_mtopology: "Hausdorff_space mtopology"
  unfolding Hausdorff_space_def
proof clarify
  fix x y
  assume x: "x \<in> topspace mtopology" and y: "y \<in> topspace mtopology" and "x \<noteq> y"
  then have gt0: "d x y / 2 > 0"
    by auto
  have "disjnt (mball x (d x y / 2)) (mball y (d x y / 2))"
    by (simp add: disjoint_mball)
  then show "\<exists>U V. openin mtopology U \<and> openin mtopology V \<and> x \<in> U \<and> y \<in> V \<and> disjnt U V"
    by (metis centre_in_mball_iff gt0 openin_mball topspace_mtopology x y)
qed



subsection\<open>Bounded sets\<close>

definition mbounded where "mbounded S \<longleftrightarrow> (\<exists>x B. S \<subseteq> mcball x B)"

lemma mbounded_pos: "mbounded S \<longleftrightarrow> (\<exists>x B. 0 < B \<and> S \<subseteq> mcball x B)"
proof -
  have "\<exists>x' r'. 0 < r' \<and> S \<subseteq> mcball x' r'" if "S \<subseteq> mcball x r" for x r
    by (metis gt_ex less_eq_real_def linorder_not_le mcball_subset_concentric order_trans that)
  then show ?thesis
    by (auto simp: mbounded_def)
qed

lemma mbounded_alt:
  "mbounded S \<longleftrightarrow> S \<subseteq> M \<and> (\<exists>B. \<forall>x \<in> S. \<forall>y \<in> S. d x y \<le> B)"
proof -
  have "\<And>x B. S \<subseteq> mcball x B \<Longrightarrow> \<forall>x\<in>S. \<forall>y\<in>S. d x y \<le> 2 * B"
    by (smt (verit, best) commute in_mcball subsetD triangle)
  then show ?thesis
    apply (auto simp: mbounded_def subset_iff)
     apply blast+
    done
qed


lemma mbounded_alt_pos:
  "mbounded S \<longleftrightarrow> S \<subseteq> M \<and> (\<exists>B>0. \<forall>x \<in> S. \<forall>y \<in> S. d x y \<le> B)"
  by (smt (verit, del_insts) gt_ex mbounded_alt)

lemma mbounded_subset: "\<lbrakk>mbounded T; S \<subseteq> T\<rbrakk> \<Longrightarrow> mbounded S"
  by (meson mbounded_def order_trans)

lemma mbounded_subset_mspace: "mbounded S \<Longrightarrow> S \<subseteq> M"
  by (simp add: mbounded_alt)

lemma mbounded:
   "mbounded S \<longleftrightarrow> S = {} \<or> (\<forall>x \<in> S. x \<in> M) \<and> (\<exists>y B. y \<in> M \<and> (\<forall>x \<in> S. d y x \<le> B))"
  by (meson all_not_in_conv in_mcball mbounded_def subset_iff)

lemma mbounded_empty [iff]: "mbounded {}"
  by (simp add: mbounded)

lemma mbounded_mcball: "mbounded (mcball x r)"
  using mbounded_def by auto

lemma mbounded_mball [iff]: "mbounded (mball x r)"
  by (meson mball_subset_mcball mbounded_def)

lemma mbounded_insert: "mbounded (insert a S) \<longleftrightarrow> a \<in> M \<and> mbounded S"
proof -
  have "\<And>y B. \<lbrakk>y \<in> M; \<forall>x\<in>S. d y x \<le> B\<rbrakk>
           \<Longrightarrow> \<exists>y. y \<in> M \<and> (\<exists>B \<ge> d y a. \<forall>x\<in>S. d y x \<le> B)"
    by (metis order.trans nle_le)
  then show ?thesis
    by (auto simp add: mbounded)
qed

lemma mbounded_Int: "mbounded S \<Longrightarrow> mbounded (S \<inter> T)"
  by (meson inf_le1 mbounded_subset)

lemma mbounded_Un: "mbounded (S \<union> T) \<longleftrightarrow> mbounded S \<and> mbounded T" (is "?lhs=?rhs")
proof
  assume R: ?rhs
  show ?lhs
  proof (cases "S={} \<or> T={}")
    case True then show ?thesis
      using R by auto
  next
    case False
    obtain x y B C where "S \<subseteq> mcball x B" "T \<subseteq> mcball y C" "B > 0" "C > 0" "x \<in> M" "y \<in> M"
      using R mbounded_pos
      by (metis False mcball_eq_empty subset_empty)
    then have "S \<union> T \<subseteq> mcball x (B + C + d x y)"
      by (smt (verit) commute dual_order.trans le_supI mcball_subset mdist_pos_eq)
    then show ?thesis
      using mbounded_def by blast
  qed
next
  show "?lhs \<Longrightarrow> ?rhs"
    using mbounded_def by auto
qed

lemma mbounded_Union:
  "\<lbrakk>finite \<F>; \<And>X. X \<in> \<F> \<Longrightarrow> mbounded X\<rbrakk> \<Longrightarrow> mbounded (\<Union>\<F>)"
  by (induction \<F> rule: finite_induct) (auto simp: mbounded_Un)

lemma mbounded_closure_of:
   "mbounded S \<Longrightarrow> mbounded (mtopology closure_of S)"
  by (meson closedin_mcball closure_of_minimal mbounded_def)

lemma mbounded_closure_of_eq:
   "S \<subseteq> M \<Longrightarrow> (mbounded (mtopology closure_of S) \<longleftrightarrow> mbounded S)"
  by (metis closure_of_subset mbounded_closure_of mbounded_subset topspace_mtopology)


lemma maxdist_thm:
  assumes "mbounded S"
      and "x \<in> S"
      and "y \<in> S"
    shows  "d x y = (SUP z\<in>S. \<bar>d x z - d z y\<bar>)"
proof -
  have "\<bar>d x z - d z y\<bar> \<le> d x y" if "z \<in> S" for z
    by (metis all_not_in_conv assms mbounded mdist_reverse_triangle that) 
  moreover have "d x y \<le> r"
    if "\<And>z. z \<in> S \<Longrightarrow> \<bar>d x z - d z y\<bar> \<le> r" for r :: real
    using that assms mbounded_subset_mspace mdist_refl by fastforce
  ultimately show ?thesis
    by (intro cSup_eq [symmetric]) auto
qed


lemma metric_eq_thm: "\<lbrakk>S \<subseteq> M; x \<in> S; y \<in> S\<rbrakk> \<Longrightarrow> (x = y) = (\<forall>z\<in>S. d x z = d y z)"
  by (metis commute  subset_iff zero)

lemma compactin_imp_mbounded:
  assumes "compactin mtopology S"
  shows "mbounded S"
proof -
  have "S \<subseteq> M"
    and com: "\<And>\<U>. \<lbrakk>\<forall>U\<in>\<U>. openin mtopology U; S \<subseteq> \<Union>\<U>\<rbrakk> \<Longrightarrow> \<exists>\<F>. finite \<F> \<and> \<F> \<subseteq> \<U> \<and> S \<subseteq> \<Union>\<F>"
    using assms by (auto simp: compactin_def mbounded_def)
  show ?thesis
  proof (cases "S = {}")
    case False
    with \<open>S \<subseteq> M\<close> obtain a where "a \<in> S" "a \<in> M"
      by blast
    with \<open>S \<subseteq> M\<close> gt_ex have "S \<subseteq> \<Union>(range (mball a))"
      by force
    moreover have "\<forall>U \<in> range (mball a). openin mtopology U"
      by (simp add: openin_mball)
    ultimately obtain \<F> where "finite \<F>" "\<F> \<subseteq> range (mball a)" "S \<subseteq> \<Union>\<F>"
      by (meson com)
  then show ?thesis
      using mbounded_Union mbounded_subset by fastforce
  qed auto
qed

end


subsection\<open>Subspace of a metric space\<close>

locale submetric = Metric_space + 
  fixes A
  assumes subset: "A \<subseteq> M"

sublocale submetric \<subseteq> sub: Metric_space A d
  by (simp add: subset subspace)

context submetric
begin 

lemma mball_submetric_eq: "sub.mball a r = (if a \<in> A then A \<inter> mball a r else {})"
and mcball_submetric_eq: "sub.mcball a r = (if a \<in> A then A \<inter> mcball a r else {})"
  using subset by force+

lemma mtopology_submetric: "sub.mtopology = subtopology mtopology A"
  unfolding topology_eq
proof (intro allI iffI)
  fix S
  assume "openin sub.mtopology S"
  then have "\<exists>T. openin (subtopology mtopology A) T \<and> x \<in> T \<and> T \<subseteq> S" if "x \<in> S" for x
    by (metis mball_submetric_eq openin_mball openin_subtopology_Int2 sub.centre_in_mball_iff sub.openin_mtopology subsetD that)
  then show "openin (subtopology mtopology A) S"
    by (meson openin_subopen)
next
  fix S
  assume "openin (subtopology mtopology A) S"
  then obtain T where "openin mtopology T" "S = T \<inter> A"
    by (meson openin_subtopology)
  then have "mopen T"
    by (simp add: mopen_def openin_mtopology)
  then have "sub.mopen (T \<inter> A)"
    unfolding sub.mopen_def mopen_def
    by (metis inf.coboundedI2 mball_submetric_eq Int_iff \<open>S = T \<inter> A\<close> inf.bounded_iff subsetI)
  then show "openin sub.mtopology S"
    using \<open>S = T \<inter> A\<close> sub.mopen_def sub.openin_mtopology by force
qed

lemma mbounded_submetric: "sub.mbounded T \<longleftrightarrow> mbounded T \<and> T \<subseteq> A"
  by (meson mbounded_alt sub.mbounded_alt subset subset_trans)

end
  

(**
lemma submetric_submetric:
   "\<And>m A t::A=>bool.
        submetric (submetric A) t = submetric (A \<inter> t)"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[submetric] THEN
  REWRITE_TAC[SUBMETRIC] THEN
  REWRITE_TAC[SET_RULE `(A \<inter> t) \<inter> m = t \<inter> A \<inter> m`]);;

lemma submetric_restrict:
   "\<And>m A::A=>bool. submetric A = submetric (M \<inter> A)"
oops
  REPEAT GEN_TAC THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> LAND_CONV) [GSYM SUBMETRIC_MSPACE] THEN
  REWRITE_TAC[SUBMETRIC_SUBMETRIC]);;
**)


subsection\<open>The discrete metric\<close>


locale discrete_metric =
  fixes M :: "'a set"

definition (in discrete_metric) dd :: "'a \<Rightarrow> 'a \<Rightarrow> real"
  where "dd \<equiv> \<lambda>x y::'a. if x=y then 0 else 1"

lemma metric_M_dd: "Metric_space M discrete_metric.dd"
  by (simp add: discrete_metric.dd_def Metric_space.intro)

sublocale discrete_metric \<subseteq> disc: Metric_space M dd
  by (simp add: metric_M_dd)


lemma (in discrete_metric) mopen_singleton:
  assumes "x \<in> M" shows "disc.mopen {x}"
proof -
  have "disc.mball x (1/2) \<subseteq> {x}"
    by (smt (verit) dd_def disc.in_mball less_divide_eq_1_pos singleton_iff subsetI)
  with assms show ?thesis
    using disc.mopen_def half_gt_zero_iff zero_less_one by blast
qed

lemma (in discrete_metric) mtopology_discrete_metric:
   "disc.mtopology = discrete_topology M"
proof -
  have "\<And>x. x \<in> M \<Longrightarrow> openin disc.mtopology {x}"
    by (simp add: disc.mtopology_def mopen_singleton)
  then show ?thesis
    by (metis disc.topspace_mtopology discrete_topology_unique)
qed

lemma (in discrete_metric) discrete_ultrametric:
   "dd x z \<le> max (dd x y) (dd y z)"
  by (simp add: dd_def)


lemma (in discrete_metric) dd_le1: "dd x y \<le> 1"
  by (simp add: dd_def)

lemma (in discrete_metric) mbounded_discrete_metric: "disc.mbounded S \<longleftrightarrow> S \<subseteq> M"
  by (meson dd_le1 disc.mbounded_alt)



subsection\<open>Metrizable spaces\<close>


definition metrizable_space where
  "metrizable_space X \<equiv> (\<exists>M d. Metric_space M d \<and> X = Metric_space.mtopology M d)"

lemma (in Metric_space) metrizable_space_mtopology: "metrizable_space mtopology"
  using local.Metric_space_axioms metrizable_space_def by blast

lemma openin_mtopology_eq_open [simp]: "openin Met.mtopology = open"
  by (simp add: Met.mtopology_def)

lemma closedin_mtopology_eq_closed [simp]: "closedin Met.mtopology = closed"
proof -
  have "(euclidean::'a topology) = Met.mtopology"
    by (simp add: Met.mtopology_def)
  then show ?thesis
    using closed_closedin by fastforce
qed

lemma compactin_mtopology_eq_compact [simp]: "compactin Met.mtopology = compact"
  by (simp add: compactin_def compact_eq_Heine_Borel fun_eq_iff) meson

lemma metrizable_space_discrete_topology:
   "metrizable_space(discrete_topology U)"
  by (metis discrete_metric.mtopology_discrete_metric metric_M_dd metrizable_space_def)

lemma metrizable_space_subtopology:
  assumes "metrizable_space X"
  shows "metrizable_space(subtopology X S)"
proof -
  obtain M d where "Metric_space M d" and X: "X = Metric_space.mtopology M d"
    using assms metrizable_space_def by blast
  then interpret submetric M d "M \<inter> S"
    by (simp add: submetric.intro submetric_axioms_def)
  show ?thesis
    unfolding metrizable_space_def
    by (metis X mtopology_submetric sub.Metric_space_axioms subtopology_restrict topspace_mtopology)
qed

lemma homeomorphic_metrizable_space_aux:
  assumes "X homeomorphic_space X'" "metrizable_space X"
  shows "metrizable_space X'"
proof -
  obtain M d where "Metric_space M d" and X: "X = Metric_space.mtopology M d"
    using assms by (auto simp: metrizable_space_def)
  then interpret m: Metric_space M d 
    by simp
  obtain f g where hmf: "homeomorphic_map X X' f" and hmg: "homeomorphic_map X' X g"
    and fg: "(\<forall>x \<in> M. g(f x) = x) \<and> (\<forall>y \<in> topspace X'. f(g y) = y)"
    using assms X homeomorphic_maps_map homeomorphic_space_def by fastforce
  define d' where "d' x y \<equiv> d (g x) (g y)" for x y
  interpret m': Metric_space "topspace X'" "d'"
    unfolding d'_def
  proof
    show "(d (g x) (g y) = 0) = (x = y)" if "x \<in> topspace X'" "y \<in> topspace X'" for x y
      by (metis fg X hmg homeomorphic_imp_surjective_map imageI m.topspace_mtopology m.zero that)
    show "d (g x) (g z) \<le> d (g x) (g y) + d (g y) (g z)"
      if "x \<in> topspace X'" and "y \<in> topspace X'" and "z \<in> topspace X'" for x y z
      by (metis X that hmg homeomorphic_eq_everything_map imageI m.topspace_mtopology m.triangle)
  qed (auto simp: m.nonneg m.commute)
  have "X' = Metric_space.mtopology (topspace X') d'"
    unfolding topology_eq
  proof (intro allI)
    fix S
    have "openin m'.mtopology S" if S: "S \<subseteq> topspace X'" and "openin X (g ` S)"
      unfolding m'.openin_mtopology
    proof (intro conjI that strip)
      fix y
      assume "y \<in> S"
      then obtain r where "r>0" and r: "m.mball (g y) r \<subseteq> g ` S" 
        using X \<open>openin X (g ` S)\<close> m.openin_mtopology using \<open>y \<in> S\<close> by auto
      then have "g ` m'.mball y r \<subseteq> m.mball (g y) r"
        using X d'_def hmg homeomorphic_imp_surjective_map by fastforce
      with S fg have "m'.mball y r \<subseteq> S"
        by (smt (verit, del_insts) image_iff m'.in_mball r subset_iff)
      then show "\<exists>r>0. m'.mball y r \<subseteq> S"
        using \<open>0 < r\<close> by blast 
    qed
    moreover have "openin X (g ` S)" if ope': "openin m'.mtopology S"
    proof -
      have "\<exists>r>0. m.mball (g y) r \<subseteq> g ` S" if "y \<in> S" for y
      proof -
        have y: "y \<in> topspace X'"
          using m'.openin_mtopology ope' that by blast
        obtain r where "r > 0" and r: "m'.mball y r \<subseteq> S"
          using ope' by (meson \<open>y \<in> S\<close> m'.openin_mtopology)
        moreover have "\<And>x. \<lbrakk>x \<in> M; d (g y) x < r\<rbrakk> \<Longrightarrow> \<exists>u. u \<in> topspace X' \<and> d' y u < r \<and> x = g u"
          using fg X d'_def hmf homeomorphic_imp_surjective_map by fastforce
        ultimately have "m.mball (g y) r \<subseteq> g ` m'.mball y r"
          using y by (force simp: m'.openin_mtopology)
        then show ?thesis
          using \<open>0 < r\<close> r by blast
      qed
      then show ?thesis
        using X hmg homeomorphic_imp_surjective_map m.openin_mtopology ope' openin_subset by fastforce
    qed
    ultimately have "(S \<subseteq> topspace X' \<and> openin X (g ` S)) = openin m'.mtopology S"
      using m'.topspace_mtopology openin_subset by blast
    then show "openin X' S = openin m'.mtopology S"
      by (simp add: m'.mopen_def homeomorphic_map_openness_eq [OF hmg])
  qed
  then show ?thesis
    using m'.metrizable_space_mtopology by force
qed

lemma homeomorphic_metrizable_space:
  assumes "X homeomorphic_space X'"
  shows "metrizable_space X \<longleftrightarrow> metrizable_space X'"
  using assms homeomorphic_metrizable_space_aux homeomorphic_space_sym by metis

lemma metrizable_space_retraction_map_image:
   "retraction_map X X' r \<and> metrizable_space X
        \<Longrightarrow> metrizable_space X'"
  using hereditary_imp_retractive_property metrizable_space_subtopology homeomorphic_metrizable_space
  by blast


lemma metrizable_imp_Hausdorff_space:
   "metrizable_space X \<Longrightarrow> Hausdorff_space X"
  by (metis Metric_space.Hausdorff_space_mtopology metrizable_space_def)

(**
lemma metrizable_imp_kc_space:
   "metrizable_space X \<Longrightarrow> kc_space X"
oops
  MESON_TAC[METRIZABLE_IMP_HAUSDORFF_SPACE; HAUSDORFF_IMP_KC_SPACE]);;

lemma kc_space_mtopology:
   "kc_space mtopology"
oops
  REWRITE_TAC[GSYM FORALL_METRIZABLE_SPACE; METRIZABLE_IMP_KC_SPACE]);;
**)

lemma metrizable_imp_t1_space:
   "metrizable_space X \<Longrightarrow> t1_space X"
  by (simp add: Hausdorff_imp_t1_space metrizable_imp_Hausdorff_space)

lemma closed_imp_gdelta_in:
  assumes X: "metrizable_space X" and S: "closedin X S"
  shows "gdelta_in X S"
proof -
  obtain M d where "Metric_space M d" and Xeq: "X = Metric_space.mtopology M d"
    using X metrizable_space_def by blast
  then interpret M: Metric_space M d
    by blast
  have "S \<subseteq> M"
    using M.closedin_metric \<open>X = M.mtopology\<close> S by blast
  show ?thesis
  proof (cases "S = {}")
    case True
    then show ?thesis
      by simp
  next
    case False
    have "\<exists>y\<in>S. d x y < inverse (1 + real n)" if "x \<in> S" for x n
      using \<open>S \<subseteq> M\<close> M.mdist_refl [of x] that by force
    moreover
    have "x \<in> S" if "x \<in> M" and \<section>: "\<And>n. \<exists>y\<in>S. d x y < inverse(Suc n)" for x
    proof -
      have *: "\<exists>y\<in>S. d x y < \<epsilon>" if "\<epsilon> > 0" for \<epsilon>
        by (metis \<section> that not0_implies_Suc order_less_le order_less_le_trans real_arch_inverse)
      have "closedin M.mtopology S"
        using S by (simp add: Xeq)
      then show ?thesis
        apply (simp add: M.closedin_metric)
        by (metis * \<open>x \<in> M\<close> M.in_mball disjnt_insert1 insert_absorb subsetD)
    qed
    ultimately have Seq: "S = \<Inter>(range (\<lambda>n. {x\<in>M. \<exists>y\<in>S. d x y < inverse(Suc n)}))"
      using \<open>S \<subseteq> M\<close> by force
    have "openin M.mtopology {xa \<in> M. \<exists>y\<in>S. d xa y < inverse (1 + real n)}" for n
    proof (clarsimp simp add: M.openin_mtopology)
      fix x y
      assume "x \<in> M" "y \<in> S" and dxy: "d x y < inverse (1 + real n)"
      then have "\<And>z. \<lbrakk>z \<in> M; d x z < inverse (1 + real n) - d x y\<rbrakk> \<Longrightarrow> \<exists>y\<in>S. d z y < inverse (1 + real n)"
        by (smt (verit) M.commute M.triangle \<open>S \<subseteq> M\<close> in_mono)
      with dxy show "\<exists>r>0. M.mball x r \<subseteq> {z \<in> M. \<exists>y\<in>S. d z y < inverse (1 + real n)}"
        by (rule_tac x="inverse(Suc n) - d x y" in exI) auto
    qed
    then show ?thesis
      apply (subst Seq)
      apply (force simp: Xeq intro: gdelta_in_Inter open_imp_gdelta_in)
      done
  qed
qed

lemma open_imp_fsigma_in:
   "\<lbrakk>metrizable_space X; openin X S\<rbrakk> \<Longrightarrow> fsigma_in X S"
  by (meson closed_imp_gdelta_in fsigma_in_gdelta_in openin_closedin openin_subset)

(*NEEDS first_countable
lemma first_countable_mtopology:
   "first_countable mtopology"
oops
  GEN_TAC THEN REWRITE_TAC[first_countable; TOPSPACE_MTOPOLOGY] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  EXISTS_TAC `{ mball m (x::A,r) | rational r \<and> 0 < r}` THEN
  REWRITE_TAC[FORALL_IN_GSPEC; OPEN_IN_MBALL; EXISTS_IN_GSPEC] THEN
  ONCE_REWRITE_TAC[SET_RULE
   `{f x | S x \<and> Q x} = f ` {x. x \<in> S \<and> Q x}`] THEN
  SIMP_TAC[COUNTABLE_IMAGE; COUNTABLE_RATIONAL; COUNTABLE_RESTRICT] THEN
  REWRITE_TAC[OPEN_IN_MTOPOLOGY] THEN
  X_GEN_TAC `U::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::A`) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `r::real` THEN STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC \<circ> SPEC `r::real` \<circ> MATCH_MP RATIONAL_APPROXIMATION_BELOW) THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `q::real` THEN
  REWRITE_TAC[REAL_SUB_REFL] THEN STRIP_TAC THEN
  ASM_SIMP_TAC[CENTRE_IN_MBALL] THEN
  TRANS_TAC SUBSET_TRANS `mball m (x::A,r)` THEN
  ASM_SIMP_TAC[MBALL_SUBSET_CONCENTRIC; REAL_LT_IMP_LE]);;

lemma metrizable_imp_first_countable:
   "metrizable_space X \<Longrightarrow> first_countable X"
oops
  REWRITE_TAC[FORALL_METRIZABLE_SPACE; FIRST_COUNTABLE_MTOPOLOGY]);;
*)

subsection\<open>Connected topological spaces\<close>

lemma connected_space_eq_frontier_eq_empty:
   "connected_space X \<longleftrightarrow> (\<forall>S. S \<subseteq> topspace X \<and> X frontier_of S = {} \<longrightarrow> S = {} \<or> S = topspace X)"
  by (meson clopenin_eq_frontier_of connected_space_clopen_in)

lemma connected_space_frontier_eq_empty:
   "connected_space X \<and> S \<subseteq> topspace X
        \<Longrightarrow> (X frontier_of S = {} \<longleftrightarrow> S = {} \<or> S = topspace X)"
  by (meson connected_space_eq_frontier_eq_empty frontier_of_empty frontier_of_topspace)

lemma connectedin_eq_subset_separated_union:
   "connectedin X C \<longleftrightarrow>
        C \<subseteq> topspace X \<and> (\<forall>S T. separatedin X S T \<and> C \<subseteq> S \<union> T \<longrightarrow> C \<subseteq> S \<or> C \<subseteq> T)" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
  using connectedin_subset_topspace connectedin_subset_separated_union by blast
next
  assume ?rhs
  then show ?lhs
  by (metis closure_of_subset connectedin_separation dual_order.eq_iff inf.orderE separatedin_def sup.boundedE)
qed


lemma connectedin_clopen_cases:
   "\<lbrakk>connectedin X C; closedin X T; openin X T\<rbrakk> \<Longrightarrow> C \<subseteq> T \<or> disjnt C T"
  by (metis Diff_eq_empty_iff Int_empty_right clopenin_eq_frontier_of connectedin_Int_frontier_of disjnt_def)

lemma connected_space_quotient_map_image:
   "\<lbrakk>quotient_map X X' q; connected_space X\<rbrakk> \<Longrightarrow> connected_space X'"
  by (metis connectedin_continuous_map_image connectedin_topspace quotient_imp_continuous_map quotient_imp_surjective_map)

lemma connected_space_retraction_map_image:
   "\<lbrakk>retraction_map X X' r; connected_space X\<rbrakk> \<Longrightarrow> connected_space X'"
  using connected_space_quotient_map_image retraction_imp_quotient_map by blast

lemma connectedin_imp_perfect_gen:
  assumes X: "t1_space X" and S: "connectedin X S" and nontriv: "\<nexists>a. S = {a}"
  shows "S \<subseteq> X derived_set_of S"
unfolding derived_set_of_def
proof (intro subsetI CollectI conjI strip)
  show XS: "x \<in> topspace X" if "x \<in> S" for x
    using that S connectedin by fastforce 
  show "\<exists>y. y \<noteq> x \<and> y \<in> S \<and> y \<in> T"
    if "x \<in> S" and "x \<in> T \<and> openin X T" for x T
  proof -
    have opeXx: "openin X (topspace X - {x})"
      by (meson X openin_topspace t1_space_openin_delete_alt)
    moreover
    have "S \<subseteq> T \<union> (topspace X - {x})"
      using XS that(2) by auto
    moreover have "(topspace X - {x}) \<inter> S \<noteq> {}"
      by (metis Diff_triv S connectedin double_diff empty_subsetI inf_commute insert_subsetI nontriv that(1))
    ultimately show ?thesis
      using that connectedinD [OF S, of T "topspace X - {x}"]
      by blast
  qed
qed

lemma connectedin_imp_perfect:
  "\<lbrakk>Hausdorff_space X; connectedin X S; \<nexists>a. S = {a}\<rbrakk> \<Longrightarrow> S \<subseteq> X derived_set_of S"
  by (simp add: Hausdorff_imp_t1_space connectedin_imp_perfect_gen)


lemma connected_space_prod_topology:
   "connected_space(prod_topology X Y) \<longleftrightarrow>
    topspace(prod_topology X Y) = {} \<or> connected_space X \<and> connected_space Y" (is "?lhs=?rhs")
proof (cases "topspace(prod_topology X Y) = {}")
  case True
  then show ?thesis
    using connected_space_topspace_empty by blast
next
  case False
  then have nonempty: "topspace X \<noteq> {}" "topspace Y \<noteq> {}"
    by force+
  show ?thesis 
  proof
    assume ?lhs
    then show ?rhs
      by (meson connected_space_quotient_map_image nonempty quotient_map_fst quotient_map_snd)
  next
    assume ?rhs
    then have conX: "connected_space X" and conY: "connected_space Y"
      using False by blast+
    have False
      if "openin (prod_topology X Y) U" and "openin (prod_topology X Y) V"
        and UV: "topspace X \<times> topspace Y \<subseteq> U \<union> V" "U \<inter> V = {}" 
        and "U \<noteq> {}" and "V \<noteq> {}"
      for U V
    proof -
      have Usub: "U \<subseteq> topspace X \<times> topspace Y" and Vsub: "V \<subseteq> topspace X \<times> topspace Y"
        using that by (metis openin_subset topspace_prod_topology)+
      obtain a b where ab: "(a,b) \<in> U" and a: "a \<in> topspace X" and b: "b \<in> topspace Y"
        using \<open>U \<noteq> {}\<close> Usub by auto
      have "\<not> topspace X \<times> topspace Y \<subseteq> U"
        using Usub Vsub \<open>U \<inter> V = {}\<close> \<open>V \<noteq> {}\<close> by auto
      then obtain x y where x: "x \<in> topspace X" and y: "y \<in> topspace Y" and "(x,y) \<notin> U"
        by blast
      have oX: "openin X {x \<in> topspace X. (x,y) \<in> U}" "openin X {x \<in> topspace X. (x,y) \<in> V}"
       and oY: "openin Y {y \<in> topspace Y. (a,y) \<in> U}" "openin Y {y \<in> topspace Y. (a,y) \<in> V}"
        by (force intro: openin_continuous_map_preimage [where Y = "prod_topology X Y"] 
            simp add: that continuous_map_pairwise o_def x y a)+
      have 1: "topspace Y \<subseteq> {y \<in> topspace Y. (a,y) \<in> U} \<union> {y \<in> topspace Y. (a,y) \<in> V}"
        using a that(3) by auto
      have 2: "{y \<in> topspace Y. (a,y) \<in> U} \<inter> {y \<in> topspace Y. (a,y) \<in> V} = {}"
        using that(4) by auto
      have 3: "{y \<in> topspace Y. (a,y) \<in> U} \<noteq> {}"
        using ab b by auto
      have 4: "{y \<in> topspace Y. (a,y) \<in> V} \<noteq> {}"
      proof -
        show ?thesis
          using connected_spaceD [OF conX oX] UV \<open>(x,y) \<notin> U\<close> a x y
                disjoint_iff_not_equal by blast
      qed
      show ?thesis
        using connected_spaceD [OF conY oY 1 2 3 4] by auto
    qed
    then show ?lhs
      unfolding connected_space_def topspace_prod_topology by blast 
  qed
qed


lemma connectedin_Times:
   "connectedin (prod_topology X Y) (S \<times> T) \<longleftrightarrow>
        S = {} \<or> T = {} \<or> connectedin X S \<and> connectedin Y T"
  by (force simp: connectedin_def subtopology_Times connected_space_prod_topology)


subsection\<open>The notion of "separated between" (complement of "connected between)"\<close>

definition separated_between 
  where "separated_between X S T \<equiv>
        \<exists>U V. openin X U \<and> openin X V \<and> U \<union> V = topspace X \<and> disjnt U V \<and> S \<subseteq> U \<and> T \<subseteq> V"

lemma separated_between_alt:
   "separated_between X S T \<longleftrightarrow>
        (\<exists>U V. closedin X U \<and> closedin X V \<and> U \<union> V = topspace X \<and> disjnt U V \<and> S \<subseteq> U \<and> T \<subseteq> V)"
  unfolding separated_between_def
  by (metis separatedin_open_sets separation_closedin_Un_gen subtopology_topspace 
            separatedin_closed_sets separation_openin_Un_gen)

lemma separated_between:
   "separated_between X S T \<longleftrightarrow>
        (\<exists>U. closedin X U \<and> openin X U \<and> S \<subseteq> U \<and> T \<subseteq> topspace X - U)"
  unfolding separated_between_def closedin_def disjnt_def
  by (smt (verit, del_insts) Diff_cancel Diff_disjoint Diff_partition Un_Diff Un_Diff_Int openin_subset)

lemma separated_between_mono:
   "\<lbrakk>separated_between X S T; S' \<subseteq> S; T' \<subseteq> T\<rbrakk> \<Longrightarrow> separated_between X S' T'"
  by (meson order.trans separated_between)

lemma separated_between_refl:
   "separated_between X S S \<longleftrightarrow> S = {}"
  unfolding separated_between_def
  by (metis Un_empty_right disjnt_def disjnt_empty2 disjnt_subset2 disjnt_sym le_iff_inf openin_empty openin_topspace)

lemma separated_between_sym:
   "separated_between X S T \<longleftrightarrow> separated_between X T S"
  by (metis disjnt_sym separated_between_alt sup_commute)

lemma separated_between_imp_subset:
   "separated_between X S T \<Longrightarrow> S \<subseteq> topspace X \<and> T \<subseteq> topspace X"
  by (metis le_supI1 le_supI2 separated_between_def)

lemma separated_between_empty: 
  "(separated_between X {} S \<longleftrightarrow> S \<subseteq> topspace X) \<and> (separated_between X S {} \<longleftrightarrow> S \<subseteq> topspace X)"
  by (metis Diff_empty bot.extremum closedin_empty openin_empty separated_between separated_between_imp_subset separated_between_sym)


lemma separated_between_Un: 
  "separated_between X S (T \<union> U) \<longleftrightarrow> separated_between X S T \<and> separated_between X S U"
  by (auto simp: separated_between)

lemma separated_between_Un': 
  "separated_between X (S \<union> T) U \<longleftrightarrow> separated_between X S U \<and> separated_between X T U"
  by (simp add: separated_between_Un separated_between_sym)

lemma separated_between_imp_disjoint:
   "separated_between X S T \<Longrightarrow> disjnt S T"
  by (meson disjnt_iff separated_between_def subsetD)

lemma separated_between_imp_separatedin:
   "separated_between X S T \<Longrightarrow> separatedin X S T"
  by (meson separated_between_def separatedin_mono separatedin_open_sets)

lemma separated_between_full:
  assumes "S \<union> T = topspace X"
  shows "separated_between X S T \<longleftrightarrow> disjnt S T \<and> closedin X S \<and> openin X S \<and> closedin X T \<and> openin X T"
proof -
  have "separated_between X S T \<longrightarrow> separatedin X S T"
    by (simp add: separated_between_imp_separatedin)
  then show ?thesis
    unfolding separated_between_def
    by (metis assms separation_closedin_Un_gen separation_openin_Un_gen subset_refl subtopology_topspace)
qed

lemma separated_between_eq_separatedin:
   "S \<union> T = topspace X \<Longrightarrow> (separated_between X S T \<longleftrightarrow> separatedin X S T)"
  by (simp add: separated_between_full separatedin_full)

lemma separated_between_pointwise_left:
  assumes "compactin X S"
  shows "separated_between X S T \<longleftrightarrow>
         (S = {} \<longrightarrow> T \<subseteq> topspace X) \<and> (\<forall>x \<in> S. separated_between X {x} T)"  (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    using separated_between_imp_subset separated_between_mono by fastforce
next
  assume R: ?rhs
  then have "T \<subseteq> topspace X"
    by (meson equals0I separated_between_imp_subset)
  show ?lhs
  proof -
    obtain U where U: "\<forall>x \<in> S. openin X (U x)"
      "\<forall>x \<in> S. \<exists>V. openin X V \<and> U x \<union> V = topspace X \<and> disjnt (U x) V \<and> {x} \<subseteq> U x \<and> T \<subseteq> V"
      using R unfolding separated_between_def by metis
    then have "S \<subseteq> \<Union>(U ` S)"
      by blast
    then obtain K where "finite K" "K \<subseteq> S" and K: "S \<subseteq> (\<Union>i\<in>K. U i)"
      using assms U unfolding compactin_def by (smt (verit) finite_subset_image imageE)
    show ?thesis
      unfolding separated_between
    proof (intro conjI exI)
      have "\<And>x. x \<in> K \<Longrightarrow> closedin X (U x)"
        by (smt (verit) \<open>K \<subseteq> S\<close> Diff_cancel U(2) Un_Diff Un_Diff_Int disjnt_def openin_closedin_eq subsetD)
      then show "closedin X (\<Union> (U ` K))"
        by (metis (mono_tags, lifting) \<open>finite K\<close> closedin_Union finite_imageI image_iff)
      show "openin X (\<Union> (U ` K))"
        using U(1) \<open>K \<subseteq> S\<close> by blast
      show "S \<subseteq> \<Union> (U ` K)"
        by (simp add: K)
      have "\<And>x i. \<lbrakk>x \<in> T; i \<in> K; x \<in> U i\<rbrakk> \<Longrightarrow> False"
        by (meson U(2) \<open>K \<subseteq> S\<close> disjnt_iff subsetD)
      then show "T \<subseteq> topspace X - \<Union> (U ` K)"
        using \<open>T \<subseteq> topspace X\<close> by auto
    qed
  qed
qed

lemma separated_between_pointwise_right:
   "compactin X T
        \<Longrightarrow> separated_between X S T \<longleftrightarrow> (T = {} \<longrightarrow> S \<subseteq> topspace X) \<and> (\<forall>y \<in> T. separated_between X S {y})"
  by (meson separated_between_pointwise_left separated_between_sym)

lemma separated_between_closure_of:
  "S \<subseteq> topspace X \<Longrightarrow> separated_between X (X closure_of S) T \<longleftrightarrow> separated_between X S T"
  by (meson closure_of_minimal_eq separated_between_alt)


lemma separated_between_closure_of':
 "T \<subseteq> topspace X \<Longrightarrow> separated_between X S (X closure_of T) \<longleftrightarrow> separated_between X S T"
  by (meson separated_between_closure_of separated_between_sym)

lemma separated_between_closure_of_eq:
 "separated_between X S T \<longleftrightarrow> S \<subseteq> topspace X \<and> separated_between X (X closure_of S) T"
  by (metis separated_between_closure_of separated_between_imp_subset)

lemma separated_between_closure_of_eq':
 "separated_between X S T \<longleftrightarrow> T \<subseteq> topspace X \<and> separated_between X S (X closure_of T)"
  by (metis separated_between_closure_of' separated_between_imp_subset)

lemma separated_between_frontier_of_eq':
  "separated_between X S T \<longleftrightarrow>
   T \<subseteq> topspace X \<and> disjnt S T \<and> separated_between X S (X frontier_of T)" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis interior_of_union_frontier_of separated_between_Un separated_between_closure_of_eq' 
        separated_between_imp_disjoint)
next
  assume R: ?rhs
  then obtain U where U: "closedin X U" "openin X U" "S \<subseteq> U" "X closure_of T - X interior_of T \<subseteq> topspace X - U"
    by (metis frontier_of_def separated_between)
  show ?lhs
  proof (rule separated_between_mono [of _ S "X closure_of T"])
    have "separated_between X S T"
      unfolding separated_between
    proof (intro conjI exI)
      show "S \<subseteq> U - T" "T \<subseteq> topspace X - (U - T)"
        using R U(3) by (force simp: disjnt_iff)+
      have "T \<subseteq> X closure_of T"
        by (simp add: R closure_of_subset)
      then have *: "U - T = U - X interior_of T"
        using U(4) interior_of_subset by fastforce
      then show "closedin X (U - T)"
        by (simp add: U(1) closedin_diff)
      have "U \<inter> X frontier_of T = {}"
        using U(4) frontier_of_def by fastforce
      then show "openin X (U - T)"
        by (metis * Diff_Un U(2) Un_Diff_Int Un_Int_eq(1) closedin_closure_of interior_of_union_frontier_of openin_diff sup_bot_right)
    qed
    then show "separated_between X S (X closure_of T)"
      by (simp add: R separated_between_closure_of')
  qed (auto simp add: R closure_of_subset)
qed

lemma separated_between_frontier_of_eq:
  "separated_between X S T \<longleftrightarrow> S \<subseteq> topspace X \<and> disjnt S T \<and> separated_between X (X frontier_of S) T"
  by (metis disjnt_sym separated_between_frontier_of_eq' separated_between_sym)

lemma separated_between_frontier_of:
  "\<lbrakk>S \<subseteq> topspace X; disjnt S T\<rbrakk>
   \<Longrightarrow> (separated_between X (X frontier_of S) T \<longleftrightarrow> separated_between X S T)"
  using separated_between_frontier_of_eq by blast

lemma separated_between_frontier_of':
 "\<lbrakk>T \<subseteq> topspace X; disjnt S T\<rbrakk>
   \<Longrightarrow> (separated_between X S (X frontier_of T) \<longleftrightarrow> separated_between X S T)"
  using separated_between_frontier_of_eq' by auto

lemma connected_space_separated_between:
  "connected_space X \<longleftrightarrow> (\<forall>S T. separated_between X S T \<longrightarrow> S = {} \<or> T = {})" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis Diff_cancel connected_space_clopen_in separated_between subset_empty)
next
  assume ?rhs then show ?lhs
    by (meson connected_space_eq_not_separated separated_between_eq_separatedin)
qed

lemma connected_space_imp_separated_between_trivial:
   "connected_space X
        \<Longrightarrow> (separated_between X S T \<longleftrightarrow> S = {} \<and> T \<subseteq> topspace X \<or> S \<subseteq> topspace X \<and> T = {})"
  by (metis connected_space_separated_between separated_between_empty)


subsection\<open>Connected components\<close>

lemma connected_component_of_subtopology_eq:
   "connected_component_of (subtopology X U) a = connected_component_of X a \<longleftrightarrow>
    connected_component_of_set X a \<subseteq> U"
  by (force simp: connected_component_of_set connectedin_subtopology connected_component_of_def fun_eq_iff subset_iff)

lemma connected_components_of_subtopology:
  assumes "C \<in> connected_components_of X" "C \<subseteq> U"
  shows "C \<in> connected_components_of (subtopology X U)"
proof -
  obtain a where a: "connected_component_of_set X a \<subseteq> U" and "a \<in> topspace X"
             and Ceq: "C = connected_component_of_set X a"
    using assms by (force simp: connected_components_of_def)
  then have "a \<in> U"
    by (simp add: connected_component_of_refl in_mono)
  then have "connected_component_of_set X a = connected_component_of_set (subtopology X U) a"
    by (metis a connected_component_of_subtopology_eq)
  then show ?thesis
    by (simp add: Ceq \<open>a \<in> U\<close> \<open>a \<in> topspace X\<close> connected_component_in_connected_components_of)
qed

thm connected_space_iff_components_eq

lemma open_in_finite_connected_components:
  assumes "finite(connected_components_of X)" "C \<in> connected_components_of X"
  shows "openin X C"
proof -
  have "closedin X (topspace X - C)"
    by (metis DiffD1 assms closedin_Union closedin_connected_components_of complement_connected_components_of_Union finite_Diff)
  then show ?thesis
    by (simp add: assms connected_components_of_subset openin_closedin)
qed
thm connected_component_of_eq_overlap

lemma connected_components_of_disjoint:
  assumes "C \<in> connected_components_of X" "C' \<in> connected_components_of X"
    shows "(disjnt C C' \<longleftrightarrow> (C \<noteq> C'))"
proof -
  have "C \<noteq> {}"
    using nonempty_connected_components_of assms by blast
  with assms show ?thesis
    by (metis disjnt_self_iff_empty pairwiseD pairwise_disjoint_connected_components_of)
qed

lemma connected_components_of_overlap:
   "\<lbrakk>C \<in> connected_components_of X; C' \<in> connected_components_of X\<rbrakk> \<Longrightarrow> C \<inter> C' \<noteq> {} \<longleftrightarrow> C = C'"
  by (meson connected_components_of_disjoint disjnt_def)

lemma pairwise_separated_connected_components_of:
   "pairwise (separatedin X) (connected_components_of X)"
  by (simp add: closedin_connected_components_of connected_components_of_disjoint pairwiseI separatedin_closed_sets)

lemma finite_connected_components_of_finite:
   "finite(topspace X) \<Longrightarrow> finite(connected_components_of X)"
  by (simp add: Union_connected_components_of finite_UnionD)

lemma connected_component_of_unique:
   "\<lbrakk>x \<in> C; connectedin X C; \<And>C'. x \<in> C' \<and> connectedin X C' \<Longrightarrow> C' \<subseteq> C\<rbrakk>
        \<Longrightarrow> connected_component_of_set X x = C"
  by (meson connected_component_of_maximal connectedin_connected_component_of subsetD subset_antisym)

lemma closedin_connected_component_of_subtopology:
   "\<lbrakk>C \<in> connected_components_of (subtopology X s); X closure_of C \<subseteq> s\<rbrakk> \<Longrightarrow> closedin X C"
  by (metis closedin_Int_closure_of closedin_connected_components_of closure_of_eq inf.absorb_iff2)

lemma connected_component_of_discrete_topology:
   "connected_component_of_set (discrete_topology U) x = (if x \<in> U then {x} else {})"
  by (simp add: locally_path_connected_space_discrete_topology flip: path_component_eq_connected_component_of)

lemma connected_components_of_discrete_topology:
   "connected_components_of (discrete_topology U) = (\<lambda>x. {x}) ` U"
  by (simp add: connected_component_of_discrete_topology connected_components_of_def)

lemma connected_component_of_continuous_image:
   "\<lbrakk>continuous_map X Y f; connected_component_of X x y\<rbrakk>
        \<Longrightarrow> connected_component_of Y (f x) (f y)"
  by (meson connected_component_of_def connectedin_continuous_map_image image_eqI)

lemma homeomorphic_map_connected_component_of:
  assumes "homeomorphic_map X Y f" and x: "x \<in> topspace X"
  shows "connected_component_of_set Y (f x) = f ` (connected_component_of_set X x)"
proof -
  obtain g where g: "continuous_map X Y f"
    "continuous_map Y X g " "\<And>x. x \<in> topspace X \<Longrightarrow> g (f x) = x" 
    "\<And>y. y \<in> topspace Y \<Longrightarrow> f (g y) = y"
    using assms(1) homeomorphic_map_maps homeomorphic_maps_def by fastforce
  show ?thesis
    using connected_component_in_topspace [of Y] x g
          connected_component_of_continuous_image [of X Y f]
          connected_component_of_continuous_image [of Y X g]
    by force
qed

lemma homeomorphic_map_connected_components_of:
  assumes "homeomorphic_map X Y f"
  shows "connected_components_of Y = (image f) ` (connected_components_of X)"
proof -
  have "topspace Y = f ` topspace X"
    by (metis assms homeomorphic_imp_surjective_map)
  with homeomorphic_map_connected_component_of [OF assms] show ?thesis
    by (auto simp: connected_components_of_def image_iff)
qed

lemma connected_component_of_pair:
   "connected_component_of_set (prod_topology X Y) (x,y) =
        connected_component_of_set X x \<times> connected_component_of_set Y y"
proof (cases "x \<in> topspace X \<and> y \<in> topspace Y")
  case True
  show ?thesis
  proof (rule connected_component_of_unique)
    show "(x, y) \<in> connected_component_of_set X x \<times> connected_component_of_set Y y"
      using True by (simp add: connected_component_of_refl)
    show "connectedin (prod_topology X Y) (connected_component_of_set X x \<times> connected_component_of_set Y y)"
      by (metis connectedin_Times connectedin_connected_component_of)
    show "C \<subseteq> connected_component_of_set X x \<times> connected_component_of_set Y y"
      if "(x, y) \<in> C \<and> connectedin (prod_topology X Y) C" for C 
      using that unfolding connected_component_of_def
      apply clarsimp
      by (metis (no_types) connectedin_continuous_map_image continuous_map_fst continuous_map_snd fst_conv imageI snd_conv)
  qed
next
  case False then show ?thesis
    by (metis Sigma_empty1 Sigma_empty2 connected_component_of_eq_empty mem_Sigma_iff topspace_prod_topology)
qed

lemma connected_components_of_prod_topology:
  "connected_components_of (prod_topology X Y) =
    {C \<times> D |C D. C \<in> connected_components_of X \<and> D \<in> connected_components_of Y}" (is "?lhs=?rhs")
proof
  show "?lhs \<subseteq> ?rhs"
    apply (clarsimp simp: connected_components_of_def)
    by (metis (no_types) connected_component_of_pair imageI)
next
  show "?rhs \<subseteq> ?lhs"
    using connected_component_of_pair
    by (fastforce simp: connected_components_of_def)
qed


lemma connected_component_of_product_topology:
   "connected_component_of_set (product_topology X I) x =
    (if x \<in> extensional I then PiE I (\<lambda>i. connected_component_of_set (X i) (x i)) else {})"
    (is "?lhs = If _ ?R _")    
proof (cases "x \<in> topspace(product_topology X I)")
  case True
  have "?lhs = (\<Pi>\<^sub>E i\<in>I. connected_component_of_set (X i) (x i))"
    if xX: "\<And>i. i\<in>I \<Longrightarrow> x i \<in> topspace (X i)" and ext: "x \<in> extensional I"
  proof (rule connected_component_of_unique)
    show "x \<in> ?R"
      by (simp add: PiE_iff connected_component_of_refl local.ext xX)
    show "connectedin (product_topology X I) ?R"
      by (simp add: connectedin_PiE connectedin_connected_component_of)
    show "C \<subseteq> ?R"
      if "x \<in> C \<and> connectedin (product_topology X I) C" for C 
    proof -
      have "C \<subseteq> extensional I"
        using PiE_def connectedin_subset_topspace that by fastforce
      have "\<And>y. y \<in> C \<Longrightarrow> y \<in> (\<Pi> i\<in>I. connected_component_of_set (X i) (x i))"
        apply (simp add: connected_component_of_def Pi_def)
        by (metis connectedin_continuous_map_image continuous_map_product_projection imageI that)
      then show ?thesis
        using PiE_def \<open>C \<subseteq> extensional I\<close> by fastforce
    qed
  qed
  with True show ?thesis
    by (simp add: PiE_iff)
next
  case False
  then show ?thesis
    apply (simp add: PiE_iff)
    by (smt (verit) Collect_empty_eq False PiE_eq_empty_iff PiE_iff connected_component_of_eq_empty)
qed


lemma connected_components_of_product_topology:
   "connected_components_of (product_topology X I) =
    {PiE I B |B. \<forall>i \<in> I. B i \<in> connected_components_of(X i)}"  (is "?lhs=?rhs")
proof
  show "?lhs \<subseteq> ?rhs"
    by (auto simp: connected_components_of_def connected_component_of_product_topology PiE_iff)
  show "?rhs \<subseteq> ?lhs"
  proof
    fix F
    assume "F \<in> ?rhs"
    then obtain B where Feq: "F = Pi\<^sub>E I B" and
      "\<forall>i\<in>I. \<exists>x\<in>topspace (X i). B i = connected_component_of_set (X i) x"
      by (force simp: connected_components_of_def connected_component_of_product_topology image_iff)
    then obtain f where
      f: "\<And>i. i \<in> I \<Longrightarrow> f i \<in> topspace (X i) \<and> B i = connected_component_of_set (X i) (f i)"
      by metis
    then have "(\<lambda>i\<in>I. f i) \<in> ((\<Pi>\<^sub>E i\<in>I. topspace (X i)) \<inter> extensional I)"
      by simp
    with f show "F \<in> ?lhs"
      unfolding Feq connected_components_of_def connected_component_of_product_topology image_iff
      by (smt (verit, del_insts) PiE_cong restrict_PiE_iff restrict_apply' restrict_extensional topspace_product_topology)
  qed
qed


subsection \<open>Monotone maps (in the general topological sense)\<close>


definition monotone_map 
  where "monotone_map X Y f ==
        f ` (topspace X) \<subseteq> topspace Y \<and>
        (\<forall>y \<in> topspace Y. connectedin X {x \<in> topspace X. f x = y})"

lemma monotone_map:
  "monotone_map X Y f \<longleftrightarrow>
   f ` (topspace X) \<subseteq> topspace Y \<and> (\<forall>y. connectedin X {x \<in> topspace X. f x = y})"
  apply (simp add: monotone_map_def)
  by (metis (mono_tags, lifting) connectedin_empty [of X] Collect_empty_eq image_subset_iff) 


lemma monotone_map_in_subtopology:
   "monotone_map X (subtopology Y S) f \<longleftrightarrow> monotone_map X Y f \<and> f ` (topspace X) \<subseteq> S"
  by (smt (verit, del_insts) le_inf_iff monotone_map topspace_subtopology)

lemma monotone_map_from_subtopology:
  assumes "monotone_map X Y f" 
    "\<And>x y. x \<in> topspace X \<and> y \<in> topspace X \<and> x \<in> S \<and> f x = f y \<Longrightarrow> y \<in> S"
  shows "monotone_map (subtopology X S) Y f"
  using assms
  unfolding monotone_map_def connectedin_subtopology
  by (smt (verit, del_insts) Collect_cong Collect_empty_eq IntE IntI connectedin_empty image_subset_iff mem_Collect_eq subsetI topspace_subtopology)

lemma monotone_map_restriction:
  "monotone_map X Y f \<and> {x \<in> topspace X. f x \<in> v} = u
        \<Longrightarrow> monotone_map (subtopology X u) (subtopology Y v) f"
  by (smt (verit, best) IntI Int_Collect image_subset_iff mem_Collect_eq monotone_map monotone_map_from_subtopology topspace_subtopology)

lemma injective_imp_monotone_map:
  assumes "f ` topspace X \<subseteq> topspace Y"  "inj_on f (topspace X)"
  shows "monotone_map X Y f"
  unfolding monotone_map_def
proof (intro conjI assms strip)
  fix y
  assume "y \<in> topspace Y"
  then have "{x \<in> topspace X. f x = y} = {} \<or> (\<exists>a \<in> topspace X. {x \<in> topspace X. f x = y} = {a})"
    using assms(2) unfolding inj_on_def by blast
  then show "connectedin X {x \<in> topspace X. f x = y}"
    by (metis (no_types, lifting) connectedin_empty connectedin_sing)
qed

lemma embedding_imp_monotone_map:
   "embedding_map X Y f \<Longrightarrow> monotone_map X Y f"
  by (metis (no_types) embedding_map_def homeomorphic_eq_everything_map inf.absorb_iff2 injective_imp_monotone_map topspace_subtopology)

lemma section_imp_monotone_map:
   "section_map X Y f \<Longrightarrow> monotone_map X Y f"
  by (simp add: embedding_imp_monotone_map section_imp_embedding_map)

lemma homeomorphic_imp_monotone_map:
   "homeomorphic_map X Y f \<Longrightarrow> monotone_map X Y f"
  by (meson section_and_retraction_eq_homeomorphic_map section_imp_monotone_map)

lemma connected_space_monotone_quotient_map_preimage:
  assumes f: "monotone_map X Y f" "quotient_map X Y f" and "connected_space Y"
  shows "connected_space X"
proof (rule ccontr)
  assume "\<not> connected_space X"
  then obtain U V where "openin X U" "openin X V" "U \<inter> V = {}"
    "U \<noteq> {}" "V \<noteq> {}" and topUV: "topspace X \<subseteq> U \<union> V"
    by (auto simp: connected_space_def)
  then have UVsub: "U \<subseteq> topspace X" "V \<subseteq> topspace X"
    by (auto simp add: openin_subset)
  have "\<not> connected_space Y"
    unfolding connected_space_def not_not
  proof (intro exI conjI)
    show "topspace Y \<subseteq> f`U \<union> f`V"
      by (metis f(2) image_Un quotient_imp_surjective_map subset_Un_eq topUV)
    show "f`U \<noteq> {}"
      by (simp add: \<open>U \<noteq> {}\<close>)
    show "(f`V) \<noteq> {}"
      by (simp add: \<open>V \<noteq> {}\<close>)
    have *: "y \<notin> f ` V" if "y \<in> f ` U" for y
    proof -
      have \<section>: "connectedin X {x \<in> topspace X. f x = y}"
        using f(1) monotone_map by fastforce
      show ?thesis
        using connectedinD [OF \<section> \<open>openin X U\<close> \<open>openin X V\<close>] UVsub topUV \<open>U \<inter> V = {}\<close> that
        by (force simp: disjoint_iff)
    qed
    then show "f`U \<inter> f`V = {}"
      by blast
    show "openin Y (f`U)"
      using f \<open>openin X U\<close> topUV * unfolding quotient_map_saturated_open by force
    show "openin Y (f`V)"
      using f \<open>openin X V\<close> topUV * unfolding quotient_map_saturated_open by force
  qed
  then show False
    by (simp add: assms)
qed

lemma connectedin_monotone_quotient_map_preimage:
  assumes "monotone_map X Y f" "quotient_map X Y f" "connectedin Y C" "openin Y C \<or> closedin Y C"
  shows "connectedin X {x \<in> topspace X. f x \<in> C}"
proof -
  have "connected_space (subtopology X {x \<in> topspace X. f x \<in> C})"
  proof -
    have "connected_space (subtopology Y C)"
      using \<open>connectedin Y C\<close> connectedin_def by blast
    moreover have "quotient_map (subtopology X {a \<in> topspace X. f a \<in> C}) (subtopology Y C) f"
      by (simp add: assms quotient_map_restriction)
    ultimately show ?thesis
      using \<open>monotone_map X Y f\<close> connected_space_monotone_quotient_map_preimage monotone_map_restriction by blast
  qed
  then show ?thesis
    by (simp add: connectedin_def)
qed

lemma monotone_open_map:
  assumes "continuous_map X Y f" "open_map X Y f" and fim: "f ` (topspace X) = topspace Y"
  shows "monotone_map X Y f \<longleftrightarrow> (\<forall>C. connectedin Y C \<longrightarrow> connectedin X {x \<in> topspace X. f x \<in> C})"
         (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
    unfolding connectedin_def
  proof (intro strip conjI)
    fix C
    assume C: "C \<subseteq> topspace Y \<and> connected_space (subtopology Y C)"
    show "connected_space (subtopology X {x \<in> topspace X. f x \<in> C})"
    proof (rule connected_space_monotone_quotient_map_preimage)
      show "monotone_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
        by (simp add: L monotone_map_restriction)
      show "quotient_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
      proof (rule continuous_open_imp_quotient_map)
        show "continuous_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
          using assms continuous_map_from_subtopology continuous_map_in_subtopology by fastforce
      qed (use open_map_restriction assms in fastforce)+
    qed (simp add: C)
  qed auto
next
  assume ?rhs 
  then have "\<forall>y. connectedin Y {y} \<longrightarrow> connectedin X {x \<in> topspace X. f x = y}"
    by (smt (verit) Collect_cong singletonD singletonI)
  then show ?lhs
    by (simp add: fim monotone_map_def)
qed

lemma monotone_closed_map:
  assumes "continuous_map X Y f" "closed_map X Y f" and fim: "f ` (topspace X) = topspace Y"
  shows "monotone_map X Y f \<longleftrightarrow> (\<forall>C. connectedin Y C \<longrightarrow> connectedin X {x \<in> topspace X. f x \<in> C})" 
         (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
    unfolding connectedin_def
  proof (intro strip conjI)
    fix C
    assume C: "C \<subseteq> topspace Y \<and> connected_space (subtopology Y C)"
    show "connected_space (subtopology X {x \<in> topspace X. f x \<in> C})"
    proof (rule connected_space_monotone_quotient_map_preimage)
      show "monotone_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
        by (simp add: L monotone_map_restriction)
      show "quotient_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
      proof (rule continuous_closed_imp_quotient_map)
        show "continuous_map (subtopology X {x \<in> topspace X. f x \<in> C}) (subtopology Y C) f"
          using assms continuous_map_from_subtopology continuous_map_in_subtopology by fastforce
      qed (use closed_map_restriction assms in fastforce)+
    qed (simp add: C)
  qed auto
next
  assume ?rhs 
  then have "\<forall>y. connectedin Y {y} \<longrightarrow> connectedin X {x \<in> topspace X. f x = y}"
    by (smt (verit) Collect_cong singletonD singletonI)
  then show ?lhs
    by (simp add: fim monotone_map_def)
qed

subsection\<open>Other countability properties\<close>

definition second_countable
  where "second_countable X \<equiv>
         \<exists>\<B>. countable \<B> \<and> (\<forall>V \<in> \<B>. openin X V) \<and>
             (\<forall>U x. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U))"

definition first_countable
  where "first_countable X \<equiv>
        \<forall>x \<in> topspace X.
         \<exists>\<B>. countable \<B> \<and> (\<forall>V \<in> \<B>. openin X V) \<and>
             (\<forall>U. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U))"

definition separable_space
  where "separable_space X \<equiv>
        \<exists>C. countable C \<and> C \<subseteq> topspace X \<and> X closure_of C = topspace X"

lemma second_countable:
   "second_countable X \<longleftrightarrow>
        (\<exists>\<B>. countable \<B> \<and> openin X = arbitrary union_of (\<lambda>x. x \<in> \<B>))"
  by (smt (verit) openin_topology_base_unique second_countable_def)

lemma second_countable_subtopology:
  assumes "second_countable X"
  shows "second_countable (subtopology X S)"
proof -
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    "\<And>U x. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms by (auto simp: second_countable_def)
  show ?thesis
    unfolding second_countable_def
  proof (intro exI conjI)
    show "\<forall>V\<in>((\<inter>)S) ` \<B>. openin (subtopology X S) V"
      using openin_subtopology_Int2 \<B> by blast
    show "\<forall>U x. openin (subtopology X S) U \<and> x \<in> U \<longrightarrow> (\<exists>V\<in>((\<inter>)S) ` \<B>. x \<in> V \<and> V \<subseteq> U)"
      using \<B> subset_iff by (fastforce simp: image_iff openin_subtopology)
  qed (use \<B> in auto)
qed


lemma second_countable_discrete_topology:
   "second_countable(discrete_topology U) \<longleftrightarrow> countable U" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> V \<subseteq> U"
    "\<And>W x. W \<subseteq> U \<and> x \<in> W \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> W)"
    by (auto simp: second_countable_def)
  then have "{x} \<in> \<B>" if "x \<in> U" for x
    by (metis empty_subsetI insertCI insert_subset subset_antisym that)
  then show ?rhs
    by (smt (verit) countable_subset image_subsetI \<open>countable \<B>\<close> countable_image_inj_on [OF _ inj_singleton])
next
  assume ?rhs 
  then show ?lhs
    unfolding second_countable_def
    by (rule_tac x="(\<lambda>x. {x}) ` U" in exI) auto
qed

lemma second_countable_open_map_image:
  assumes "continuous_map X Y f" "open_map X Y f" 
   and fim: "f ` (topspace X) = topspace Y" and "second_countable X"
 shows "second_countable Y"
proof -
  have openXYf: "\<And>U. openin X U \<longrightarrow> openin Y (f ` U)"
    using assms by (auto simp: open_map_def)
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    and *: "\<And>U x. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms by (auto simp: second_countable_def)
  show ?thesis
    unfolding second_countable_def
  proof (intro exI conjI strip)
    fix V y
    assume V: "openin Y V \<and> y \<in> V"
    then obtain x where "x \<in> topspace X" and x: "f x = y"
      by (metis fim image_iff openin_subset subsetD)

    then obtain W where "W\<in>\<B>" "x \<in> W" "W \<subseteq> {x \<in> topspace X. f x \<in> V}"
      using * [of "{x \<in> topspace X. f x \<in> V}" x] V assms openin_continuous_map_preimage 
      by force
    then show "\<exists>W \<in> (image f) ` \<B>. y \<in> W \<and> W \<subseteq> V"
      using x by auto
  qed (use \<B> openXYf in auto)
qed

lemma homeomorphic_space_second_countability:
   "X homeomorphic_space Y \<Longrightarrow> (second_countable X \<longleftrightarrow> second_countable Y)"
  by (meson homeomorphic_eq_everything_map homeomorphic_space homeomorphic_space_sym second_countable_open_map_image)

lemma second_countable_retraction_map_image:
   "\<lbrakk>retraction_map X Y r; second_countable X\<rbrakk> \<Longrightarrow> second_countable Y"
  using hereditary_imp_retractive_property homeomorphic_space_second_countability second_countable_subtopology by blast

lemma second_countable_imp_first_countable:
   "second_countable X \<Longrightarrow> first_countable X"
  by (metis first_countable_def second_countable_def)

lemma first_countable_subtopology:
  assumes "first_countable X"
  shows "first_countable (subtopology X S)"
  unfolding first_countable_def
proof
  fix x
  assume "x \<in> topspace (subtopology X S)"
  then obtain \<B> where "countable \<B>" and \<B>: "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    "\<And>U. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms first_countable_def by force
  show "\<exists>\<B>. countable \<B> \<and> (\<forall>V\<in>\<B>. openin (subtopology X S) V) \<and> (\<forall>U. openin (subtopology X S) U \<and> x \<in> U \<longrightarrow> (\<exists>V\<in>\<B>. x \<in> V \<and> V \<subseteq> U))"
  proof (intro exI conjI strip)
    show "countable (((\<inter>)S) ` \<B>)"
      using \<open>countable \<B>\<close> by blast
    show "openin (subtopology X S) V" if "V \<in> ((\<inter>)S) ` \<B>" for V
      using \<B> openin_subtopology_Int2 that by fastforce
    show "\<exists>V\<in>((\<inter>)S) ` \<B>. x \<in> V \<and> V \<subseteq> U"
      if "openin (subtopology X S) U \<and> x \<in> U" for U 
      using that \<B>(2) by (clarsimp simp add: openin_subtopology) (meson le_infI2)
  qed
qed

lemma first_countable_discrete_topology:
   "first_countable (discrete_topology U)"
  unfolding first_countable_def topspace_discrete_topology openin_discrete_topology
proof
  fix x assume "x \<in> U"
  show "\<exists>\<B>. countable \<B> \<and> (\<forall>V\<in>\<B>. V \<subseteq> U) \<and> (\<forall>Ua. Ua \<subseteq> U \<and> x \<in> Ua \<longrightarrow> (\<exists>V\<in>\<B>. x \<in> V \<and> V \<subseteq> Ua))"
    using \<open>x \<in> U\<close> by (rule_tac x="{{x}}" in exI) auto
qed

lemma first_countable_open_map_image:
  assumes "continuous_map X Y f" "open_map X Y f" 
   and fim: "f ` (topspace X) = topspace Y" and "first_countable X"
 shows "first_countable Y"
  unfolding first_countable_def
proof
  fix y
  assume "y \<in> topspace Y"
  have openXYf: "\<And>U. openin X U \<longrightarrow> openin Y (f ` U)"
    using assms by (auto simp: open_map_def)
  then obtain x where x: "x \<in> topspace X" "f x = y"
    by (metis \<open>y \<in> topspace Y\<close> fim imageE)
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    and *: "\<And>U. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms x first_countable_def by force
  show "\<exists>\<B>. countable \<B> \<and>
              (\<forall>V\<in>\<B>. openin Y V) \<and> (\<forall>U. openin Y U \<and> y \<in> U \<longrightarrow> (\<exists>V\<in>\<B>. y \<in> V \<and> V \<subseteq> U))"
  proof (intro exI conjI strip)
    fix V assume "openin Y V \<and> y \<in> V"
    then have "\<exists>W\<in>\<B>. x \<in> W \<and> W \<subseteq> {x \<in> topspace X. f x \<in> V}"
      using * [of "{x \<in> topspace X. f x \<in> V}"] assms openin_continuous_map_preimage x 
      by fastforce
    then show "\<exists>V' \<in> (image f) ` \<B>. y \<in> V' \<and> V' \<subseteq> V"
      using image_mono x by auto 
  qed (use \<B> openXYf in force)+
qed

lemma homeomorphic_space_first_countability:
  "X homeomorphic_space Y \<Longrightarrow> first_countable X \<longleftrightarrow> first_countable Y"
  by (meson first_countable_open_map_image homeomorphic_eq_everything_map homeomorphic_space homeomorphic_space_sym)

lemma first_countable_retraction_map_image:
   "\<lbrakk>retraction_map X Y r; first_countable X\<rbrakk> \<Longrightarrow> first_countable Y"
  using first_countable_subtopology hereditary_imp_retractive_property homeomorphic_space_first_countability by blast

lemma separable_space_open_subset:
  assumes "separable_space X" "openin X S"
  shows "separable_space (subtopology X S)"
proof -
  obtain C where C: "countable C" "C \<subseteq> topspace X" "X closure_of C = topspace X"
    by (meson assms separable_space_def)
  then have "\<And>x T. \<lbrakk>x \<in> topspace X; x \<in> T; openin (subtopology X S) T\<rbrakk>
           \<Longrightarrow> \<exists>y. y \<in> S \<and> y \<in> C \<and> y \<in> T"
    by (smt (verit) \<open>openin X S\<close> in_closure_of openin_open_subtopology subsetD)
  with C \<open>openin X S\<close> show ?thesis
    unfolding separable_space_def
    by (rule_tac x="S \<inter> C" in exI) (force simp: in_closure_of)
qed

lemma separable_space_continuous_map_image:
  assumes "separable_space X" "continuous_map X Y f" 
    and fim: "f ` (topspace X) = topspace Y"
  shows "separable_space Y"
proof -
  have cont: "\<And>S. f ` (X closure_of S) \<subseteq> Y closure_of f ` S"
    by (simp add: assms continuous_map_image_closure_subset)
  obtain C where C: "countable C" "C \<subseteq> topspace X" "X closure_of C = topspace X"
    by (meson assms separable_space_def)
  then show ?thesis
    unfolding separable_space_def
    by (metis cont fim closure_of_subset_topspace countable_image image_mono subset_antisym)
qed

lemma separable_space_quotient_map_image:
  "\<lbrakk>quotient_map X Y q; separable_space X\<rbrakk> \<Longrightarrow> separable_space Y"
  by (meson quotient_imp_continuous_map quotient_imp_surjective_map separable_space_continuous_map_image)

lemma separable_space_retraction_map_image:
  "\<lbrakk>retraction_map X Y r; separable_space X\<rbrakk> \<Longrightarrow> separable_space Y"
  using retraction_imp_quotient_map separable_space_quotient_map_image by blast

lemma homeomorphic_separable_space:
  "X homeomorphic_space Y \<Longrightarrow> (separable_space X \<longleftrightarrow> separable_space Y)"
  by (meson homeomorphic_eq_everything_map homeomorphic_maps_map homeomorphic_space_def separable_space_continuous_map_image)

lemma separable_space_discrete_topology:
   "separable_space(discrete_topology U) \<longleftrightarrow> countable U"
  by (metis countable_Int2 discrete_topology_closure_of dual_order.refl inf.orderE separable_space_def topspace_discrete_topology)

lemma second_countable_imp_separable_space:
  assumes "second_countable X"
  shows "separable_space X"
proof -
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    and *: "\<And>U x. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms by (auto simp: second_countable_def)
  obtain c where c: "\<And>V. \<lbrakk>V \<in> \<B>; V \<noteq> {}\<rbrakk> \<Longrightarrow> c V \<in> V"
    by (metis all_not_in_conv)
  then have **: "\<And>x. x \<in> topspace X \<Longrightarrow> x \<in> X closure_of c ` (\<B> - {{}})"
    using * by (force simp: closure_of_def)
  show ?thesis
    unfolding separable_space_def
  proof (intro exI conjI)
    show "countable (c ` (\<B>-{{}}))"
      using \<B>(1) by blast
    show "(c ` (\<B>-{{}})) \<subseteq> topspace X"
      using \<B>(2) c openin_subset by fastforce
    show "X closure_of (c ` (\<B>-{{}})) = topspace X"
      by (meson ** closure_of_subset_topspace subsetI subset_antisym)
  qed
qed

lemma second_countable_imp_Lindelof_space:
  assumes "second_countable X"
  shows "Lindelof_space X"
unfolding Lindelof_space_def
proof clarify
  fix \<U>
  assume "\<forall>U \<in> \<U>. openin X U" and UU: "\<Union>\<U> = topspace X"
  obtain \<B> where \<B>: "countable \<B>" "\<And>V. V \<in> \<B> \<Longrightarrow> openin X V"
    and *: "\<And>U x. openin X U \<and> x \<in> U \<longrightarrow> (\<exists>V \<in> \<B>. x \<in> V \<and> V \<subseteq> U)"
    using assms by (auto simp: second_countable_def)
  define \<B>' where "\<B>' = {B \<in> \<B>. \<exists>U. U \<in> \<U> \<and> B \<subseteq> U}"
  have \<B>': "countable \<B>'" "\<Union>\<B>' = \<Union>\<U>"
    using \<B> using "*" \<open>\<forall>U\<in>\<U>. openin X U\<close> by (fastforce simp: \<B>'_def)+
  have "\<And>b. \<exists>U. b \<in> \<B>' \<longrightarrow> U \<in> \<U> \<and> b \<subseteq> U" 
    by (simp add: \<B>'_def)
  then obtain G where G: "\<And>b. b \<in> \<B>' \<longrightarrow> G b \<in> \<U> \<and> b \<subseteq> G b" 
    by metis
  with \<B>' UU show "\<exists>\<V>. countable \<V> \<and> \<V> \<subseteq> \<U> \<and> \<Union>\<V> = topspace X"
    by (rule_tac x="G ` \<B>'" in exI) fastforce
qed

subsection \<open>Neigbourhood bases EXTRAS\<close>
(* Neigbourhood bases (useful for "local" properties of various kind).       *)

lemma openin_topology_neighbourhood_base_unique:
   "openin X = arbitrary union_of P \<longleftrightarrow>
        (\<forall>u. P u \<longrightarrow> openin X u) \<and> neighbourhood_base_of P X"
  by (smt (verit, best) open_neighbourhood_base_of openin_topology_base_unique)

lemma neighbourhood_base_at_topology_base:
   "        openin X = arbitrary union_of b
        \<Longrightarrow> (neighbourhood_base_at x P X \<longleftrightarrow>
             (\<forall>w. b w \<and> x \<in> w \<longrightarrow> (\<exists>u v. openin X u \<and> P v \<and> x \<in> u \<and> u \<subseteq> v \<and> v \<subseteq> w)))"
  apply (simp add: neighbourhood_base_at_def)
  by (smt (verit, del_insts) openin_topology_base_unique subset_trans)

lemma neighbourhood_base_of_unlocalized:
  assumes "\<And>S t. P S \<and> openin X t \<and> (t \<noteq> {}) \<and> t \<subseteq> S \<Longrightarrow> P t"
  shows "neighbourhood_base_of P X \<longleftrightarrow>
         (\<forall>x \<in> topspace X. \<exists>u v. openin X u \<and> P v \<and> x \<in> u \<and> u \<subseteq> v \<and> v \<subseteq> topspace X)"
  apply (simp add: neighbourhood_base_of_def)
  by (smt (verit, ccfv_SIG) assms empty_iff neighbourhood_base_at_unlocalized)

lemma neighbourhood_base_at_discrete_topology:
   "neighbourhood_base_at x P (discrete_topology u) \<longleftrightarrow> x \<in> u \<Longrightarrow> P {x}"
  apply (simp add: neighbourhood_base_at_def)
  by (smt (verit) empty_iff empty_subsetI insert_subset singletonI subsetD subset_singletonD)

lemma neighbourhood_base_of_discrete_topology:
   "neighbourhood_base_of P (discrete_topology u) \<longleftrightarrow> (\<forall>x \<in> u. P {x})"
  apply (simp add: neighbourhood_base_of_def)
  using neighbourhood_base_at_discrete_topology[of _ P u]
  by (metis empty_subsetI insert_subset neighbourhood_base_at_def openin_discrete_topology singletonI)

lemma second_countable_neighbourhood_base_alt:
  "second_countable X \<longleftrightarrow> 
  (\<exists>\<B>. countable \<B> \<and> (\<forall>V \<in> \<B>. openin X V) \<and> neighbourhood_base_of (\<lambda>A. A\<in>\<B>) X)"
  by (metis (full_types) openin_topology_neighbourhood_base_unique second_countable)

lemma first_countable_neighbourhood_base_alt:
   "first_countable X \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<exists>\<B>. countable \<B> \<and> (\<forall>V \<in> \<B>. openin X V) \<and> neighbourhood_base_at x (\<lambda>V. V \<in> \<B>) X)"
  unfolding first_countable_def
  apply (intro ball_cong refl ex_cong conj_cong)
  by (metis (mono_tags, lifting) open_neighbourhood_base_at)

lemma second_countable_neighbourhood_base:
   "second_countable X \<longleftrightarrow>
        (\<exists>\<B>. countable \<B> \<and> neighbourhood_base_of (\<lambda>V. V \<in> \<B>) X)" (is "?lhs=?rhs")
proof
  assume ?lhs 
  then show ?rhs
    using second_countable_neighbourhood_base_alt by blast
next
  assume ?rhs 
  then obtain \<B> where "countable \<B>"
    and \<B>: "\<And>W x. openin X W \<and> x \<in> W \<longrightarrow> (\<exists>U. openin X U \<and> (\<exists>V. V \<in> \<B> \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W))"
    by (metis neighbourhood_base_of)
  then show ?lhs
    unfolding second_countable_neighbourhood_base_alt neighbourhood_base_of
    apply (rule_tac x="(\<lambda>u. X interior_of u) ` \<B>" in exI)
    by (smt (verit, best) interior_of_eq interior_of_mono countable_image image_iff openin_interior_of)
qed

lemma first_countable_neighbourhood_base:
   "first_countable X \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<exists>\<B>. countable \<B> \<and> neighbourhood_base_at x (\<lambda>V. V \<in> \<B>) X)" (is "?lhs=?rhs")
proof
  assume ?lhs 
  then show ?rhs
    by (metis first_countable_neighbourhood_base_alt)
next
  assume R: ?rhs 
  show ?lhs
    unfolding first_countable_neighbourhood_base_alt
  proof
    fix x
    assume "x \<in> topspace X"
    with R obtain \<B> where "countable \<B>" and \<B>: "neighbourhood_base_at x (\<lambda>V. V \<in> \<B>) X"
      by blast
    then
    show "\<exists>\<B>. countable \<B> \<and> Ball \<B> (openin X) \<and> neighbourhood_base_at x (\<lambda>V. V \<in> \<B>) X"
      unfolding neighbourhood_base_at_def
      apply (rule_tac x="(\<lambda>u. X interior_of u) ` \<B>" in exI)
      by (smt (verit, best) countable_image image_iff interior_of_eq interior_of_mono openin_interior_of)
  qed
qed


subsection\<open>T_0 spaces and the Kolmogorov quotient\<close>


definition t0_space where
  "t0_space X \<equiv>
     \<forall>x \<in> topspace X. \<forall>y \<in> topspace X. x \<noteq> y \<longrightarrow> (\<exists>U. openin X U \<and> (x \<notin> U \<longleftrightarrow> y \<in> U))"

lemma t0_space_expansive:
   "\<lbrakk>topspace Y = topspace X; \<And>U. openin X U \<Longrightarrow> openin Y U\<rbrakk> \<Longrightarrow> t0_space X \<Longrightarrow> t0_space Y"
  by (metis t0_space_def)

lemma t1_imp_t0_space: "t1_space X \<Longrightarrow> t0_space X"
  by (metis t0_space_def t1_space_def)

lemma t1_eq_symmetric_t0_space_alt:
   "t1_space X \<longleftrightarrow>
      t0_space X \<and>
      (\<forall>x \<in> topspace X. \<forall>y \<in> topspace X. x \<in> X closure_of {y} \<longleftrightarrow> y \<in> X closure_of {x})"
  apply (simp add: t0_space_def t1_space_def closure_of_def)
  by (smt (verit, best) openin_topspace)

lemma t1_eq_symmetric_t0_space:
  "t1_space X \<longleftrightarrow> t0_space X \<and> (\<forall>x y. x \<in> X closure_of {y} \<longleftrightarrow> y \<in> X closure_of {x})"
  by (auto simp: t1_eq_symmetric_t0_space_alt in_closure_of)

lemma Hausdorff_imp_t0_space:
   "Hausdorff_space X \<Longrightarrow> t0_space X"
  by (simp add: Hausdorff_imp_t1_space t1_imp_t0_space)

lemma t0_space:
   "t0_space X \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<forall>y \<in> topspace X. x \<noteq> y \<longrightarrow> (\<exists>C. closedin X C \<and> (x \<notin> C \<longleftrightarrow> y \<in> C)))"
  unfolding t0_space_def by (metis Diff_iff closedin_def openin_closedin_eq)

lemma homeomorphic_t0_space:
  assumes "X homeomorphic_space Y"
  shows "t0_space X \<longleftrightarrow> t0_space Y"
proof -
  obtain f where f: "homeomorphic_map X Y f" and F: "inj_on f (topspace X)" and "topspace Y = f ` topspace X"
    by (metis assms homeomorphic_imp_injective_map homeomorphic_imp_surjective_map homeomorphic_space)
  with inj_on_image_mem_iff [OF F] 
  show ?thesis
    apply (simp add: t0_space_def homeomorphic_eq_everything_map continuous_map_def open_map_def inj_on_def)
    by (smt (verit)  mem_Collect_eq openin_subset)
qed

lemma t0_space_closure_of_sing:
   "t0_space X \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<forall>y \<in> topspace X. X closure_of {x} = X closure_of {y} \<longrightarrow> x = y)"
  by (simp add: t0_space_def closure_of_def set_eq_iff) (smt (verit))

lemma t0_space_discrete_topology: "t0_space (discrete_topology S)"
  by (simp add: Hausdorff_imp_t0_space)

lemma t0_space_subtopology: "t0_space X \<Longrightarrow> t0_space (subtopology X U)"
  by (simp add: t0_space_def openin_subtopology) (metis Int_iff)

lemma t0_space_retraction_map_image:
   "\<lbrakk>retraction_map X Y r; t0_space X\<rbrakk> \<Longrightarrow> t0_space Y"
  using hereditary_imp_retractive_property homeomorphic_t0_space t0_space_subtopology by blast

lemma XY: "{x}\<times>{y} = {(x,y)}"
  by simp

lemma t0_space_prod_topologyI: "\<lbrakk>t0_space X; t0_space Y\<rbrakk> \<Longrightarrow> t0_space (prod_topology X Y)"
  by (simp add: t0_space_closure_of_sing closure_of_Times closure_of_eq_empty_gen times_eq_iff flip: XY insert_Times_insert)


lemma t0_space_prod_topology_iff:
   "t0_space (prod_topology X Y) \<longleftrightarrow> topspace (prod_topology X Y) = {} \<or> t0_space X \<and> t0_space Y" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (metis Sigma_empty1 Sigma_empty2 retraction_map_fst retraction_map_snd t0_space_retraction_map_image topspace_prod_topology)
qed (metis empty_iff t0_space_def t0_space_prod_topologyI)

lemma t0_space_product_topology:
   "t0_space (product_topology X I) \<longleftrightarrow>
        topspace(product_topology X I) = {} \<or> (\<forall>i \<in> I. t0_space (X i))" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (meson retraction_map_product_projection t0_space_retraction_map_image)
next
  assume R: ?rhs 
  show ?lhs
  proof (cases "topspace(product_topology X I) = {}")
    case True
    then show ?thesis
      by (simp add: t0_space_def)
  next
    case False
    show ?thesis
      unfolding t0_space
    proof (intro strip)
      fix x y
      assume x: "x \<in> topspace (product_topology X I)"
        and y: "y \<in> topspace (product_topology X I)"
        and "x \<noteq> y"
      then obtain i where "i \<in> I" "x i \<noteq> y i"
        by (metis PiE_ext topspace_product_topology)
      then have "t0_space (X i)"
        using False R by blast
      then obtain U where "closedin (X i) U" "(x i \<notin> U \<longleftrightarrow> y i \<in> U)"
        by (metis t0_space PiE_mem \<open>i \<in> I\<close> \<open>x i \<noteq> y i\<close> topspace_product_topology x y)
      with \<open>i \<in> I\<close> x y show "\<exists>U. closedin (product_topology X I) U \<and> (x \<notin> U) = (y \<in> U)"
        by (rule_tac x="PiE I (\<lambda>j. if j = i then U else topspace(X j))" in exI)
          (simp add: closedin_product_topology PiE_iff)
    qed
  qed
qed


subsection \<open>Kolmogorov quotients\<close>

definition Kolmogorov_quotient 
  where "Kolmogorov_quotient X \<equiv> \<lambda>x. @y. \<forall>U. openin X U \<longrightarrow> (y \<in> U \<longleftrightarrow> x \<in> U)"

lemma Kolmogorov_quotient_in_open:
   "openin X U \<Longrightarrow> (Kolmogorov_quotient X x \<in> U \<longleftrightarrow> x \<in> U)"
  by (smt (verit, ccfv_SIG) Kolmogorov_quotient_def someI_ex)

lemma Kolmogorov_quotient_in_topspace:
   "Kolmogorov_quotient X x \<in> topspace X \<longleftrightarrow> x \<in> topspace X"
  by (simp add: Kolmogorov_quotient_in_open)

lemma Kolmogorov_quotient_in_closed:
  "closedin X C \<Longrightarrow> (Kolmogorov_quotient X x \<in> C \<longleftrightarrow> x \<in> C)"
  unfolding closedin_def
  by (meson DiffD2 DiffI Kolmogorov_quotient_in_open Kolmogorov_quotient_in_topspace in_mono)
 
lemma continuous_map_Kolmogorov_quotient:
   "continuous_map X X (Kolmogorov_quotient X)"
  using Kolmogorov_quotient_in_open openin_subopen openin_subset 
    by (fastforce simp add: continuous_map_def Kolmogorov_quotient_in_topspace)

lemma open_map_Kolmogorov_quotient_explicit:
   "openin X U \<Longrightarrow> Kolmogorov_quotient X ` U = Kolmogorov_quotient X ` topspace X \<inter> U"
  using Kolmogorov_quotient_in_open openin_subset by fastforce


lemma open_map_Kolmogorov_quotient_gen:
   "open_map (subtopology X S) (subtopology X (image (Kolmogorov_quotient X) S)) (Kolmogorov_quotient X)"
proof (clarsimp simp add: open_map_def openin_subtopology_alt image_iff)
  fix U
  assume "openin X U"
  then have "Kolmogorov_quotient X ` (S \<inter> U) = Kolmogorov_quotient X ` S \<inter> U"
    using Kolmogorov_quotient_in_open [of X U] by auto
  then show "\<exists>V. openin X V \<and> Kolmogorov_quotient X ` (S \<inter> U) = Kolmogorov_quotient X ` S \<inter> V"
    using \<open>openin X U\<close> by blast
qed

lemma open_map_Kolmogorov_quotient:
   "open_map X (subtopology X (Kolmogorov_quotient X ` topspace X))
     (Kolmogorov_quotient X)"
  by (metis open_map_Kolmogorov_quotient_gen subtopology_topspace)

lemma closed_map_Kolmogorov_quotient_explicit:
   "closedin X U \<Longrightarrow> Kolmogorov_quotient X ` U = Kolmogorov_quotient X ` topspace X \<inter> U"
  using closedin_subset by (fastforce simp add: Kolmogorov_quotient_in_closed)

lemma closed_map_Kolmogorov_quotient_gen:
   "closed_map (subtopology X S) (subtopology X (Kolmogorov_quotient X ` S))
     (Kolmogorov_quotient X)"
  using Kolmogorov_quotient_in_closed by (force simp: closed_map_def closedin_subtopology_alt image_iff)

lemma closed_map_Kolmogorov_quotient:
   "closed_map X (subtopology X (Kolmogorov_quotient X ` topspace X))
     (Kolmogorov_quotient X)"
  by (metis closed_map_Kolmogorov_quotient_gen subtopology_topspace)

lemma quotient_map_Kolmogorov_quotient_gen:
  "quotient_map (subtopology X S) (subtopology X (Kolmogorov_quotient X ` S)) (Kolmogorov_quotient X)"
proof (intro continuous_open_imp_quotient_map)
  show "continuous_map (subtopology X S) (subtopology X (Kolmogorov_quotient X ` S)) (Kolmogorov_quotient X)"
    by (simp add: continuous_map_Kolmogorov_quotient continuous_map_from_subtopology continuous_map_in_subtopology image_mono)
  show "open_map (subtopology X S) (subtopology X (Kolmogorov_quotient X ` S)) (Kolmogorov_quotient X)"
    using open_map_Kolmogorov_quotient_gen by blast
  show "Kolmogorov_quotient X ` topspace (subtopology X S) = topspace (subtopology X (Kolmogorov_quotient X ` S))"
    by (force simp add: Kolmogorov_quotient_in_open)
qed

lemma quotient_map_Kolmogorov_quotient:
   "quotient_map X (subtopology X (Kolmogorov_quotient X ` topspace X)) (Kolmogorov_quotient X)"
  by (metis quotient_map_Kolmogorov_quotient_gen subtopology_topspace)

lemma Kolmogorov_quotient_eq:
   "Kolmogorov_quotient X x = Kolmogorov_quotient X y \<longleftrightarrow>
    (\<forall>U. openin X U \<longrightarrow> (x \<in> U \<longleftrightarrow> y \<in> U))" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis Kolmogorov_quotient_in_open)
next
  assume ?rhs then show ?lhs
    by (simp add: Kolmogorov_quotient_def)
qed

lemma Kolmogorov_quotient_eq_alt:
   "Kolmogorov_quotient X x = Kolmogorov_quotient X y \<longleftrightarrow>
    (\<forall>U. closedin X U \<longrightarrow> (x \<in> U \<longleftrightarrow> y \<in> U))" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis Kolmogorov_quotient_in_closed)
next
  assume ?rhs then show ?lhs
    by (smt (verit) Diff_iff Kolmogorov_quotient_eq closedin_topspace in_mono openin_closedin_eq)
qed

lemma Kolmogorov_quotient_continuous_map:
  assumes "continuous_map X Y f" "t0_space Y" and x: "x \<in> topspace X"
  shows "f (Kolmogorov_quotient X x) = f x"
  using assms unfolding continuous_map_def t0_space_def
  by (smt (verit, ccfv_SIG) Kolmogorov_quotient_in_open Kolmogorov_quotient_in_topspace x mem_Collect_eq)

lemma t0_space_Kolmogorov_quotient:
  "t0_space (subtopology X (Kolmogorov_quotient X ` topspace X))"
  apply (clarsimp simp add: t0_space_def )
  by (smt (verit, best) Kolmogorov_quotient_eq imageE image_eqI open_map_Kolmogorov_quotient open_map_def)

lemma Kolmogorov_quotient_id:
   "t0_space X \<Longrightarrow> x \<in> topspace X \<Longrightarrow> Kolmogorov_quotient X x = x"
  by (metis Kolmogorov_quotient_in_open Kolmogorov_quotient_in_topspace t0_space_def)

lemma Kolmogorov_quotient_idemp:
   "Kolmogorov_quotient X (Kolmogorov_quotient X x) = Kolmogorov_quotient X x"
  by (simp add: Kolmogorov_quotient_eq Kolmogorov_quotient_in_open)

lemma retraction_maps_Kolmogorov_quotient:
   "retraction_maps X
     (subtopology X (Kolmogorov_quotient X ` topspace X))
     (Kolmogorov_quotient X) id"
  unfolding retraction_maps_def continuous_map_in_subtopology
  using Kolmogorov_quotient_idemp continuous_map_Kolmogorov_quotient by force

lemma retraction_map_Kolmogorov_quotient:
   "retraction_map X
     (subtopology X (Kolmogorov_quotient X ` topspace X))
     (Kolmogorov_quotient X)"
  using retraction_map_def retraction_maps_Kolmogorov_quotient by blast

lemma retract_of_space_Kolmogorov_quotient_image:
   "Kolmogorov_quotient X ` topspace X retract_of_space X"
proof -
  have "continuous_map X X (Kolmogorov_quotient X)"
    by (simp add: continuous_map_Kolmogorov_quotient)
  then have "Kolmogorov_quotient X ` topspace X \<subseteq> topspace X"
    by (simp add: continuous_map_image_subset_topspace)
  then show ?thesis
    by (meson retract_of_space_retraction_maps retraction_maps_Kolmogorov_quotient)
qed

lemma Kolmogorov_quotient_lift_exists:
  assumes "S \<subseteq> topspace X" "t0_space Y" and f: "continuous_map (subtopology X S) Y f"
  obtains g where "continuous_map (subtopology X (image (Kolmogorov_quotient X) S)) Y g"
              "\<And>x. x \<in> S \<Longrightarrow> g(Kolmogorov_quotient X x) = f x"
proof -
  have "\<And>x y. \<lbrakk>x \<in> S; y \<in> S; Kolmogorov_quotient X x = Kolmogorov_quotient X y\<rbrakk>
            \<Longrightarrow> f x = f y"
    using assms
    apply (simp add: Kolmogorov_quotient_eq t0_space_def continuous_map_def Int_absorb1 openin_subtopology)
    by (smt (verit, del_insts) Int_iff mem_Collect_eq)
  then obtain g where g: "continuous_map (subtopology X (Kolmogorov_quotient X ` S)) Y g"
    "g ` (topspace X \<inter> Kolmogorov_quotient X ` S) = f ` S"
    "\<And>x. x \<in> S \<Longrightarrow> g (Kolmogorov_quotient X x) = f x"
    using quotient_map_lift_exists [OF quotient_map_Kolmogorov_quotient_gen [of X S] f]
    by (metis assms(1) topspace_subtopology topspace_subtopology_subset) 
  show ?thesis
    proof qed (use g in auto)
qed

subsection\<open>Closed diagonals and graphs\<close>

lemma Hausdorff_space_closedin_diagonal:
  "Hausdorff_space X \<longleftrightarrow>
        closedin (prod_topology X X) ((\<lambda>x. (x,x)) ` topspace X)"
proof -
  have \<section>: "((\<lambda>x. (x, x)) ` topspace X) \<subseteq> topspace X \<times> topspace X"
    by auto
  show ?thesis
    apply (simp add: closedin_def openin_prod_topology_alt Hausdorff_space_def disjnt_iff \<section>)
    apply (intro all_cong1 imp_cong ex_cong1 conj_cong refl)
    by (force dest!: openin_subset)+
qed

lemma closed_map_diag_eq:
   "closed_map X (prod_topology X X) (\<lambda>x. (x,x)) \<longleftrightarrow> Hausdorff_space X"
proof -
  have "section_map X (prod_topology X X) (\<lambda>x. (x, x))"
    unfolding section_map_def retraction_maps_def
    by (smt (verit) continuous_map_fst continuous_map_of_fst continuous_map_on_empty continuous_map_pairwise fst_conv fst_diag_fst snd_diag_fst)
  then have "embedding_map X (prod_topology X X) (\<lambda>x. (x, x))"
    by (rule section_imp_embedding_map)
  then show ?thesis
    using Hausdorff_space_closedin_diagonal embedding_imp_closed_map_eq by blast
qed


lemma closedin_continuous_maps_eq:
  assumes "Hausdorff_space Y" and f: "continuous_map X Y f" and g: "continuous_map X Y g"
  shows "closedin X {x \<in> topspace X. f x = g x}"
proof -
  have \<section>:"{x \<in> topspace X. f x = g x} = {x \<in> topspace X. (f x,g x) \<in> ((\<lambda>y.(y,y)) ` topspace Y)}"
    using f continuous_map_image_subset_topspace by fastforce
  show ?thesis
    unfolding \<section>
  proof (intro closedin_continuous_map_preimage)
    show "continuous_map X (prod_topology Y Y) (\<lambda>x. (f x, g x))"
      by (simp add: continuous_map_pairedI f g)
    show "closedin (prod_topology Y Y) ((\<lambda>y. (y, y)) ` topspace Y)"
      using Hausdorff_space_closedin_diagonal assms by blast
  qed
qed

lemma retract_of_space_imp_closedin:
  assumes "Hausdorff_space X" and S: "S retract_of_space X"
  shows "closedin X S"
proof -
  obtain r where r: "continuous_map X (subtopology X S) r" "\<forall>x\<in>S. r x = x"
    using assms by (meson retract_of_space_def)
  then have \<section>: "S = {x \<in> topspace X. r x = x}"
    using S retract_of_space_imp_subset by (force simp: continuous_map_def)
  show ?thesis
    unfolding \<section> 
    using r continuous_map_into_fulltopology assms
    by (force intro: closedin_continuous_maps_eq)
qed

lemma homeomorphic_maps_graph:
   "homeomorphic_maps X (subtopology (prod_topology X Y) ((\<lambda>x. (x, f x)) ` (topspace X)))
         (\<lambda>x. (x, f x)) fst  \<longleftrightarrow>  continuous_map X Y f" 
   (is "?lhs=?rhs")
proof
  assume ?lhs
  then 
  have h: "homeomorphic_map X (subtopology (prod_topology X Y) ((\<lambda>x. (x, f x)) ` topspace X)) (\<lambda>x. (x, f x))"
    by (auto simp: homeomorphic_maps_map)
  have "f = snd \<circ> (\<lambda>x. (x, f x))"
    by force
  then show ?rhs
    by (metis (no_types, lifting) h continuous_map_in_subtopology continuous_map_snd_of homeomorphic_eq_everything_map)
next
  assume ?rhs
  then show ?lhs
    unfolding homeomorphic_maps_def
    by (smt (verit, ccfv_threshold) continuous_map_eq continuous_map_subtopology_fst embedding_map_def embedding_map_graph homeomorphic_eq_everything_map  image_cong image_iff prod.collapse prod.inject)
qed


subsection \<open> KC spaces, those where all compact sets are closed.\<close>

definition kc_space 
  where "kc_space X \<equiv> \<forall>S. compactin X S \<longrightarrow> closedin X S"

lemma kc_space_expansive:
   "\<lbrakk>kc_space X; topspace Y = topspace X; \<And>U. openin X U \<Longrightarrow> openin Y U\<rbrakk>
      \<Longrightarrow> kc_space Y"
  by (meson compactin_contractive kc_space_def topology_finer_closedin)

lemma compactin_imp_closedin_gen:
   "\<lbrakk>kc_space X; compactin X S\<rbrakk> \<Longrightarrow> closedin X S"
  using kc_space_def by blast

lemma Hausdorff_imp_kc_space: "Hausdorff_space X \<Longrightarrow> kc_space X"
  by (simp add: compactin_imp_closedin kc_space_def)

lemma kc_imp_t1_space: "kc_space X \<Longrightarrow> t1_space X"
  by (simp add: finite_imp_compactin kc_space_def t1_space_closedin_finite)

lemma kc_space_subtopology:
   "kc_space X \<Longrightarrow> kc_space(subtopology X S)"
  by (metis closedin_Int_closure_of closure_of_eq compactin_subtopology inf.absorb2 kc_space_def)

lemma kc_space_discrete_topology:
   "kc_space(discrete_topology U)"
  using Hausdorff_space_discrete_topology compactin_imp_closedin kc_space_def by blast

lemma kc_space_continuous_injective_map_preimage:
  assumes "kc_space Y" "continuous_map X Y f" and injf: "inj_on f (topspace X)"
  shows "kc_space X"
  unfolding kc_space_def
proof (intro strip)
  fix S
  assume S: "compactin X S"
  have "S = {x \<in> topspace X. f x \<in> f ` S}"
    using S compactin_subset_topspace inj_onD [OF injf] by blast
  with assms S show "closedin X S"
    by (metis (no_types, lifting) Collect_cong closedin_continuous_map_preimage compactin_imp_closedin_gen image_compactin)
qed

lemma kc_space_retraction_map_image:
  assumes "retraction_map X Y r" "kc_space X"
  shows "kc_space Y"
proof -
  obtain s where s: "continuous_map X Y r" "continuous_map Y X s" "\<And>x. x \<in> topspace Y \<Longrightarrow> r (s x) = x"
    using assms by (force simp: retraction_map_def retraction_maps_def)
  then have inj: "inj_on s (topspace Y)"
    by (metis inj_on_def)
  show ?thesis
    unfolding kc_space_def
  proof (intro strip)
    fix S
    assume S: "compactin Y S"
    have "S = {x \<in> topspace Y. s x \<in> s ` S}"
      using S compactin_subset_topspace inj_onD [OF inj] by blast
    with assms S show "closedin Y S"
      by (meson compactin_imp_closedin_gen inj kc_space_continuous_injective_map_preimage s(2))
  qed
qed

lemma homeomorphic_kc_space:
   "X homeomorphic_space Y \<Longrightarrow> kc_space X \<longleftrightarrow> kc_space Y"
  by (meson homeomorphic_eq_everything_map homeomorphic_space homeomorphic_space_sym kc_space_continuous_injective_map_preimage)

lemma compact_kc_eq_maximal_compact_space:
  assumes "compact_space X"
  shows "kc_space X \<longleftrightarrow>
         (\<forall>Y. topspace Y = topspace X \<and> (\<forall>S. openin X S \<longrightarrow> openin Y S) \<and> compact_space Y \<longrightarrow> Y = X)" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (metis closedin_compact_space compactin_contractive kc_space_def topology_eq topology_finer_closedin)    
next
  assume R: ?rhs
  show ?lhs
    unfolding kc_space_def
  proof (intro strip)
    fix S
    assume S: "compactin X S"
    define Y where 
      "Y \<equiv> topology (arbitrary union_of (finite intersection_of (\<lambda>A. A = topspace X - S \<or> openin X A)
                           relative_to (topspace X)))"
    have "topspace Y = topspace X"
      by (auto simp: Y_def)
    have "openin X T \<longrightarrow> openin Y T" for T
      by (simp add: Y_def arbitrary_union_of_inc finite_intersection_of_inc openin_subbase openin_subset relative_to_subset)
    have "compact_space Y"
    proof (rule Alexander_subbase_alt)
      show "\<exists>\<F>'. finite \<F>' \<and> \<F>' \<subseteq> \<C> \<and> topspace X \<subseteq> \<Union> \<F>'" 
        if \<C>: "\<C> \<subseteq> insert (topspace X - S) (Collect (openin X))" and sub: "topspace X \<subseteq> \<Union>\<C>" for \<C>
      proof -
        consider "\<C> \<subseteq> Collect (openin X)" | \<V> where "\<C> = insert (topspace X - S) \<V>" "\<V> \<subseteq> Collect (openin X)"
          using \<C> by (metis insert_Diff subset_insert_iff)
        then show ?thesis
        proof cases
          case 1
          then show ?thesis
            by (metis assms compact_space_alt mem_Collect_eq subsetD that(2))
        next
          case 2
          then have "S \<subseteq> \<Union>\<V>"
            using S sub compactin_subset_topspace by blast
          with 2 obtain \<F> where "finite \<F> \<and> \<F> \<subseteq> \<V> \<and> S \<subseteq> \<Union>\<F>"
            using S unfolding compactin_def by (metis Ball_Collect)
          with 2 show ?thesis
            by (rule_tac x="insert (topspace X - S) \<F>" in exI) blast
        qed
      qed
    qed (auto simp: Y_def)
    have "Y = X"
      using R \<open>\<And>S. openin X S \<longrightarrow> openin Y S\<close> \<open>compact_space Y\<close> \<open>topspace Y = topspace X\<close> by blast
    moreover have "openin Y (topspace X - S)"
      by (simp add: Y_def arbitrary_union_of_inc finite_intersection_of_inc openin_subbase relative_to_subset)
    ultimately show "closedin X S"
      unfolding closedin_def using S compactin_subset_topspace by blast
  qed
qed

lemma continuous_imp_closed_map_gen:
   "\<lbrakk>compact_space X; kc_space Y; continuous_map X Y f\<rbrakk> \<Longrightarrow> closed_map X Y f"
  by (meson closed_map_def closedin_compact_space compactin_imp_closedin_gen image_compactin)

lemma kc_space_compact_subtopologies:
  "kc_space X \<longleftrightarrow> (\<forall>K. compactin X K \<longrightarrow> kc_space(subtopology X K))" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (auto simp: kc_space_def closedin_closed_subtopology compactin_subtopology)
next
  assume R: ?rhs
  show ?lhs
    unfolding kc_space_def
  proof (intro strip)
    fix K
    assume K: "compactin X K"
    then have "K \<subseteq> topspace X"
      by (simp add: compactin_subset_topspace)
    moreover have "X closure_of K \<subseteq> K"
    proof
      fix x
      assume x: "x \<in> X closure_of K"
      have "kc_space (subtopology X K)"
        by (simp add: R \<open>compactin X K\<close>)
      have "compactin X (insert x K)"
        by (metis K x compactin_Un compactin_sing in_closure_of insert_is_Un)
      then show "x \<in> K"
        by (metis R x K Int_insert_left_if1 closedin_Int_closure_of compact_imp_compactin_subtopology 
            insertCI kc_space_def subset_insertI)
    qed
    ultimately show "closedin X K"
      using closure_of_subset_eq by blast
  qed
qed

lemma kc_space_compact_prod_topology:
  assumes "compact_space X"
  shows "kc_space(prod_topology X X) \<longleftrightarrow> Hausdorff_space X" (is "?lhs=?rhs")
proof
  assume L: ?lhs
  show ?rhs
    unfolding closed_map_diag_eq [symmetric]
  proof (intro continuous_imp_closed_map_gen)
    show "continuous_map X (prod_topology X X) (\<lambda>x. (x, x))"
      by (intro continuous_intros)
  qed (use L assms in auto)
next
  assume ?rhs then show ?lhs
    by (simp add: Hausdorff_imp_kc_space Hausdorff_space_prod_topology)
qed

lemma kc_space_prod_topology:
   "kc_space(prod_topology X X) \<longleftrightarrow> (\<forall>K. compactin X K \<longrightarrow> Hausdorff_space(subtopology X K))" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (metis compactin_subspace kc_space_compact_prod_topology kc_space_subtopology subtopology_Times)
next
  assume R: ?rhs  
  have "kc_space (subtopology (prod_topology X X) L)" if "compactin (prod_topology X X) L" for L 
  proof -
    define K where "K \<equiv> fst ` L \<union> snd ` L"
    have "L \<subseteq> K \<times> K"
      by (force simp: K_def)
    have "compactin X K"
      by (metis K_def compactin_Un continuous_map_fst continuous_map_snd image_compactin that)
    then have "Hausdorff_space (subtopology X K)"
      by (simp add: R)
    then have "kc_space (prod_topology (subtopology X K) (subtopology X K))"
      by (simp add: \<open>compactin X K\<close> compact_space_subtopology kc_space_compact_prod_topology)
    then have "kc_space (subtopology (prod_topology (subtopology X K) (subtopology X K)) L)"
      using kc_space_subtopology by blast
    then show ?thesis
      using \<open>L \<subseteq> K \<times> K\<close> subtopology_Times subtopology_subtopology
      by (metis (no_types, lifting) Sigma_cong inf.absorb_iff2)
  qed
  then show ?lhs
    using kc_space_compact_subtopologies by blast
qed

lemma kc_space_prod_topology_alt:
   "kc_space(prod_topology X X) \<longleftrightarrow>
        kc_space X \<and>
        (\<forall>K. compactin X K \<longrightarrow> Hausdorff_space(subtopology X K))"
  using Hausdorff_imp_kc_space kc_space_compact_subtopologies kc_space_prod_topology by blast

lemma kc_space_prod_topology_left:
  assumes X: "kc_space X" and Y: "Hausdorff_space Y"
  shows "kc_space (prod_topology X Y)"
  unfolding kc_space_def
proof (intro strip)
  fix K
  assume K: "compactin (prod_topology X Y) K"
  then have "K \<subseteq> topspace X \<times> topspace Y"
    using compactin_subset_topspace topspace_prod_topology by blast
  moreover have "\<exists>T. openin (prod_topology X Y) T \<and> (a,b) \<in> T \<and> T \<subseteq> (topspace X \<times> topspace Y) - K"
    if ab: "(a,b) \<in> (topspace X \<times> topspace Y) - K" for a b
  proof - 
    have "compactin Y {b}"
      using that by force
    moreover 
    have "compactin Y {y \<in> topspace Y. (a,y) \<in> K}"
    proof -
      have "compactin (prod_topology X Y) (K \<inter> {a} \<times> topspace Y)"
        using that compact_Int_closedin [OF K]
        by (simp add: X closedin_prod_Times_iff compactin_imp_closedin_gen)
      moreover have "subtopology (prod_topology X Y) (K \<inter> {a} \<times> topspace Y)  homeomorphic_space 
                     subtopology Y {y \<in> topspace Y. (a, y) \<in> K}"
        unfolding homeomorphic_space_def homeomorphic_maps_def
        using that
        apply (rule_tac x="snd" in exI)
        apply (rule_tac x="Pair a" in exI)
        by (force simp: continuous_map_in_subtopology continuous_map_from_subtopology continuous_map_subtopology_snd continuous_map_paired)
      ultimately show ?thesis
        by (simp add: compactin_subspace homeomorphic_compact_space) 
    qed
    moreover have "disjnt {b} {y \<in> topspace Y. (a,y) \<in> K}"
      using ab by force
    ultimately obtain V U where VU: "openin Y V" "openin Y U" "{b} \<subseteq> V" "{y \<in> topspace Y. (a,y) \<in> K} \<subseteq> U" "disjnt V U"
      using Hausdorff_space_compact_separation [OF Y] by blast
    define V' where "V' \<equiv> topspace Y - U"
    have W: "closedin Y V'" "{y \<in> topspace Y. (a,y) \<in> K} \<subseteq> topspace Y - V'" "disjnt V (topspace Y - V')"
      using VU by (auto simp: V'_def disjnt_iff)
    with VU obtain "V \<subseteq> topspace Y" "V' \<subseteq> topspace Y"
      by (meson closedin_subset openin_closedin_eq)
    then obtain "b \<in> V" "disjnt {y \<in> topspace Y. (a,y) \<in> K} V'" "V \<subseteq> V'"
      using VU unfolding disjnt_iff V'_def by force
    define C where "C \<equiv> image fst (K \<inter> {z \<in> topspace(prod_topology X Y). snd z \<in> V'})"
    have "closedin (prod_topology X Y) {z \<in> topspace (prod_topology X Y). snd z \<in> V'}"
        using closedin_continuous_map_preimage \<open>closedin Y V'\<close> continuous_map_snd by blast
    then have "compactin X C"
      unfolding C_def by (meson K compact_Int_closedin continuous_map_fst image_compactin)
    then have "closedin X C"
      using assms by (auto simp: kc_space_def)
    show ?thesis
      apply (rule_tac x="(topspace X - C) \<times> V" in exI)
      using VU
      apply (auto simp:  )
          apply (metis VU(1) \<open>closedin X C\<close> closedin_def openin_prod_Times_iff)
      using that apply blast
        apply (auto simp: C_def image_iff Ball_def)
      using V'_def VU(4) apply auto[1]
       apply (simp add: \<open>b \<in> V\<close>)
      using \<open>V \<subseteq> topspace Y\<close> apply blast
      using \<open>V \<subseteq> V'\<close> \<open>V \<subseteq> topspace Y\<close> by blast
  qed
  ultimately show "closedin (prod_topology X Y) K"
    by (metis surj_pair closedin_def openin_subopen topspace_prod_topology)
qed

lemma kc_space_prod_topology_right:
   "\<lbrakk>Hausdorff_space X; kc_space Y\<rbrakk> \<Longrightarrow> kc_space (prod_topology X Y)"
  using kc_space_prod_topology_left homeomorphic_kc_space homeomorphic_space_prod_topology_swap by blast


subsection \<open>Regular spaces\<close>

text \<open>Regular spaces. These are *not* a priori assumed to be Hausdorff/T_1\<close>


definition regular_space 
  where "regular_space X \<equiv>
        \<forall>C a. closedin X C \<and> a \<in> topspace X - C
                \<longrightarrow> (\<exists>U V. openin X U \<and> openin X V \<and> a \<in> U \<and> C \<subseteq> V \<and> disjnt U V)"

lemma homeomorphic_regular_space_aux:
  assumes hom: "X homeomorphic_space Y" and X: "regular_space X"
  shows "regular_space Y"
proof -
  obtain f g where hmf: "homeomorphic_map X Y f" and hmg: "homeomorphic_map Y X g"
    and fg: "(\<forall>x \<in> topspace X. g(f x) = x) \<and> (\<forall>y \<in> topspace Y. f(g y) = y)"
    using assms X homeomorphic_maps_map homeomorphic_space_def by fastforce
  show ?thesis
    unfolding regular_space_def
  proof clarify
    fix C a
    assume Y: "closedin Y C" "a \<in> topspace Y" and "a \<notin> C"
    then obtain "closedin X (g ` C)" "g a \<in> topspace X" "g a \<notin> g ` C"
      using \<open>closedin Y C\<close> hmg homeomorphic_map_closedness_eq
      by (smt (verit, ccfv_SIG) fg homeomorphic_imp_surjective_map image_iff in_mono) 
    then obtain S T where ST: "openin X S" "openin X T" "g a \<in> S" "g`C \<subseteq> T" "disjnt S T"
      using X unfolding regular_space_def by (metis DiffI)
    then have "openin Y (f`S)" "openin Y (f`T)"
      by (meson hmf homeomorphic_map_openness_eq)+
    moreover have "a \<in> f`S \<and> C \<subseteq> f`T"
      using ST by (smt (verit, best) Y closedin_subset fg image_eqI subset_iff)   
    moreover have "disjnt (f`S) (f`T)"
      using ST by (smt (verit, ccfv_SIG) disjnt_iff fg image_iff openin_subset subsetD)
    ultimately show "\<exists>U V. openin Y U \<and> openin Y V \<and> a \<in> U \<and> C \<subseteq> V \<and> disjnt U V"
      by metis
  qed
qed

lemma homeomorphic_regular_space:
   "X homeomorphic_space Y
        \<Longrightarrow> (regular_space X \<longleftrightarrow> regular_space Y)"
  by (meson homeomorphic_regular_space_aux homeomorphic_space_sym)

lemma regular_space:
   "regular_space X \<longleftrightarrow>
        (\<forall>C a. closedin X C \<and> a \<in> topspace X - C
              \<longrightarrow> (\<exists>U. openin X U \<and> a \<in> U \<and> disjnt C (X closure_of U)))"
  unfolding regular_space_def
proof (intro all_cong1 imp_cong refl ex_cong1)
  fix C a U
  assume C: "closedin X C \<and> a \<in> topspace X - C"
  show "(\<exists>V. openin X U \<and> openin X V \<and> a \<in> U \<and> C \<subseteq> V \<and> disjnt U V)  
    \<longleftrightarrow> (openin X U \<and> a \<in> U \<and> disjnt C (X closure_of U))" (is "?lhs=?rhs")
  proof
    assume ?lhs
    then show ?rhs
      by (smt (verit, best) disjnt_iff in_closure_of subsetD)
  next
    assume R: ?rhs
    then have "disjnt U (topspace X - X closure_of U)"
      by (meson DiffD2 closure_of_subset disjnt_iff openin_subset subsetD)
    moreover have "C \<subseteq> topspace X - X closure_of U"
      by (meson C DiffI R closedin_subset disjnt_iff subset_eq)
    ultimately show ?lhs
      using R by (rule_tac x="topspace X - X closure_of U" in exI) auto
    qed
qed

lemma neighbourhood_base_of_closedin:
  "neighbourhood_base_of (closedin X) X \<longleftrightarrow> regular_space X" (is "?lhs=?rhs")
proof -
  have "?lhs \<longleftrightarrow> (\<forall>W x. openin X W \<and> x \<in> W \<longrightarrow>
                  (\<exists>U. openin X U \<and> (\<exists>V. closedin X V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W)))"
    by (simp add: neighbourhood_base_of)
  also have "\<dots> \<longleftrightarrow> (\<forall>W x. closedin X W \<and> x \<in> topspace X - W \<longrightarrow>
                     (\<exists>U. openin X U \<and> (\<exists>V. closedin X V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> topspace X - W)))"
    by (smt (verit) Diff_Diff_Int closedin_def inf.absorb_iff2 openin_closedin_eq)
  also have "\<dots> \<longleftrightarrow> ?rhs"
  proof -
    have \<section>: "(\<exists>V. closedin X V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> topspace X - W) 
         \<longleftrightarrow> (\<exists>V. openin X V \<and> x \<in> U \<and> W \<subseteq> V \<and> disjnt U V)" (is "?lhs=?rhs")
      if "openin X U"  "closedin X W" "x \<in> topspace X" "x \<notin> W" for W U x
    proof
      assume ?lhs with \<open>closedin X W\<close> show ?rhs
        unfolding closedin_def by (smt (verit) Diff_mono disjnt_Diff1 double_diff subset_eq)
    next
      assume ?rhs with \<open>openin X U\<close> show ?lhs
        unfolding openin_closedin_eq disjnt_def
        by (smt (verit) Diff_Diff_Int Diff_disjoint Diff_eq_empty_iff Int_Diff inf.orderE)
    qed
    show ?thesis
      unfolding regular_space_def
      by (intro all_cong1 ex_cong1 imp_cong refl) (metis \<section> DiffE)
  qed
  finally show ?thesis .
qed

lemma regular_space_discrete_topology:
   "regular_space (discrete_topology S)"
  using neighbourhood_base_of_closedin neighbourhood_base_of_discrete_topology by fastforce

lemma regular_space_subtopology:
 "regular_space X \<Longrightarrow> regular_space (subtopology X S)"
  unfolding regular_space_def openin_subtopology_alt closedin_subtopology_alt disjnt_iff
  by clarsimp (smt (verit, best) inf.orderE inf_le1 le_inf_iff)


lemma regular_space_retraction_map_image:
   "\<lbrakk>retraction_map X Y r; regular_space X\<rbrakk> \<Longrightarrow> regular_space Y"
  using hereditary_imp_retractive_property homeomorphic_regular_space regular_space_subtopology by blast

lemma regular_t0_imp_Hausdorff_space:
   "\<lbrakk>regular_space X; t0_space X\<rbrakk> \<Longrightarrow> Hausdorff_space X"
  apply (clarsimp simp add: regular_space_def t0_space Hausdorff_space_def)
  by (metis disjnt_sym subsetD)

lemma regular_t0_eq_Hausdorff_space:
   "regular_space X \<Longrightarrow> (t0_space X \<longleftrightarrow> Hausdorff_space X)"
  using Hausdorff_imp_t0_space regular_t0_imp_Hausdorff_space by blast

lemma regular_t1_imp_Hausdorff_space:
   "\<lbrakk>regular_space X; t1_space X\<rbrakk> \<Longrightarrow> Hausdorff_space X"
  by (simp add: regular_t0_imp_Hausdorff_space t1_imp_t0_space)

lemma regular_t1_eq_Hausdorff_space:
   "regular_space X \<Longrightarrow> t1_space X \<longleftrightarrow> Hausdorff_space X"
  using regular_t0_imp_Hausdorff_space t1_imp_t0_space t1_or_Hausdorff_space by blast

lemma compact_Hausdorff_imp_regular_space:
  assumes "compact_space X" "Hausdorff_space X"
  shows "regular_space X"
  unfolding regular_space_def
proof clarify
  fix S a
  assume "closedin X S" and "a \<in> topspace X" and "a \<notin> S"
  then show "\<exists>U V. openin X U \<and> openin X V \<and> a \<in> U \<and> S \<subseteq> V \<and> disjnt U V"
    using assms unfolding Hausdorff_space_compact_sets
    by (metis closedin_compact_space compactin_sing disjnt_empty1 insert_subset disjnt_insert1)
qed

lemma regular_space_topspace_empty: "topspace X = {} \<Longrightarrow> regular_space X"
  by (simp add: Hausdorff_space_topspace_empty compact_Hausdorff_imp_regular_space compact_space_topspace_empty)

lemma neighbourhood_base_of_closed_Hausdorff_space:
   "regular_space X \<and> Hausdorff_space X \<longleftrightarrow>
    neighbourhood_base_of (\<lambda>C. closedin X C \<and> Hausdorff_space(subtopology X C)) X" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (simp add: Hausdorff_space_subtopology neighbourhood_base_of_closedin)
next
  assume ?rhs then show ?lhs
  by (metis (mono_tags, lifting) Hausdorff_space_closed_neighbourhood neighbourhood_base_of neighbourhood_base_of_closedin openin_topspace)
qed

lemma locally_compact_imp_kc_eq_Hausdorff_space:
   "neighbourhood_base_of (compactin X) X \<Longrightarrow> kc_space X \<longleftrightarrow> Hausdorff_space X"
  by (metis Hausdorff_imp_kc_space kc_imp_t1_space kc_space_def neighbourhood_base_of_closedin neighbourhood_base_of_mono regular_t1_imp_Hausdorff_space)

lemma (in Metric_space) regular_space_mtopology:
   "regular_space mtopology"
unfolding regular_space_def
proof clarify
  fix C a
  assume C: "closedin mtopology C" and a: "a \<in> topspace mtopology" and "a \<notin> C"
  have "openin mtopology (topspace mtopology - C)"
    by (simp add: C openin_diff)
  then obtain r where "r>0" and r: "mball a r \<subseteq> topspace mtopology - C"
    unfolding openin_mtopology using \<open>a \<notin> C\<close> a by auto
  show "\<exists>U V. openin mtopology U \<and> openin mtopology V \<and> a \<in> U \<and> C \<subseteq> V \<and> disjnt U V"
  proof (intro exI conjI)
    show "a \<in> mball a (r/2)"
      using \<open>0 < r\<close> a by force
    show "C \<subseteq> topspace mtopology - mcball a (r/2)"
      using C \<open>0 < r\<close> r by (fastforce simp: closedin_metric)
  qed (auto simp: openin_mball closedin_mcball openin_diff disjnt_iff)
qed

lemma metrizable_imp_regular_space:
   "metrizable_space X \<Longrightarrow> regular_space X"
  by (metis Metric_space.regular_space_mtopology metrizable_space_def)

lemma regular_space_compact_closed_separation:
  assumes X: "regular_space X"
      and S: "compactin X S"
      and T: "closedin X T"
      and "disjnt S T"
    shows "\<exists>U V. openin X U \<and> openin X V \<and> S \<subseteq> U \<and> T \<subseteq> V \<and> disjnt U V"
proof (cases "S={}")
  case True
  then show ?thesis
    by (meson T closedin_def disjnt_empty1 empty_subsetI openin_empty openin_topspace)
next
  case False
  then have "\<exists>U V. x \<in> S \<longrightarrow> openin X U \<and> openin X V \<and> x \<in> U \<and> T \<subseteq> V \<and> disjnt U V" for x
    using assms unfolding regular_space_def
    by (smt (verit) Diff_iff compactin_subset_topspace disjnt_iff subsetD)
  then obtain U V where UV: "\<And>x. x \<in> S \<Longrightarrow> openin X (U x) \<and> openin X (V x) \<and> x \<in> (U x) \<and> T \<subseteq> (V x) \<and> disjnt (U x) (V x)" 
    by metis
  then obtain \<F> where "finite \<F>" "\<F> \<subseteq> U ` S" "S \<subseteq> \<Union> \<F>"
    using S unfolding compactin_def by (smt (verit) UN_iff image_iff subsetI)
  then obtain K where "finite K" "K \<subseteq> S" and K: "S \<subseteq> \<Union>(U ` K)"
    by (metis finite_subset_image)
  show ?thesis 
  proof (intro exI conjI)
    show "openin X (\<Union>(U ` K))"
      using \<open>K \<subseteq> S\<close> UV by blast
    show "openin X (\<Inter>(V ` K))"
      using False K UV \<open>K \<subseteq> S\<close> \<open>finite K\<close> by blast
    show "S \<subseteq> \<Union>(U ` K)"
      by (simp add: K)
    show "T \<subseteq> \<Inter>(V ` K)"
      using UV \<open>K \<subseteq> S\<close> by blast
    show "disjnt (\<Union>(U ` K)) (\<Inter>(V ` K))"
      by (smt (verit) Inter_iff UN_E UV \<open>K \<subseteq> S\<close> disjnt_iff image_eqI subset_iff)
  qed
qed

lemma regular_space_compact_closed_sets:
   "regular_space X \<longleftrightarrow>
        (\<forall>S T. compactin X S \<and> closedin X T \<and> disjnt S T
           \<longrightarrow> (\<exists>U V. openin X U \<and> openin X V \<and> S \<subseteq> U \<and> T \<subseteq> V \<and> disjnt U V))" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    using regular_space_compact_closed_separation by fastforce
next
  assume R: ?rhs
  show ?lhs
    unfolding regular_space
  proof clarify
    fix S x
    assume "closedin X S" and "x \<in> topspace X" and "x \<notin> S"
    then obtain U V where "openin X U \<and> openin X V \<and> {x} \<subseteq> U \<and> S \<subseteq> V \<and> disjnt U V"
      by (metis R compactin_sing disjnt_empty1 disjnt_insert1)
    then show "\<exists>U. openin X U \<and> x \<in> U \<and> disjnt S (X closure_of U)"
      by (smt (verit, best) disjnt_iff in_closure_of insert_subset subsetD)
  qed
qed


lemma regular_space_prod_topology:
   "regular_space (prod_topology X Y) \<longleftrightarrow>
        topspace X = {} \<or> topspace Y = {} \<or> regular_space X \<and> regular_space Y" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (metis regular_space_retraction_map_image retraction_map_fst retraction_map_snd)
next
  assume R: ?rhs  
  show ?lhs
  proof (cases "topspace X = {} \<or> topspace Y = {}")
    case True
    then show ?thesis
      by (simp add: regular_space_topspace_empty)
  next
    case False
    then have "regular_space X" "regular_space Y"
      using R by auto
    show ?thesis
      unfolding neighbourhood_base_of_closedin [symmetric] neighbourhood_base_of
    proof clarify
      fix W x y
      assume W: "openin (prod_topology X Y) W" and "(x,y) \<in> W"
      then obtain U V where U: "openin X U" "x \<in> U" and V: "openin Y V" "y \<in> V" 
        and "U \<times> V \<subseteq> W"
        by (metis openin_prod_topology_alt)
      obtain D1 C1 where 1: "openin X D1" "closedin X C1" "x \<in> D1" "D1 \<subseteq> C1" "C1 \<subseteq> U"
        by (metis \<open>regular_space X\<close> U neighbourhood_base_of neighbourhood_base_of_closedin)
      obtain D2 C2 where 2: "openin Y D2" "closedin Y C2" "y \<in> D2" "D2 \<subseteq> C2" "C2 \<subseteq> V"
        by (metis \<open>regular_space Y\<close> V neighbourhood_base_of neighbourhood_base_of_closedin)
      show "\<exists>U V. openin (prod_topology X Y) U \<and> closedin (prod_topology X Y) V \<and>
                  (x,y) \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W"
      proof (intro conjI exI)
        show "openin (prod_topology X Y) (D1 \<times> D2)"
          by (simp add: 1 2 openin_prod_Times_iff)
        show "closedin (prod_topology X Y) (C1 \<times> C2)"
          by (simp add: 1 2 closedin_prod_Times_iff)
      qed (use 1 2 \<open>U \<times> V \<subseteq> W\<close> in auto)
    qed
  qed
qed

lemma regular_space_product_topology:
   "regular_space (product_topology X I) \<longleftrightarrow>
    topspace (product_topology X I) = {} \<or> (\<forall>i \<in> I. regular_space (X i))" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    by (meson regular_space_retraction_map_image retraction_map_product_projection)
next
  assume R: ?rhs  
  show ?lhs
  proof (cases "topspace(product_topology X I) = {}")
    case True
    then show ?thesis
      by (simp add: regular_space_topspace_empty)
  next
    case False
    then obtain x where x: "x \<in> topspace (product_topology X I)"
      by blast
    define \<F> where "\<F> \<equiv> {Pi\<^sub>E I U |U. finite {i \<in> I. U i \<noteq> topspace (X i)}
                        \<and> (\<forall>i\<in>I. openin (X i) (U i))}"
    have oo: "openin (product_topology X I) = arbitrary union_of (\<lambda>W. W \<in> \<F>)"
      by (simp add: \<F>_def openin_product_topology product_topology_base_alt)
    have "\<exists>U V. openin (product_topology X I) U \<and> closedin (product_topology X I) V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> Pi\<^sub>E I W"
      if fin: "finite {i \<in> I. W i \<noteq> topspace (X i)}" 
        and opeW: "\<And>k. k \<in> I \<Longrightarrow> openin (X k) (W k)" and x: "x \<in> PiE I W" for W x
    proof -
      have "\<And>i. i \<in> I \<Longrightarrow> \<exists>U V. openin (X i) U \<and> closedin (X i) V \<and> x i \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W i"
        by (metis False PiE_iff R neighbourhood_base_of neighbourhood_base_of_closedin opeW x)
      then obtain U C where UC: 
        "\<And>i. i \<in> I \<Longrightarrow> openin (X i) (U i) \<and> closedin (X i) (C i) \<and> x i \<in> U i \<and> U i \<subseteq> C i \<and> C i \<subseteq> W i"
        by metis
      define PI where "PI \<equiv> \<lambda>V. PiE I (\<lambda>i. if W i = topspace(X i) then topspace(X i) else V i)"
      show ?thesis
      proof (intro conjI exI)
        have "\<forall>i\<in>I. W i \<noteq> topspace (X i) \<longrightarrow> openin (X i) (U i)"
          using UC by force
        with fin show "openin (product_topology X I) (PI U)"
          by (simp add: Collect_mono_iff PI_def openin_PiE_gen rev_finite_subset)
        show "closedin (product_topology X I) (PI C)"
          by (simp add: UC closedin_product_topology PI_def)
        show "x \<in> PI U"
          using UC x by (fastforce simp: PI_def)
        show "PI U \<subseteq> PI C"
          by (smt (verit) UC Orderings.order_eq_iff PiE_mono PI_def)
        show "PI C \<subseteq> Pi\<^sub>E I W"
          by (simp add: UC PI_def subset_PiE)
      qed
    qed
    then have "neighbourhood_base_of (closedin (product_topology X I)) (product_topology X I)"
      unfolding neighbourhood_base_of_topology_base [OF oo] by (force simp: \<F>_def)
    then show ?thesis
      by (simp add: neighbourhood_base_of_closedin)
  qed
qed

lemma closed_map_paired_gen_aux:
  assumes "regular_space Y" and f: "closed_map Z X f" and g: "closed_map Z Y g"
    and clo: "\<And>y. y \<in> topspace X \<Longrightarrow> closedin Z {x \<in> topspace Z. f x = y}"
    and contg: "continuous_map Z Y g"
  shows "closed_map Z (prod_topology X Y) (\<lambda>x. (f x, g x))"
  unfolding closed_map_def
proof (intro strip)
  fix C assume "closedin Z C"
  then have "C \<subseteq> topspace Z"
    by (simp add: closedin_subset)
  have "f ` topspace Z \<subseteq> topspace X" "g ` topspace Z \<subseteq> topspace Y"
    by (simp_all add: assms closed_map_imp_subset_topspace)
  show "closedin (prod_topology X Y) ((\<lambda>x. (f x, g x)) ` C)"
    unfolding closedin_def topspace_prod_topology
  proof (intro conjI)
    have "closedin Y (g ` C)"
      using \<open>closedin Z C\<close> assms(3) closed_map_def by blast
    with assms show "(\<lambda>x. (f x, g x)) ` C \<subseteq> topspace X \<times> topspace Y"
      using \<open>C \<subseteq> topspace Z\<close> \<open>f ` topspace Z \<subseteq> topspace X\<close> continuous_map_closedin subsetD by fastforce
    have *: "\<exists>T. openin (prod_topology X Y) T \<and> (y1,y2) \<in> T \<and> T \<subseteq> topspace X \<times> topspace Y - (\<lambda>x. (f x, g x)) ` C"
      if "(y1,y2) \<notin> (\<lambda>x. (f x, g x)) ` C" and y1: "y1 \<in> topspace X" and y2: "y2 \<in> topspace Y"
      for y1 y2
    proof -
      define A where "A \<equiv> topspace Z - (C \<inter> {x \<in> topspace Z. f x = y1})"
      have A: "openin Z A" "{x \<in> topspace Z. g x = y2} \<subseteq> A"
        using that \<open>closedin Z C\<close> clo that(2) by (auto simp: A_def)
      obtain V0 where "openin Y V0 \<and> y2 \<in> V0" and UA: "{x \<in> topspace Z. g x \<in> V0} \<subseteq> A"
        using g A y2 unfolding closed_map_fibre_neighbourhood by blast
      then obtain V V' where VV: "openin Y V \<and> closedin Y V' \<and> y2 \<in> V \<and> V \<subseteq> V'" and "V' \<subseteq> V0"
        by (metis (no_types, lifting) \<open>regular_space Y\<close> neighbourhood_base_of neighbourhood_base_of_closedin)
      with UA have subA: "{x \<in> topspace Z. g x \<in> V'} \<subseteq> A"
        by blast
      show ?thesis
      proof -
        define B where "B \<equiv> topspace Z - (C \<inter> {x \<in> topspace Z. g x \<in> V'})"
        have "openin Z B"
          using VV \<open>closedin Z C\<close> contg by (fastforce simp: B_def continuous_map_closedin)
        have "{x \<in> topspace Z. f x = y1} \<subseteq> B"
          using A_def subA by (auto simp: A_def B_def)
        then obtain U where "openin X U" "y1 \<in> U" and subB: "{x \<in> topspace Z. f x \<in> U} \<subseteq> B"
          using \<open>openin Z B\<close> y1 f unfolding closed_map_fibre_neighbourhood by meson
        show ?thesis
        proof (intro conjI exI)
          show "openin (prod_topology X Y) (U \<times> V)"
            by (metis VV \<open>openin X U\<close> openin_prod_Times_iff)
          show "(y1, y2) \<in> U \<times> V"
            by (simp add: VV \<open>y1 \<in> U\<close>)
          show "U \<times> V \<subseteq> topspace X \<times> topspace Y - (\<lambda>x. (f x, g x)) ` C"
            using VV \<open>C \<subseteq> topspace Z\<close> \<open>openin X U\<close> subB
            by (force simp: image_iff B_def subset_iff dest: openin_subset)
        qed
      qed
    qed
    then show "openin (prod_topology X Y) (topspace X \<times> topspace Y - (\<lambda>x. (f x, g x)) ` C)"
      by (smt (verit, ccfv_threshold) Diff_iff SigmaE openin_subopen)
  qed
qed


lemma closed_map_paired_gen:
  assumes f: "closed_map Z X f" and g: "closed_map Z Y g"
  and D: "(regular_space X \<and> continuous_map Z X f \<and> (\<forall>z \<in> topspace Y. closedin Z {x \<in> topspace Z. g x = z})
         \<or> regular_space Y \<and> continuous_map Z Y g \<and> (\<forall>y \<in> topspace X. closedin Z {x \<in> topspace Z. f x = y}))"
         (is "?RSX \<or> ?RSY")
       shows "closed_map Z (prod_topology X Y) (\<lambda>x. (f x, g x))"
  using D
proof
  assume RSX: ?RSX
  have eq: "(\<lambda>x. (f x, g x)) = (\<lambda>(x,y). (y,x)) \<circ> (\<lambda>x. (g x, f x))"
    by auto
  show ?thesis
    unfolding eq
  proof (rule closed_map_compose)
    show "closed_map Z (prod_topology Y X) (\<lambda>x. (g x, f x))"
      using RSX closed_map_paired_gen_aux f g by fastforce
    show "closed_map (prod_topology Y X) (prod_topology X Y) (\<lambda>(x, y). (y, x))"
      using homeomorphic_imp_closed_map homeomorphic_map_swap by blast
  qed
qed (blast intro: assms closed_map_paired_gen_aux)

lemma closed_map_paired:
  assumes "closed_map Z X f" and contf: "continuous_map Z X f"
          "closed_map Z Y g" and contg: "continuous_map Z Y g"
  and D: "t1_space X \<and> regular_space Y \<or> regular_space X \<and> t1_space Y"
  shows "closed_map Z (prod_topology X Y) (\<lambda>x. (f x, g x))"
proof (rule closed_map_paired_gen)
  show "regular_space X \<and> continuous_map Z X f \<and> (\<forall>z\<in>topspace Y. closedin Z {x \<in> topspace Z. g x = z}) \<or> regular_space Y \<and> continuous_map Z Y g \<and> (\<forall>y\<in>topspace X. closedin Z {x \<in> topspace Z. f x = y})"
    using D contf contg
    by (smt (verit, del_insts) Collect_cong closedin_continuous_map_preimage t1_space_closedin_singleton singleton_iff)
qed (use assms in auto)

lemma closed_map_pairwise:
  assumes  "closed_map Z X (fst \<circ> f)" "continuous_map Z X (fst \<circ> f)"
    "closed_map Z Y (snd \<circ> f)" "continuous_map Z Y (snd \<circ> f)"
    "t1_space X \<and> regular_space Y \<or> regular_space X \<and> t1_space Y"
  shows "closed_map Z (prod_topology X Y) f"
proof -
  have "closed_map Z (prod_topology X Y) (\<lambda>a. ((fst \<circ> f) a, (snd \<circ> f) a))"
    using assms closed_map_paired by blast
  then show ?thesis
    by auto
qed


lemma tube_lemma_right:
  assumes W: "openin (prod_topology X Y) W" and C: "compactin Y C" 
    and x: "x \<in> topspace X" and subW: "{x} \<times> C \<subseteq> W"
  shows "\<exists>U V. openin X U \<and> openin Y V \<and> x \<in> U \<and> C \<subseteq> V \<and> U \<times> V \<subseteq> W"
proof (cases "C = {}")
  case True
  with x show ?thesis by auto
next
  case False
  have "\<exists>U V. openin X U \<and> openin Y V \<and> x \<in> U \<and> y \<in> V \<and> U \<times> V \<subseteq> W" 
    if "y \<in> C" for y
    using W openin_prod_topology_alt subW subsetD that by fastforce
  then obtain U V where UV: "\<And>y. y \<in> C \<Longrightarrow> openin X (U y) \<and> openin Y (V y) \<and> x \<in> U y \<and> y \<in> V y \<and> U y \<times> V y \<subseteq> W" 
    by metis
  then obtain D where D: "finite D" "D \<subseteq> C" "C \<subseteq> \<Union> (V ` D)"
    using compactinD [OF C, of "V`C"]
    by (smt (verit) UN_I finite_subset_image imageE subsetI)
  show ?thesis
  proof (intro exI conjI)
    show "openin X (\<Inter> (U ` D))" "openin Y (\<Union> (V ` D))"
      using D False UV by blast+
    show "x \<in> \<Inter> (U ` D)" "C \<subseteq> \<Union> (V ` D)" "\<Inter> (U ` D) \<times> \<Union> (V ` D) \<subseteq> W"
      using D UV by force+
  qed
qed


lemma closed_map_fst:
  assumes "compact_space Y"
  shows "closed_map (prod_topology X Y) X fst"
proof -
  have *: "{x \<in> topspace X \<times> topspace Y. fst x \<in> U} = U \<times> topspace Y"
    if "U \<subseteq> topspace X" for U
    using that by force
  have **: "\<And>U y. \<lbrakk>openin (prod_topology X Y) U; y \<in> topspace X;
            {x \<in> topspace X \<times> topspace Y. fst x = y} \<subseteq> U\<rbrakk>
           \<Longrightarrow> \<exists>V. openin X V \<and> y \<in> V \<and> V \<times> topspace Y \<subseteq> U"
    using tube_lemma_right[of X Y _ "topspace Y"] assms compact_space_def
    by (force simp add: )
  show ?thesis
    unfolding closed_map_fibre_neighbourhood
    by (force simp add: * openin_subset cong: conj_cong intro: **)
qed

lemma closed_map_snd:
  assumes "compact_space X"
  shows "closed_map (prod_topology X Y) Y snd"
proof -
  have "snd = fst o prod.swap"
    by force
  moreover have "closed_map (prod_topology X Y) Y (fst o prod.swap)"
  proof (rule closed_map_compose)
    show "closed_map (prod_topology X Y) (prod_topology Y X) prod.swap"
      by (metis (no_types, lifting) homeomorphic_imp_closed_map homeomorphic_map_eq homeomorphic_map_swap prod.swap_def split_beta)
    show "closed_map (prod_topology Y X) Y fst"
      by (simp add: Abstract_Metric_Spaces.closed_map_fst assms)
  qed
  ultimately show ?thesis
    by metis
qed

lemma closed_map_paired_closed_map_right:
   "\<lbrakk>closed_map X Y f; regular_space X;
     \<And>y. y \<in> topspace Y \<Longrightarrow> closedin X {x \<in> topspace X. f x = y}\<rbrakk>
    \<Longrightarrow> closed_map X (prod_topology X Y) (\<lambda>x. (x, f x))"
  by (rule closed_map_paired_gen [OF closed_map_id, unfolded id_def]) auto

lemma closed_map_paired_closed_map_left:
  assumes "closed_map X Y f"  "regular_space X"
    "\<And>y. y \<in> topspace Y \<Longrightarrow> closedin X {x \<in> topspace X. f x = y}"
  shows "closed_map X (prod_topology Y X) (\<lambda>x. (f x, x))"
proof -
  have eq: "(\<lambda>x. (f x, x)) = (\<lambda>(x,y). (y,x)) \<circ> (\<lambda>x. (x, f x))"
    by auto
  show ?thesis
    unfolding eq
  proof (rule closed_map_compose)
    show "closed_map X (prod_topology X Y) (\<lambda>x. (x, f x))"
      by (simp add: assms closed_map_paired_closed_map_right)
    show "closed_map (prod_topology X Y) (prod_topology Y X) (\<lambda>(x, y). (y, x))"
      using homeomorphic_imp_closed_map homeomorphic_map_swap by blast
  qed
qed

lemma closed_map_imp_closed_graph:
  assumes "closed_map X Y f" "regular_space X"
          "\<And>y. y \<in> topspace Y \<Longrightarrow> closedin X {x \<in> topspace X. f x = y}"
  shows "closedin (prod_topology X Y) ((\<lambda>x. (x, f x)) ` topspace X)"
  using assms closed_map_def closed_map_paired_closed_map_right by blast

lemma proper_map_paired_closed_map_right:
  assumes "closed_map X Y f" "regular_space X"
    "\<And>y. y \<in> topspace Y \<Longrightarrow> closedin X {x \<in> topspace X. f x = y}"
  shows "proper_map X (prod_topology X Y) (\<lambda>x. (x, f x))"
  by (simp add: assms closed_injective_imp_proper_map inj_on_def closed_map_paired_closed_map_right)

lemma proper_map_paired_closed_map_left:
  assumes "closed_map X Y f" "regular_space X"
    "\<And>y. y \<in> topspace Y \<Longrightarrow> closedin X {x \<in> topspace X. f x = y}"
  shows "proper_map X (prod_topology Y X) (\<lambda>x. (f x, x))"
  by (simp add: assms closed_injective_imp_proper_map inj_on_def closed_map_paired_closed_map_left)

lemma regular_space_continuous_proper_map_image:
  assumes "regular_space X" and contf: "continuous_map X Y f" and pmapf: "proper_map X Y f"
    and fim: "f ` (topspace X) = topspace Y"
  shows "regular_space Y"
  unfolding regular_space_def
proof clarify
  fix C y
  assume "closedin Y C" and "y \<in> topspace Y" and "y \<notin> C"
  have "closed_map X Y f" "(\<forall>y \<in> topspace Y. compactin X {x \<in> topspace X. f x = y})"
    using pmapf proper_map_def by force+
  moreover have "closedin X {z \<in> topspace X. f z \<in> C}"
    using \<open>closedin Y C\<close> contf continuous_map_closedin by fastforce
  moreover have "disjnt {z \<in> topspace X. f z = y} {z \<in> topspace X. f z \<in> C}"
    using \<open>y \<notin> C\<close> disjnt_iff by blast
  ultimately
  obtain U V where UV: "openin X U" "openin X V" "{z \<in> topspace X. f z = y} \<subseteq> U" "{z \<in> topspace X. f z \<in> C} \<subseteq> V"
                  and dUV: "disjnt U V"
    using \<open>y \<in> topspace Y\<close> \<open>regular_space X\<close> unfolding regular_space_compact_closed_sets
    by meson

  have *: "\<And>U T. openin X U \<and> T \<subseteq> topspace Y \<and> {x \<in> topspace X. f x \<in> T} \<subseteq> U \<longrightarrow>
         (\<exists>V. openin Y V \<and> T \<subseteq> V \<and> {x \<in> topspace X. f x \<in> V} \<subseteq> U)"
   using \<open>closed_map X Y f\<close> unfolding closed_map_preimage_neighbourhood by blast
  obtain V1 where V1: "openin Y V1 \<and> y \<in> V1" and sub1: "{x \<in> topspace X. f x \<in> V1} \<subseteq> U"
    using * [of U "{y}"] UV \<open>y \<in> topspace Y\<close> by auto
  moreover
  obtain V2 where "openin Y V2 \<and> C \<subseteq> V2" and sub2: "{x \<in> topspace X. f x \<in> V2} \<subseteq> V"
    by (smt (verit, ccfv_SIG) * UV \<open>closedin Y C\<close> closedin_subset mem_Collect_eq subset_iff)
  moreover have "disjnt V1 V2"
  proof -
    have "\<And>x. \<lbrakk>\<forall>x. x \<in> U \<longrightarrow> x \<notin> V; x \<in> V1; x \<in> V2\<rbrakk> \<Longrightarrow> False"
      by (smt (verit) V1 fim image_iff mem_Collect_eq openin_subset sub1 sub2 subsetD)
    with dUV show ?thesis by (auto simp: disjnt_iff)
  qed
  ultimately show "\<exists>U V. openin Y U \<and> openin Y V \<and> y \<in> U \<and> C \<subseteq> V \<and> disjnt U V"
    by meson
qed

lemma regular_space_perfect_map_image:
   "\<lbrakk>regular_space X; perfect_map X Y f\<rbrakk> \<Longrightarrow> regular_space Y"
  by (meson perfect_map_def regular_space_continuous_proper_map_image)

lemma regular_space_perfect_map_image_eq:
  assumes "Hausdorff_space X" and perf: "perfect_map X Y f"
  shows "regular_space X \<longleftrightarrow> regular_space Y" (is "?lhs=?rhs")
proof
  assume ?lhs
  then show ?rhs
    using perf regular_space_perfect_map_image by blast
next
  assume R: ?rhs  
  have "continuous_map X Y f" "proper_map X Y f" and fim: "f ` (topspace X) = topspace Y"
    using perf by (auto simp: perfect_map_def)
  then have "closed_map X Y f" and preYf: "(\<forall>y \<in> topspace Y. compactin X {x \<in> topspace X. f x = y})"
    by (simp_all add: proper_map_def)
  show ?lhs
    unfolding regular_space_def
  proof clarify
    fix C x
    assume "closedin X C" and "x \<in> topspace X" and "x \<notin> C"
    obtain U1 U2 where "openin X U1" "openin X U2" "{x} \<subseteq> U1" and "disjnt U1 U2"
      and subV: "C \<inter> {z \<in> topspace X. f z = f x} \<subseteq> U2"
    proof (rule Hausdorff_space_compact_separation [of X "{x}" "C \<inter> {z \<in> topspace X. f z = f x}", OF \<open>Hausdorff_space X\<close>])
      show "compactin X {x}"
        by (simp add: \<open>x \<in> topspace X\<close>)
      show "compactin X (C \<inter> {z \<in> topspace X. f z = f x})"
        using \<open>closedin X C\<close> fim \<open>x \<in> topspace X\<close> closed_Int_compactin preYf by fastforce
      show "disjnt {x} (C \<inter> {z \<in> topspace X. f z = f x})"
        using \<open>x \<notin> C\<close> by force
    qed
    have "closedin Y (f ` (C - U2))"
      using \<open>closed_map X Y f\<close> \<open>closedin X C\<close> \<open>openin X U2\<close> closed_map_def by blast
    moreover
    have "f x \<in> topspace Y - f ` (C - U2)"
      using \<open>closedin X C\<close> \<open>continuous_map X Y f\<close> \<open>x \<in> topspace X\<close> closedin_subset continuous_map_def subV by fastforce
    ultimately
    obtain V1 V2 where VV: "openin Y V1" "openin Y V2" "f x \<in> V1" 
                and subV2: "f ` (C - U2) \<subseteq> V2" and "disjnt V1 V2"
      by (meson R regular_space_def)
    show "\<exists>U U'. openin X U \<and> openin X U' \<and> x \<in> U \<and> C \<subseteq> U' \<and> disjnt U U'"
    proof (intro exI conjI)
      show "openin X (U1 \<inter> {x \<in> topspace X. f x \<in> V1})"
        using VV(1) \<open>continuous_map X Y f\<close> \<open>openin X U1\<close> continuous_map by fastforce
      show "openin X (U2 \<union> {x \<in> topspace X. f x \<in> V2})"
        using VV(2) \<open>continuous_map X Y f\<close> \<open>openin X U2\<close> continuous_map by fastforce
      show "x \<in> U1 \<inter> {x \<in> topspace X. f x \<in> V1}"
        using VV(3) \<open>x \<in> topspace X\<close> \<open>{x} \<subseteq> U1\<close> by auto
      show "C \<subseteq> U2 \<union> {x \<in> topspace X. f x \<in> V2}"
        using \<open>closedin X C\<close> closedin_subset subV2 by auto
      show "disjnt (U1 \<inter> {x \<in> topspace X. f x \<in> V1}) (U2 \<union> {x \<in> topspace X. f x \<in> V2})"
        using \<open>disjnt U1 U2\<close> \<open>disjnt V1 V2\<close> by (auto simp: disjnt_iff)
    qed
  qed
qed



subsection\<open>Locally compact spaces\<close>

definition locally_compact_space 
  where "locally_compact_space X \<equiv>
    \<forall>x \<in> topspace X. \<exists>U K. openin X U \<and> compactin X K \<and> x \<in> U \<and> U \<subseteq> K"

lemma homeomorphic_locally_compact_spaceD:
  assumes X: "locally_compact_space X" and "X homeomorphic_space Y"
  shows "locally_compact_space Y"
proof -
  obtain f where hmf: "homeomorphic_map X Y f"
    using assms homeomorphic_space by blast
  then have eq: "topspace Y = f ` (topspace X)"
    by (simp add: homeomorphic_imp_surjective_map)
  have "\<exists>V K. openin Y V \<and> compactin Y K \<and> f x \<in> V \<and> V \<subseteq> K"
    if "x \<in> topspace X" "openin X U" "compactin X K" "x \<in> U" "U \<subseteq> K" for x U K
    using that 
    by (meson hmf homeomorphic_map_compactness_eq homeomorphic_map_openness_eq image_mono image_eqI)
  with X show ?thesis
    by (smt (verit) eq image_iff locally_compact_space_def)
qed

lemma homeomorphic_locally_compact_space:
  assumes "X homeomorphic_space Y"
  shows "locally_compact_space X \<longleftrightarrow> locally_compact_space Y"
  by (meson assms homeomorphic_locally_compact_spaceD homeomorphic_space_sym)

lemma locally_compact_space_retraction_map_image:
  assumes "retraction_map X Y r" and X: "locally_compact_space X"
  shows "locally_compact_space Y"
proof -
  obtain s where s: "retraction_maps X Y r s"
    using assms retraction_map_def by blast
  obtain T where "T retract_of_space X" and Teq: "T = s ` topspace Y"
    using retraction_maps_section_image1 s by blast
  then obtain r where r: "continuous_map X (subtopology X T) r" "\<forall>x\<in>T. r x = x"
    by (meson retract_of_space_def)
  have "locally_compact_space (subtopology X T)"
    unfolding locally_compact_space_def openin_subtopology_alt
  proof clarsimp
    fix x
    assume "x \<in> topspace X" "x \<in> T"
    obtain U K where UK: "openin X U \<and> compactin X K \<and> x \<in> U \<and> U \<subseteq> K"
      by (meson X \<open>x \<in> topspace X\<close> locally_compact_space_def)
    then have "compactin (subtopology X T) (r ` K) \<and> T \<inter> U \<subseteq> r ` K"
      by (smt (verit) IntD1 image_compactin image_iff inf_le2 r subset_iff)
    then show "\<exists>U. openin X U \<and> (\<exists>K. compactin (subtopology X T) K \<and> x \<in> U \<and> T \<inter> U \<subseteq> K)"
      using UK by auto
  qed
  with Teq show ?thesis
    using homeomorphic_locally_compact_space retraction_maps_section_image2 s by blast
qed

lemma compact_imp_locally_compact_space:
   "compact_space X \<Longrightarrow> locally_compact_space X"
  using compact_space_def locally_compact_space_def by blast

lemma neighbourhood_base_imp_locally_compact_space:
   "neighbourhood_base_of (compactin X) X \<Longrightarrow> locally_compact_space X"
  by (metis locally_compact_space_def neighbourhood_base_of openin_topspace)

lemma locally_compact_imp_neighbourhood_base:
  assumes loc: "locally_compact_space X" and reg: "regular_space X"
  shows "neighbourhood_base_of (compactin X) X"
  unfolding neighbourhood_base_of
proof clarify
  fix W x
  assume "openin X W" and "x \<in> W"
  then obtain U K where "openin X U" "compactin X K" "x \<in> U" "U \<subseteq> K"
    by (metis loc locally_compact_space_def openin_subset subsetD)
  moreover have "openin X (U \<inter> W) \<and> x \<in> U \<inter> W"
    using \<open>openin X W\<close> \<open>x \<in> W\<close> \<open>openin X U\<close> \<open>x \<in> U\<close> by blast
  then have "\<exists>u' v. openin X u' \<and> closedin X v \<and> x \<in> u' \<and> u' \<subseteq> v \<and> v \<subseteq> U \<and> v \<subseteq> W"
    using reg
    by (metis le_infE neighbourhood_base_of neighbourhood_base_of_closedin)
  then show "\<exists>U V. openin X U \<and> compactin X V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W"
    by (meson \<open>U \<subseteq> K\<close> \<open>compactin X K\<close> closed_compactin subset_trans)
qed

lemma Hausdorff_regular: "\<lbrakk>Hausdorff_space X; neighbourhood_base_of (compactin X) X\<rbrakk> \<Longrightarrow> regular_space X"
  by (metis compactin_imp_closedin neighbourhood_base_of_closedin neighbourhood_base_of_mono)

lemma locally_compact_Hausdorff_imp_regular_space: 
  assumes loc: "locally_compact_space X" and "Hausdorff_space X"
  shows "regular_space X"
  unfolding neighbourhood_base_of_closedin [symmetric] neighbourhood_base_of
proof clarify
  fix W x
  assume "openin X W" and "x \<in> W"
  then have "x \<in> topspace X"
    using openin_subset by blast 
  then obtain U K where "openin X U" "compactin X K" and UK: "x \<in> U" "U \<subseteq> K"
    by (meson loc locally_compact_space_def)
  with \<open>Hausdorff_space X\<close> have "regular_space (subtopology X K)"
    using Hausdorff_space_subtopology compact_Hausdorff_imp_regular_space compact_space_subtopology by blast
  then have "\<exists>U' V'. openin (subtopology X K) U' \<and> closedin (subtopology X K) V' \<and> x \<in> U' \<and> U' \<subseteq> V' \<and> V' \<subseteq> K \<inter> W"
    unfolding neighbourhood_base_of_closedin [symmetric] neighbourhood_base_of
    by (meson IntI \<open>U \<subseteq> K\<close> \<open>openin X W\<close> \<open>x \<in> U\<close> \<open>x \<in> W\<close> openin_subtopology_Int2 subsetD)
  then obtain V C where "openin X V" "closedin X C" and VC: "x \<in> K \<inter> V" "K \<inter> V \<subseteq> K \<inter> C" "K \<inter> C \<subseteq> K \<inter> W"
    by (metis Int_commute closedin_subtopology openin_subtopology)
  show "\<exists>U V. openin X U \<and> closedin X V \<and> x \<in> U \<and> U \<subseteq> V \<and> V \<subseteq> W"
  proof (intro conjI exI)
    show "openin X (U \<inter> V)"
      using \<open>openin X U\<close> \<open>openin X V\<close> by blast
    show "closedin X (K \<inter> C)"
      using \<open>closedin X C\<close> \<open>compactin X K\<close> compactin_imp_closedin \<open>Hausdorff_space X\<close> by blast
  qed (use UK VC in auto)
qed

lemma locally_compact_space_neighbourhood_base:
  "Hausdorff_space X \<or> regular_space X
        \<Longrightarrow> locally_compact_space X \<longleftrightarrow> neighbourhood_base_of (compactin X) X"
  by (metis locally_compact_imp_neighbourhood_base locally_compact_Hausdorff_imp_regular_space 
            neighbourhood_base_imp_locally_compact_space)

lemma locally_compact_Hausdorff_or_regular:
   "locally_compact_space X \<and> (Hausdorff_space X \<or> regular_space X) \<longleftrightarrow> locally_compact_space X \<and> regular_space X"
  using locally_compact_Hausdorff_imp_regular_space by blast

lemma locally_compact_space_compact_closedin:
  assumes  "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow>
         (\<forall>x \<in> topspace X. \<exists>U K. openin X U \<and> compactin X K \<and> closedin X K \<and> x \<in> U \<and> U \<subseteq> K)"
  using locally_compact_Hausdorff_or_regular unfolding locally_compact_space_def
  by (metis assms closed_compactin inf.absorb_iff2 le_infE neighbourhood_base_of neighbourhood_base_of_closedin)

lemma locally_compact_space_compact_closure_of:
  assumes "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow>
         (\<forall>x \<in> topspace X. \<exists>U. openin X U \<and> compactin X (X closure_of U) \<and> x \<in> U)" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis assms closed_compactin closedin_closure_of closure_of_eq closure_of_mono locally_compact_space_compact_closedin)
next
  assume ?rhs then show ?lhs
    by (meson closure_of_subset locally_compact_space_def openin_subset)
qed

lemma locally_compact_space_neighbourhood_base_closedin:
  assumes "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow> neighbourhood_base_of (\<lambda>C. compactin X C \<and> closedin X C) X" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then have "regular_space X"
    using assms locally_compact_Hausdorff_imp_regular_space by blast
  with L have "neighbourhood_base_of (compactin X) X"
   by (simp add: locally_compact_imp_neighbourhood_base)
  with \<open>regular_space X\<close> show ?rhs
    by (smt (verit, ccfv_threshold) closed_compactin neighbourhood_base_of subset_trans neighbourhood_base_of_closedin)
next
  assume ?rhs then show ?lhs
    using neighbourhood_base_imp_locally_compact_space neighbourhood_base_of_mono by blast
qed

lemma locally_compact_space_neighbourhood_base_closure_of:
  assumes "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow> neighbourhood_base_of (\<lambda>T. compactin X (X closure_of T)) X" 
         (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then have "regular_space X"
    using assms locally_compact_Hausdorff_imp_regular_space by blast
  with L have "neighbourhood_base_of (\<lambda>A. compactin X A \<and> closedin X A) X"
    using locally_compact_space_neighbourhood_base_closedin by blast
  then show ?rhs
    by (simp add: closure_of_closedin neighbourhood_base_of_mono)
next
  assume ?rhs then show ?lhs
    unfolding locally_compact_space_def neighbourhood_base_of
    by (meson closure_of_subset openin_topspace subset_trans)
qed

lemma locally_compact_space_neighbourhood_base_open_closure_of:
  assumes "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow> 
             neighbourhood_base_of (\<lambda>U. openin X U \<and> compactin X (X closure_of U)) X"
         (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then have "regular_space X"
    using assms locally_compact_Hausdorff_imp_regular_space by blast
  then have "neighbourhood_base_of (\<lambda>T. compactin X (X closure_of T)) X"
    using L locally_compact_space_neighbourhood_base_closure_of by auto
  with L show ?rhs
    unfolding neighbourhood_base_of
    by (meson closed_compactin closure_of_closure_of closure_of_eq closure_of_mono subset_trans)
next
  assume ?rhs then show ?lhs
    unfolding locally_compact_space_def neighbourhood_base_of
    by (meson closure_of_subset openin_topspace subset_trans)
qed

lemma locally_compact_space_compact_closed_compact:
  assumes "Hausdorff_space X \<or> regular_space X"
  shows "locally_compact_space X \<longleftrightarrow>
         (\<forall>K. compactin X K
              \<longrightarrow> (\<exists>U L. openin X U \<and> compactin X L \<and> closedin X L \<and> K \<subseteq> U \<and> U \<subseteq> L))"
         (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then obtain U L where UL: "\<forall>x \<in> topspace X. openin X (U x) \<and> compactin X (L x) \<and> closedin X (L x) \<and> x \<in> U x \<and> U x \<subseteq> L x"
    unfolding locally_compact_space_compact_closedin [OF assms]
    by metis
  show ?rhs
  proof clarify
    fix K
    assume "compactin X K"
    then have "K \<subseteq> topspace X"
      by (simp add: compactin_subset_topspace)
    then have *: "(\<forall>U\<in>U ` K. openin X U) \<and> K \<subseteq> \<Union> (U ` K)"
      using UL by blast
    with \<open>compactin X K\<close> obtain KF where KF: "finite KF" "KF \<subseteq> K" "K \<subseteq> \<Union>(U ` KF)"
      by (metis compactinD finite_subset_image)
    show "\<exists>U L. openin X U \<and> compactin X L \<and> closedin X L \<and> K \<subseteq> U \<and> U \<subseteq> L"
    proof (intro conjI exI)
      show "openin X (\<Union> (U ` KF))"
        using "*" \<open>KF \<subseteq> K\<close> by fastforce
      show "compactin X (\<Union> (L ` KF))"
        by (smt (verit) UL \<open>K \<subseteq> topspace X\<close> KF compactin_Union finite_imageI imageE subset_iff)
      show "closedin X (\<Union> (L ` KF))"
        by (smt (verit) UL \<open>K \<subseteq> topspace X\<close> KF closedin_Union finite_imageI imageE subsetD)
    qed (use UL \<open>K \<subseteq> topspace X\<close> KF in auto)
  qed
next
  assume ?rhs then show ?lhs
    by (metis compactin_sing insert_subset locally_compact_space_def)
qed

lemma locally_compact_regular_space_neighbourhood_base:
   "locally_compact_space X \<and> regular_space X \<longleftrightarrow>
        neighbourhood_base_of (\<lambda>C. compactin X C \<and> closedin X C) X"
  using locally_compact_space_neighbourhood_base_closedin neighbourhood_base_of_closedin neighbourhood_base_of_mono by blast

lemma locally_compact_kc_space:
   "neighbourhood_base_of (compactin X) X \<and> kc_space X \<longleftrightarrow>
        locally_compact_space X \<and> Hausdorff_space X"
  using Hausdorff_imp_kc_space locally_compact_imp_kc_eq_Hausdorff_space locally_compact_space_neighbourhood_base by blast

lemma locally_compact_kc_space_alt:
   "neighbourhood_base_of (compactin X) X \<and> kc_space X \<longleftrightarrow>
        locally_compact_space X \<and> Hausdorff_space X \<and> regular_space X"
  using Hausdorff_regular locally_compact_kc_space by blast

lemma locally_compact_kc_imp_regular_space:
   "\<lbrakk>neighbourhood_base_of (compactin X) X; kc_space X\<rbrakk> \<Longrightarrow> regular_space X"
  using Hausdorff_regular locally_compact_imp_kc_eq_Hausdorff_space by blast

lemma kc_locally_compact_space:
   "kc_space X
    \<Longrightarrow> neighbourhood_base_of (compactin X) X \<longleftrightarrow> locally_compact_space X \<and> Hausdorff_space X \<and> regular_space X"
  using Hausdorff_regular locally_compact_kc_space by blast

lemma locally_compact_space_closed_subset:
  assumes loc: "locally_compact_space X" and "closedin X S"
  shows "locally_compact_space (subtopology X S)"
proof (clarsimp simp: locally_compact_space_def)
  fix x assume x: "x \<in> topspace X" "x \<in> S"
  then obtain U K where UK: "openin X U \<and> compactin X K \<and> x \<in> U \<and> U \<subseteq> K"
    by (meson loc locally_compact_space_def)
  show "\<exists>U. openin (subtopology X S) U \<and> 
            (\<exists>K. compactin (subtopology X S) K \<and> x \<in> U \<and> U \<subseteq> K)"
  proof (intro conjI exI)
    show "openin (subtopology X S) (S \<inter> U)"
      by (simp add: UK openin_subtopology_Int2)
    show "compactin (subtopology X S) (S \<inter> K)"
      by (simp add: UK assms(2) closed_Int_compactin compactin_subtopology)
  qed (use UK x in auto)
qed

lemma locally_compact_space_open_subset:
  assumes reg: "regular_space X" and loc: "locally_compact_space X" and "openin X S"
  shows "locally_compact_space (subtopology X S)"
proof (clarsimp simp: locally_compact_space_def)
  fix x assume x: "x \<in> topspace X" "x \<in> S"
  then obtain U K where UK: "openin X U" "compactin X K" "x \<in> U" "U \<subseteq> K"
    by (meson loc locally_compact_space_def)
  have "openin X (U \<inter> S)"
    by (simp add: UK \<open>openin X S\<close> openin_Int)
  with UK reg x obtain V C 
      where VC: "openin X V" "closedin X C" "x \<in> V" "V \<subseteq> C" "C \<subseteq> U" "C \<subseteq> S"
    by (metis IntI le_inf_iff neighbourhood_base_of neighbourhood_base_of_closedin)
  show "\<exists>U. openin (subtopology X S) U \<and> 
            (\<exists>K. compactin (subtopology X S) K \<and> x \<in> U \<and> U \<subseteq> K)"
  proof (intro conjI exI)
    show "openin (subtopology X S) V"
      using VC by (meson \<open>openin X S\<close> openin_open_subtopology order_trans)
    show "compactin (subtopology X S) (C \<inter> K)"
      using UK VC closed_Int_compactin compactin_subtopology by fastforce
  qed (use UK VC x in auto)
qed

lemma locally_compact_space_discrete_topology:
   "locally_compact_space (discrete_topology U)"
  by (simp add: neighbourhood_base_imp_locally_compact_space neighbourhood_base_of_discrete_topology)

lemma locally_compact_space_continuous_open_map_image:
  "\<lbrakk>continuous_map X X' f; open_map X X' f;
    f ` topspace X = topspace X'; locally_compact_space X\<rbrakk> \<Longrightarrow> locally_compact_space X'"
unfolding locally_compact_space_def open_map_def
  by (smt (verit, ccfv_SIG) image_compactin image_iff image_mono)

lemma locally_compact_subspace_openin_closure_of:
  assumes "Hausdorff_space X" and S: "S \<subseteq> topspace X" 
    and loc: "locally_compact_space (subtopology X S)"
  shows "openin (subtopology X (X closure_of S)) S"
  unfolding openin_subopen [where S=S]
proof clarify
  fix a assume "a \<in> S"
  then obtain T K where *: "openin X T" "compactin X K" "K \<subseteq> S" "a \<in> S" "a \<in> T" "S \<inter> T \<subseteq> K"
    using loc unfolding locally_compact_space_def
  by (metis IntE S compactin_subtopology inf_commute openin_subtopology topspace_subtopology_subset)
  have "T \<inter> X closure_of S \<subseteq> X closure_of (T \<inter> S)"
    by (simp add: "*"(1) openin_Int_closure_of_subset)
  also have "... \<subseteq> S"
    using * \<open>Hausdorff_space X\<close> by (metis closure_of_minimal compactin_imp_closedin order.trans inf_commute)
  finally have "T \<inter> X closure_of S \<subseteq> T \<inter> S" by simp 
  then have "openin (subtopology X (X closure_of S)) (T \<inter> S)"
    unfolding openin_subtopology using \<open>openin X T\<close> S closure_of_subset by fastforce
  with * show "\<exists>T. openin (subtopology X (X closure_of S)) T \<and> a \<in> T \<and> T \<subseteq> S"
    by blast
qed

lemma locally_compact_subspace_closed_Int_openin:
   "\<lbrakk>Hausdorff_space X \<and> S \<subseteq> topspace X \<and> locally_compact_space(subtopology X S)\<rbrakk>
        \<Longrightarrow> \<exists>C U. closedin X C \<and> openin X U \<and> C \<inter> U = S"
  by (metis closedin_closure_of inf_commute locally_compact_subspace_openin_closure_of openin_subtopology)

lemma locally_compact_subspace_open_in_closure_of_eq:
  assumes "Hausdorff_space X" and loc: "locally_compact_space X"
  shows "openin (subtopology X (X closure_of S)) S \<longleftrightarrow> S \<subseteq> topspace X \<and> locally_compact_space(subtopology X S)" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then obtain "S \<subseteq> topspace X" "regular_space X"
    using assms locally_compact_Hausdorff_imp_regular_space openin_subset by fastforce 
  then have "locally_compact_space (subtopology (subtopology X (X closure_of S)) S)"
    by (simp add: L loc locally_compact_space_closed_subset locally_compact_space_open_subset regular_space_subtopology)
  then show ?rhs
    by (metis L inf.orderE inf_commute le_inf_iff openin_subset subtopology_subtopology topspace_subtopology)
next
  assume ?rhs then show ?lhs
    using  assms locally_compact_subspace_openin_closure_of by blast
qed

lemma locally_compact_subspace_closed_Int_openin_eq:
  assumes "Hausdorff_space X" and loc: "locally_compact_space X"
  shows "(\<exists>C U. closedin X C \<and> openin X U \<and> C \<inter> U = S) \<longleftrightarrow> S \<subseteq> topspace X \<and> locally_compact_space(subtopology X S)" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then obtain C U where "closedin X C" "openin X U" and Seq: "S = C \<inter> U"
    by blast
  then have "C \<subseteq> topspace X"
    by (simp add: closedin_subset)
  have "locally_compact_space (subtopology (subtopology X C) (topspace (subtopology X C) \<inter> U))"
    proof (rule locally_compact_space_open_subset)
  show "regular_space (subtopology X C)"
    by (simp add: \<open>Hausdorff_space X\<close> loc locally_compact_Hausdorff_imp_regular_space regular_space_subtopology)
  show "locally_compact_space (subtopology X C)"
    by (simp add: \<open>closedin X C\<close> loc locally_compact_space_closed_subset)
  show "openin (subtopology X C) (topspace (subtopology X C) \<inter> U)"
    by (simp add: \<open>openin X U\<close> Int_left_commute inf_commute openin_Int openin_subtopology_Int2)
qed
    then show ?rhs
      by (metis Seq \<open>C \<subseteq> topspace X\<close> inf.coboundedI1 subtopology_subtopology subtopology_topspace)
next
  assume ?rhs then show ?lhs
  using assms locally_compact_subspace_closed_Int_openin by blast
qed

lemma dense_locally_compact_openin_Hausdorff_space:
   "\<lbrakk>Hausdorff_space X; S \<subseteq> topspace X; X closure_of S = topspace X;
     locally_compact_space (subtopology X S)\<rbrakk> \<Longrightarrow> openin X S"
  by (metis locally_compact_subspace_openin_closure_of subtopology_topspace)

lemma locally_compact_space_prod_topology:
  "locally_compact_space (prod_topology X Y) \<longleftrightarrow>
        topspace (prod_topology X Y) = {} \<or>
        locally_compact_space X \<and> locally_compact_space Y" (is "?lhs=?rhs")
proof (cases "topspace (prod_topology X Y) = {}")
  case True
  then show ?thesis
    unfolding locally_compact_space_def by blast
next
  case False
  then obtain w z where wz: "w \<in> topspace X" "z \<in> topspace Y"
    by auto
  show ?thesis 
  proof
    assume L: ?lhs then show ?rhs
      by (metis wz empty_iff locally_compact_space_retraction_map_image retraction_map_fst retraction_map_snd)
  next
    assume R: ?rhs 
    show ?lhs
      unfolding locally_compact_space_def
    proof clarsimp
      fix x y
      assume "x \<in> topspace X" and "y \<in> topspace Y"
      obtain U C where "openin X U" "compactin X C" "x \<in> U" "U \<subseteq> C"
        by (meson False R \<open>x \<in> topspace X\<close> locally_compact_space_def)
      obtain V D where "openin Y V" "compactin Y D" "y \<in> V" "V \<subseteq> D"
        by (meson False R \<open>y \<in> topspace Y\<close> locally_compact_space_def)
      show "\<exists>U. openin (prod_topology X Y) U \<and> (\<exists>K. compactin (prod_topology X Y) K \<and> (x, y) \<in> U \<and> U \<subseteq> K)"
      proof (intro exI conjI)
        show "openin (prod_topology X Y) (U \<times> V)"
          by (simp add: \<open>openin X U\<close> \<open>openin Y V\<close> openin_prod_Times_iff)
        show "compactin (prod_topology X Y) (C \<times> D)"
          by (simp add: \<open>compactin X C\<close> \<open>compactin Y D\<close> compactin_Times)
        show "(x, y) \<in> U \<times> V"
          by (simp add: \<open>x \<in> U\<close> \<open>y \<in> V\<close>)
        show "U \<times> V \<subseteq> C \<times> D"
          by (simp add: Sigma_mono \<open>U \<subseteq> C\<close> \<open>V \<subseteq> D\<close>)
      qed
    qed
  qed
qed

lemma locally_compact_space_product_topology:
   "locally_compact_space(product_topology X I) \<longleftrightarrow>
        topspace(product_topology X I) = {} \<or>
        finite {i \<in> I. \<not> compact_space(X i)} \<and> (\<forall>i \<in> I. locally_compact_space(X i))" (is "?lhs=?rhs")
proof (cases "topspace (product_topology X I) = {}")
  case True
  then show ?thesis
    by (simp add: locally_compact_space_def)
next
  case False
  show ?thesis 
  proof
    assume L: ?lhs
    obtain z where z: "z \<in> topspace (product_topology X I)"
      using False by auto
    with L z obtain U C where "openin (product_topology X I) U" "compactin (product_topology X I) C" "z \<in> U" "U \<subseteq> C"
      by (meson locally_compact_space_def)
    then obtain V where finV: "finite {i \<in> I. V i \<noteq> topspace (X i)}" and "\<forall>i \<in> I. openin (X i) (V i)" 
                    and "z \<in> PiE I V" "PiE I V \<subseteq> U"
      by (auto simp: openin_product_topology_alt)
    have "compact_space (X i)" if "i \<in> I" "V i = topspace (X i)" for i
    proof -
      have "compactin (X i) ((\<lambda>x. x i) ` C)"
        using \<open>compactin (product_topology X I) C\<close> image_compactin
        by (metis continuous_map_product_projection \<open>i \<in> I\<close>)
      moreover have "V i \<subseteq> (\<lambda>x. x i) ` C"
      proof -
        have "V i \<subseteq> (\<lambda>x. x i) ` Pi\<^sub>E I V"
          by (metis \<open>z \<in> Pi\<^sub>E I V\<close> empty_iff image_projection_PiE order_refl \<open>i \<in> I\<close>)
        also have "\<dots> \<subseteq> (\<lambda>x. x i) ` C"
          using \<open>U \<subseteq> C\<close> \<open>Pi\<^sub>E I V \<subseteq> U\<close> by blast
        finally show ?thesis .
      qed
      ultimately show ?thesis
        by (metis closed_compactin closedin_topspace compact_space_def that(2))
    qed
    with finV have "finite {i \<in> I. \<not> compact_space (X i)}"
      by (metis (mono_tags, lifting) mem_Collect_eq finite_subset subsetI)
    moreover have "locally_compact_space (X i)" if "i \<in> I" for i
      by (meson False L locally_compact_space_retraction_map_image retraction_map_product_projection that)
    ultimately show ?rhs by metis
  next
    assume R: ?rhs 
    show ?lhs
      unfolding locally_compact_space_def
    proof clarsimp
      fix z
      assume z: "z \<in> (\<Pi>\<^sub>E i\<in>I. topspace (X i))"
      have "\<exists>U C. openin (X i) U \<and> compactin (X i) C \<and> z i \<in> U \<and> U \<subseteq> C \<and>
                    (compact_space(X i) \<longrightarrow> U = topspace(X i) \<and> C = topspace(X i))" 
        if "i \<in> I" for i
        using that R z unfolding locally_compact_space_def compact_space_def
        by (metis (no_types, lifting) False PiE_mem openin_topspace set_eq_subset)
      then obtain U C where UC: "\<And>i. i \<in> I \<Longrightarrow> 
             openin (X i) (U i) \<and> compactin (X i) (C i) \<and> z i \<in> U i \<and> U i \<subseteq> C i \<and>
                    (compact_space(X i) \<longrightarrow> U i = topspace(X i) \<and> C i = topspace(X i))"
        by metis
      show "\<exists>U. openin (product_topology X I) U \<and> (\<exists>K. compactin (product_topology X I) K \<and> z \<in> U \<and> U \<subseteq> K)"
      proof (intro exI conjI)
        show "openin (product_topology X I) (Pi\<^sub>E I U)"
        by (smt (verit) Collect_cong False R UC compactin_subspace openin_PiE_gen subset_antisym subtopology_topspace)
        show "compactin (product_topology X I) (Pi\<^sub>E I C)"
          by (simp add: UC compactin_PiE)
      qed (use UC z in blast)+
    qed
  qed
qed

lemma locally_compact_space_sum_topology:
   "locally_compact_space (sum_topology X I) \<longleftrightarrow> (\<forall>i \<in> I. locally_compact_space (X i))" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (metis closed_map_component_injection embedding_map_imp_homeomorphic_space embedding_map_component_injection
        embedding_imp_closed_map_eq homeomorphic_locally_compact_space locally_compact_space_closed_subset)
next
  assume R: ?rhs
  show ?lhs
    unfolding locally_compact_space_def
  proof clarsimp
    fix i y
    assume "i \<in> I" and y: "y \<in> topspace (X i)"
    then obtain U K where UK: "openin (X i) U" "compactin (X i) K" "y \<in> U" "U \<subseteq> K"
      using R by (fastforce simp add: locally_compact_space_def)
    then show "\<exists>U. openin (sum_topology X I) U \<and> (\<exists>K. compactin (sum_topology X I) K \<and> (i, y) \<in> U \<and> U \<subseteq> K)"
      by (metis \<open>i \<in> I\<close> continuous_map_component_injection image_compactin image_mono 
          imageI open_map_component_injection open_map_def)
  qed
qed

lemma quotient_map_prod_right:
  assumes loc: "locally_compact_space Z" 
    and reg: "Hausdorff_space Z \<or> regular_space Z" 
    and f: "quotient_map X Y f"
  shows "quotient_map (prod_topology Z X) (prod_topology Z Y) (\<lambda>(x,y). (x,f y))"
proof -
  define h where "h \<equiv> (\<lambda>(x::'a,y). (x,f y))"
  have "continuous_map (prod_topology Z X) Y (f o snd)"
    by (simp add: continuous_map_of_snd f quotient_imp_continuous_map)
  then have cmh: "continuous_map (prod_topology Z X) (prod_topology Z Y) h"
    by (simp add: h_def continuous_map_paired split_def continuous_map_fst o_def)
  have fim: "f ` topspace X = topspace Y"
    by (simp add: f quotient_imp_surjective_map)
  moreover
  have "openin (prod_topology Z X) {u \<in> topspace Z \<times> topspace X. h u \<in> W}
   \<longleftrightarrow> openin (prod_topology Z Y) W"   (is "?lhs=?rhs")
    if W: "W \<subseteq> topspace Z \<times> topspace Y" for W
  proof
    define S where "S \<equiv> {u \<in> topspace Z \<times> topspace X. h u \<in> W}"
    assume ?lhs 
    then have L: "openin (prod_topology Z X) S"
      using S_def by blast
    have "\<exists>T. openin (prod_topology Z Y) T \<and> (x0, z0) \<in> T \<and> T \<subseteq> W"
      if \<section>: "(x0,z0) \<in> W" for x0 z0 
    proof -
      have x0: "x0 \<in> topspace Z"
        using W that by blast
      obtain y0 where y0: "y0 \<in> topspace X" "f y0 = z0"
        by (metis W fim imageE insert_absorb insert_subset mem_Sigma_iff \<section>)
      then have "(x0, y0) \<in> S"
        by (simp add: S_def h_def that x0)
      have "continuous_map Z (prod_topology Z X) (\<lambda>x. (x, y0))"
        by (simp add: continuous_map_paired y0)
      with openin_continuous_map_preimage [OF _ L] 
      have ope_ZS: "openin Z {x \<in> topspace Z. (x,y0) \<in> S}"
        by blast
      obtain U U' where "openin Z U" "compactin Z U'" "closedin Z U'" 
        "x0 \<in> U"  "U \<subseteq> U'" "U' \<subseteq> {x \<in> topspace Z. (x,y0) \<in> S}"
        using loc ope_ZS x0 \<open>(x0, y0) \<in> S\<close>
        by (force simp: locally_compact_space_neighbourhood_base_closedin [OF reg] 
            neighbourhood_base_of)
      then have D: "U' \<times> {y0} \<subseteq> S"
        by (auto simp: )
      define V where "V \<equiv> {z \<in> topspace Y. U' \<times> {y \<in> topspace X. f y = z} \<subseteq> S}"
      have "z0 \<in> V"
        using D y0 Int_Collect fim by (fastforce simp add: h_def V_def S_def)
      have "openin X {x \<in> topspace X. f x \<in> V} \<Longrightarrow> openin Y V"
        using f unfolding V_def quotient_map_def subset_iff
        by (smt (verit, del_insts) Collect_cong mem_Collect_eq)
      moreover have "openin X {x \<in> topspace X. f x \<in> V}"
      proof -
        let ?Z = "subtopology Z U'"
        have *: "{x \<in> topspace X. f x \<in> V} = topspace X - snd ` (U' \<times> topspace X - S)"
          by (force simp: V_def S_def h_def simp flip: fim)
        have "compact_space ?Z"
          using \<open>compactin Z U'\<close> compactin_subspace by auto
        moreover have "closedin (prod_topology ?Z X) (U' \<times> topspace X - S)"
          by (simp add: L \<open>closedin Z U'\<close> closedin_closed_subtopology closedin_diff closedin_prod_Times_iff 
              prod_topology_subtopology(1))
        ultimately show ?thesis
          using "*" Abstract_Metric_Spaces.closed_map_snd closed_map_def by fastforce
      qed
      ultimately have "openin Y V"
        by metis
      show ?thesis
      proof (intro conjI exI)
        show "openin (prod_topology Z Y) (U \<times> V)"
          by (simp add: openin_prod_Times_iff \<open>openin Z U\<close> \<open>openin Y V\<close>)
        show "(x0, z0) \<in> U \<times> V"
          by (simp add: \<open>x0 \<in> U\<close> \<open>z0 \<in> V\<close>)
        show "U \<times> V \<subseteq> W"
          using \<open>U \<subseteq> U'\<close> by (force simp: V_def S_def h_def simp flip: fim)
      qed
    qed
    with openin_subopen show ?rhs by force
  next
    assume ?rhs then show ?lhs
      using openin_continuous_map_preimage cmh by fastforce
  qed
  ultimately show ?thesis
    by (fastforce simp: image_iff quotient_map_def h_def)
qed

lemma quotient_map_prod_left:
  assumes loc: "locally_compact_space Z" 
    and reg: "Hausdorff_space Z \<or> regular_space Z" 
    and f: "quotient_map X Y f"
  shows "quotient_map (prod_topology X Z) (prod_topology Y Z) (\<lambda>(x,y). (f x,y))"
proof -
  have "(\<lambda>(x,y). (f x,y)) = prod.swap \<circ> (\<lambda>(x,y). (x,f y)) \<circ> prod.swap"
    by force
  then
  show ?thesis
    apply (rule ssubst)
  proof (intro quotient_map_compose)
    show "quotient_map (prod_topology X Z) (prod_topology Z X) prod.swap"
      "quotient_map (prod_topology Z Y) (prod_topology Y Z) prod.swap"
      using homeomorphic_map_def homeomorphic_map_swap quotient_map_eq by fastforce+
    show "quotient_map (prod_topology Z X) (prod_topology Z Y) (\<lambda>(x, y). (x, f y))"
      by (simp add: f loc quotient_map_prod_right reg)
  qed
qed

lemma locally_compact_space_perfect_map_preimage:
  assumes "locally_compact_space X'" and f: "perfect_map X X' f"
  shows "locally_compact_space X"
  unfolding locally_compact_space_def
proof (intro strip)
  fix x
  assume x: "x \<in> topspace X"
  then obtain U K where "openin X' U" "compactin X' K" "f x \<in> U" "U \<subseteq> K"
    using assms unfolding locally_compact_space_def perfect_map_def
    by (metis (no_types, lifting) continuous_map_closedin)
  show "\<exists>U K. openin X U \<and> compactin X K \<and> x \<in> U \<and> U \<subseteq> K"
  proof (intro exI conjI)
    have "continuous_map X X' f"
      using f perfect_map_def by blast
    then show "openin X {x \<in> topspace X. f x \<in> U}"
      by (simp add: \<open>openin X' U\<close> continuous_map)
    show "compactin X {x \<in> topspace X. f x \<in> K}"
      using \<open>compactin X' K\<close> f perfect_imp_proper_map proper_map_alt by blast
  qed (use x \<open>f x \<in> U\<close> \<open>U \<subseteq> K\<close> in auto)
qed



lemma mball_eq_ball [simp]: "Met.mball = ball"
  by force

lemma mopen_eq_open [simp]: "Met.mopen = open"
  by (force simp: open_contains_ball Met.mopen_def)

lemma metrizable_space_euclidean:
  "metrizable_space (euclidean :: 'a::metric_space topology)"
  unfolding metrizable_space_def
  by (metis Met.Metric_space_axioms Met.mtopology_def mopen_eq_open)

lemma kc_space_euclidean: "kc_space (euclidean :: 'a::metric_space topology)"
  by (simp add: compact_imp_closed kc_space_def)

lemma t1_space_euclidean: "t1_space (euclidean :: 'a::metric_space topology)"
  by (simp add: Hausdorff_imp_t1_space)

lemma regular_space_euclidean:
 "regular_space (euclidean :: 'a::metric_space topology)"
  by (simp add: metrizable_imp_regular_space metrizable_space_euclidean)


lemma subbase_subtopology_euclidean:
  fixes U :: "'a::order_topology set"
  shows
  "topology
    (arbitrary union_of
      (finite intersection_of (\<lambda>x. x \<in> range greaterThan \<union> range lessThan) relative_to U))
 = subtopology euclidean U"
proof -
  have "\<exists>V. (finite intersection_of (\<lambda>x. x \<in> range greaterThan \<or> x \<in> range lessThan)) V \<and> x \<in> V \<and> V \<subseteq> W"
    if "open W" "x \<in> W" for W and x::'a
    using \<open>open W\<close> [unfolded open_generated_order] \<open>x \<in> W\<close>
  proof (induct rule: generate_topology.induct)
    case UNIV
    then show ?case
      using finite_intersection_of_empty by blast
  next
    case (Int a b)
    then show ?case 
        by (meson Int_iff finite_intersection_of_Int inf_mono)
  next
    case (UN K)
    then show ?case
      by (meson Union_iff subset_iff)
  next
    case (Basis s)
    then show ?case
      by (metis (no_types, lifting) Un_iff finite_intersection_of_inc order_refl)
  qed
  moreover 
  have "\<And>V::'a set. (finite intersection_of (\<lambda>x. x \<in> range greaterThan \<or> x \<in> range lessThan)) V \<Longrightarrow> open V"
    by (force simp add: intersection_of_def subset_iff)
  ultimately have *: "openin (euclidean::'a topology) = 
           (arbitrary union_of (finite intersection_of (\<lambda>x. x \<in> range greaterThan \<or> x \<in> range lessThan)))" 
    by (smt (verit, best) openin_topology_base_unique open_openin)
  show ?thesis
    unfolding subtopology_def arbitrary_union_of_relative_to [symmetric] 
    apply (simp add: relative_to_def flip: *)
    by (metis Int_commute)
qed

subsection\<open>Limits at a point in a topological space\<close>

lemma nontrivial_limit_atin:
   "atin X a \<noteq> bot \<longleftrightarrow> a \<in> X derived_set_of topspace X"
proof 
  show "atin X a \<noteq> bot \<Longrightarrow> a \<in> X derived_set_of topspace X"
    by (smt (verit) Diff_cancel derived_set_of_topspace empty_iff eventually_atin insertI1 mem_Collect_eq trivial_limit_eq)
next
  assume a: "a \<in> X derived_set_of topspace X"
  show "atin X a \<noteq> bot"
  proof
    assume "atin X a = bot"
    then have "eventually (\<lambda>_. False) (atin X a)"
      by simp
    then show False
      by (smt (verit, best) a eventually_atin in_derived_set_of insertE insert_Diff)
  qed
qed

lemma (in Metric_space) eventually_atin_metric:
   "eventually P (atin mtopology a) \<longleftrightarrow>
        (a \<in> M \<longrightarrow> (\<exists>\<delta>>0. \<forall>x. x \<in> M \<and> 0 < d x a \<and> d x a < \<delta> \<longrightarrow> P x))"  (is "?lhs=?rhs")
proof (cases "a \<in> M")
  case True
  show ?thesis
  proof
    assume L: ?lhs 
    with True obtain U where "openin mtopology U" "a \<in> U" and U: "\<forall>x\<in>U - {a}. P x"
      by (auto simp add: eventually_atin)
    then obtain r where "r>0" and "mball a r \<subseteq> U"
      by (meson openin_mtopology)
    with U show ?rhs
      by (smt (verit, ccfv_SIG) commute in_mball insert_Diff_single insert_iff subset_iff)
  next
    assume ?rhs 
    then obtain \<delta> where "\<delta>>0" and \<delta>: "\<forall>x. x \<in> M \<and> 0 < d x a \<and> d x a < \<delta> \<longrightarrow> P x"
      using True by blast
    then have "\<forall>x \<in> mball a \<delta> - {a}. P x"
      by (simp add: commute)
    then show ?lhs
      unfolding eventually_atin openin_mtopology
      by (metis True \<open>0 < \<delta>\<close> centre_in_mball_iff openin_mball openin_mtopology) 
  qed
qed auto


subsection\<open>Limits in a topological space\<close>


lemma limitin_const_iff:
  assumes "t1_space X" "\<not> trivial_limit F"
  shows "limitin X (\<lambda>k. a) l F \<longleftrightarrow> l \<in> topspace X \<and> a = l"  (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    using assms unfolding limitin_def t1_space_def by (metis eventually_const openin_topspace)
next
  assume ?rhs then show ?lhs
    using assms by (auto simp: limitin_def t1_space_def)
qed

lemma compactin_sequence_with_limit:
  assumes lim: "limitin X \<sigma> l sequentially" and "S \<subseteq> range \<sigma>" and SX: "S \<subseteq> topspace X"
  shows "compactin X (insert l S)"
unfolding compactin_def
proof (intro conjI strip)
  show "insert l S \<subseteq> topspace X"
    by (meson SX insert_subset lim limitin_topspace)
  fix \<U>
  assume \<section>: "Ball \<U> (openin X) \<and> insert l S \<subseteq> \<Union> \<U>"
  have "\<exists>V. finite V \<and> V \<subseteq> \<U> \<and> (\<exists>t \<in> V. l \<in> t) \<and> S \<subseteq> \<Union> V"
    if *: "\<forall>x \<in> S. \<exists>T \<in> \<U>. x \<in> T" and "T \<in> \<U>" "l \<in> T" for T
  proof -
    obtain V where V: "\<And>x. x \<in> S \<Longrightarrow> V x \<in> \<U> \<and> x \<in> V x"
      using * by metis
    obtain N where N: "\<And>n. N \<le> n \<Longrightarrow> \<sigma> n \<in> T"
      by (meson "\<section>" \<open>T \<in> \<U>\<close> \<open>l \<in> T\<close> lim limitin_sequentially)
    show ?thesis
    proof (intro conjI exI)
      have "x \<in> T"
        if "x \<in> S" and "\<forall>A. (\<forall>x \<in> S. (\<forall>n\<le>N. x \<noteq> \<sigma> n) \<or> A \<noteq> V x) \<or> x \<notin> A" for x 
        by (metis (no_types) N V that assms(2) imageE nle_le subsetD)
      then show "S \<subseteq> \<Union> (insert T (V ` (S \<inter> \<sigma> ` {0..N})))"
        by force
    qed (use V that in auto)
  qed
  then show "\<exists>\<F>. finite \<F> \<and> \<F> \<subseteq> \<U> \<and> insert l S \<subseteq> \<Union> \<F>"
    by (smt (verit, best) Union_iff \<section> insert_subset subsetD)
qed

lemma limitin_Hausdorff_unique:
  assumes "limitin X f l1 F" "limitin X f l2 F" "\<not> trivial_limit F" "Hausdorff_space X"
  shows "l1 = l2"
proof (rule ccontr)
  assume "l1 \<noteq> l2"
  with assms obtain U V where "openin X U" "openin X V" "l1 \<in> U" "l2 \<in> V" "disjnt U V"
    by (metis Hausdorff_space_def limitin_topspace)
  then have "eventually (\<lambda>x. f x \<in> U) F" "eventually (\<lambda>x. f x \<in> V) F"
    using assms by (fastforce simp: limitin_def)+
  then have "\<exists>x. f x \<in> U \<and> f x \<in> V"
    using assms eventually_elim2 filter_eq_iff by fastforce
  with assms \<open>disjnt U V\<close> show False
    by (meson disjnt_iff)
qed

lemma limitin_kc_unique:
  assumes "kc_space X" and lim1: "limitin X f l1 sequentially" and lim2: "limitin X f l2 sequentially"
  shows "l1 = l2"
proof (rule ccontr)
  assume "l1 \<noteq> l2"
  define A where "A \<equiv> insert l1 (range f - {l2})"
  have "l1 \<in> topspace X"
    using lim1 limitin_def by fastforce
  moreover have "compactin X (insert l1 (topspace X \<inter> (range f - {l2})))"
    by (meson Diff_subset compactin_sequence_with_limit inf_le1 inf_le2 lim1 subset_trans)
  ultimately have "compactin X (topspace X \<inter> A)"
    by (simp add: A_def)
  then have OXA: "openin X (topspace X - A)"
    by (metis Diff_Diff_Int Diff_subset \<open>kc_space X\<close> kc_space_def openin_closedin_eq)
  have "l2 \<in> topspace X - A"
    using \<open>l1 \<noteq> l2\<close> A_def lim2 limitin_topspace by fastforce
  then have "\<forall>\<^sub>F x in sequentially. f x = l2"
    using limitinD [OF lim2 OXA] by (auto simp: A_def eventually_conj_iff)
  then show False
    using limitin_transform_eventually [OF _ lim1] 
          limitin_const_iff [OF kc_imp_t1_space trivial_limit_sequentially]
    using \<open>l1 \<noteq> l2\<close> \<open>kc_space X\<close> by fastforce
qed


subsection\<open>Topological limitin in metric spaces\<close>


lemma (in Metric_space) limitin_mspace:
   "limitin mtopology f l F \<Longrightarrow> l \<in> M"
  using limitin_topspace by fastforce

lemma (in Metric_space) limitin_metric_unique:
   "\<lbrakk>limitin mtopology f l1 F; limitin mtopology f l2 F; F \<noteq> bot\<rbrakk> \<Longrightarrow> l1 = l2"
  by (meson Hausdorff_space_mtopology limitin_Hausdorff_unique)

lemma (in Metric_space) limitin_metric:
   "limitin mtopology f l F \<longleftrightarrow> l \<in> M \<and> (\<forall>\<epsilon>>0. eventually (\<lambda>x. f x \<in> M \<and> d (f x) l < \<epsilon>) F)"  
   (is "?lhs=?rhs")
proof
  assume L: ?lhs
  show ?rhs
    unfolding limitin_def
  proof (intro conjI strip)
    show "l \<in> M"
      using L limitin_mspace by blast
    fix \<epsilon>::real
    assume "\<epsilon>>0"
    then have "\<forall>\<^sub>F x in F. f x \<in> mball l \<epsilon>"
      using L openin_mball by (fastforce simp add: limitin_def)
    then show "\<forall>\<^sub>F x in F. f x \<in> M \<and> d (f x) l < \<epsilon>"
      using commute eventually_mono by fastforce
  qed
next
  assume R: ?rhs 
  then show ?lhs
    by (force simp: limitin_def commute openin_mtopology subset_eq elim: eventually_mono)
qed

lemma (in Metric_space) limit_metric_sequentially:
   "limitin mtopology f l sequentially \<longleftrightarrow>
     l \<in> M \<and> (\<forall>\<epsilon>>0. \<exists>N. \<forall>n\<ge>N. f n \<in> M \<and> d (f n) l < \<epsilon>)"
  by (auto simp: limitin_metric eventually_sequentially)

lemma limitin_closedin:
  assumes lim: "limitin X f l F" 
    and "closedin X S" and ev: "eventually (\<lambda>x. f x \<in> S) F" "\<not> trivial_limit F"
  shows "l \<in> S"
proof (rule ccontr)
  assume "l \<notin> S"
  have "\<forall>\<^sub>F x in F. f x \<in> topspace X - S"
    by (metis Diff_iff \<open>l \<notin> S\<close> \<open>closedin X S\<close> closedin_def lim limitin_def)
  with ev eventually_elim2 trivial_limit_def show False
    by force
qed

lemma (in submetric) limitin_submetric_iff:
   "limitin sub.mtopology f l F \<longleftrightarrow>
     l \<in> A \<and> eventually (\<lambda>x. f x \<in> A) F \<and> limitin mtopology f l F" (is "?lhs=?rhs")
  by (simp add: limitin_subtopology mtopology_submetric)

lemma (in Metric_space) metric_closedin_iff_sequentially_closed:
   "closedin mtopology S \<longleftrightarrow>
    S \<subseteq> M \<and> (\<forall>\<sigma> l. range \<sigma> \<subseteq> S \<and> limitin mtopology \<sigma> l sequentially \<longrightarrow> l \<in> S)" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
    by (force simp add: closedin_metric limitin_closedin range_subsetD)
next
  assume R: ?rhs
  show ?lhs
    unfolding closedin_metric
  proof (intro conjI strip)
    show "S \<subseteq> M"
      using R by blast
    fix x
    assume "x \<in> M - S"
    have False if "\<forall>r>0. \<exists>y. y \<in> M \<and> y \<in> S \<and> d x y < r"
    proof -
      have "\<forall>n. \<exists>y. y \<in> M \<and> y \<in> S \<and> d x y < inverse(Suc n)"
        using that by auto
      then obtain \<sigma> where \<sigma>: "\<And>n. \<sigma> n \<in> M \<and> \<sigma> n \<in> S \<and> d x (\<sigma> n) < inverse(Suc n)"
        by metis
      then have "range \<sigma> \<subseteq> M"
        by blast
      have "\<exists>N. \<forall>n\<ge>N. d x (\<sigma> n) < \<epsilon>" if "\<epsilon>>0" for \<epsilon>
      proof -
        have "real (Suc (nat \<lceil>inverse \<epsilon>\<rceil>)) \<ge> inverse \<epsilon>"
          by linarith
        then have "\<forall>n \<ge> nat \<lceil>inverse \<epsilon>\<rceil>. d x (\<sigma> n) < \<epsilon>"
          by (metis \<sigma> inverse_inverse_eq inverse_le_imp_le nat_ceiling_le_eq nle_le not_less_eq_eq order.strict_trans2 that)
        then show ?thesis ..
      qed
      with \<sigma> have "limitin mtopology \<sigma> x sequentially"
        using \<open>x \<in> M - S\<close> commute limit_metric_sequentially by auto
      then show ?thesis
        by (metis R DiffD2 \<sigma> image_subset_iff \<open>x \<in> M - S\<close>)
    qed
    then show "\<exists>r>0. disjnt S (mball x r)"
      by (meson disjnt_iff in_mball)
  qed
qed

lemma (in Metric_space) limit_atin_metric:
   "limitin X f y (atin mtopology x) \<longleftrightarrow>
      y \<in> topspace X \<and>
      (x \<in> M
       \<longrightarrow> (\<forall>V. openin X V \<and> y \<in> V
               \<longrightarrow> (\<exists>\<delta>>0.  \<forall>x'. x' \<in> M \<and> 0 < d x' x \<and> d x' x < \<delta> \<longrightarrow> f x' \<in> V)))"
  by (force simp add: limitin_def eventually_atin_metric)

lemma (in Metric_space) limitin_metric_dist_null:
   "limitin mtopology f l F \<longleftrightarrow> l \<in> M \<and> eventually (\<lambda>x. f x \<in> M) F \<and> ((\<lambda>x. d (f x) l) \<longlongrightarrow> 0) F"
  by (simp add: limitin_metric tendsto_iff eventually_conj_iff all_conj_distrib imp_conjR gt_ex)


subsection\<open>More sequential characterizations in a metric space\<close>

context Metric_space
begin

lemma submetric_empty [iff]: "submetric M d {}"
  by (simp add: Metric_space_axioms submetric.intro submetric_axioms_def)

definition decreasing_dist :: "(nat \<Rightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> bool"
    where "decreasing_dist \<sigma> x \<equiv> (\<forall>m n. m < n \<longrightarrow> d (\<sigma> n) x < d (\<sigma> m) x)"

lemma decreasing_dist_imp_inj: "decreasing_dist \<sigma> a \<Longrightarrow> inj \<sigma>"
  by (metis decreasing_dist_def dual_order.irrefl linorder_inj_onI')

lemma eventually_atin_within_metric:
   "eventually P (atin_within mtopology a S) \<longleftrightarrow>
    (a \<in> M \<longrightarrow> (\<exists>\<delta>>0. \<forall>x. x \<in> M \<and> x \<in> S \<and> 0 < d x a \<and> d x a < \<delta> \<longrightarrow> P x))" (is "?lhs=?rhs")
proof
  assume ?lhs then show ?rhs
unfolding eventually_atin_within openin_mtopology subset_iff
  by (metis commute in_mball mdist_refl order_less_irrefl topspace_mtopology)
next
  assume R: ?rhs 
  show ?lhs
  proof (cases "a \<in> M")
    case True
    then obtain \<delta> where "\<delta> > 0" and \<delta>: "\<And>x. \<lbrakk>x \<in> M; x \<in> S; 0 < d x a; d x a < \<delta>\<rbrakk> \<Longrightarrow> P x"
      using R by blast
    then have "openin mtopology (mball a \<delta>) \<and> (\<forall>x \<in> mball a \<delta>. x \<in> S \<and> x \<noteq> a \<longrightarrow> P x)"
      by (simp add: commute openin_mball)
    then show ?thesis
      by (metis True \<open>0 < \<delta>\<close> centre_in_mball_iff eventually_atin_within) 
  next
    case False
    with R show ?thesis
      by (simp add: eventually_atin_within)
  qed
qed


lemma eventually_atin_within_A:
  assumes 
    "(\<And>\<sigma>. \<lbrakk>range \<sigma> \<subseteq> (S \<inter> M) - {a}; decreasing_dist \<sigma> a;
          inj \<sigma>; limitin mtopology \<sigma> a sequentially\<rbrakk>
      \<Longrightarrow> eventually (\<lambda>n. P (\<sigma> n)) sequentially)"
  shows "eventually P (atin_within mtopology a S)"
proof -
  have False if SP: "\<And>\<delta>. \<delta>>0 \<Longrightarrow> \<exists>x \<in> M-{a}. d x a < \<delta> \<and> x \<in> S \<and> \<not> P x" and "a \<in> M"
  proof -
    define \<Phi> where "\<Phi> \<equiv> \<lambda>n x. x \<in> M-{a} \<and> d x a < inverse (Suc n) \<and> x \<in> S \<and> \<not> P x"
    obtain \<sigma> where \<sigma>: "\<And>n. \<Phi> n (\<sigma> n)" and dless: "\<And>n. d (\<sigma>(Suc n)) a < d (\<sigma> n) a"
    proof -
      obtain x0 where x0: "\<Phi> 0 x0"
        using SP [OF zero_less_one] by (force simp add: \<Phi>_def)
      have "\<exists>y. \<Phi> (Suc n) y \<and> d y a < d x a" if "\<Phi> n x" for n x
        using SP [of "min (inverse (Suc (Suc n))) (d x a)"] \<open>a \<in> M\<close> that
        by (auto simp add: \<Phi>_def)
      then obtain f where f: "\<And>n x. \<Phi> n x \<Longrightarrow> \<Phi> (Suc n) (f n x) \<and> d (f n x) a < d x a" 
        by metis
      show thesis
        proof
          show "\<Phi> n (rec_nat x0 f n)" for n
            by (induction n) (auto simp: x0 dest: f)
          with f show "d (rec_nat x0 f (Suc n)) a < d (rec_nat x0 f n) a" for n
            by auto 
        qed
    qed
    have 1: "range \<sigma> \<subseteq> (S \<inter> M) - {a}"
      using \<sigma> by (auto simp: \<Phi>_def)
    have "d (\<sigma>(Suc (m+n))) a < d (\<sigma> n) a" for m n
      by (induction m) (auto intro: order_less_trans dless)
    then have 2: "decreasing_dist \<sigma> a"
      unfolding decreasing_dist_def by (metis add.commute less_imp_Suc_add)
    have "\<forall>\<^sub>F xa in sequentially. d (\<sigma> xa) a < \<epsilon>" if "\<epsilon> > 0" for \<epsilon>
    proof -
      obtain N where "inverse (Suc N) < \<epsilon>"
        using \<open>\<epsilon> > 0\<close> reals_Archimedean by blast
      with \<sigma> 2 show ?thesis
        unfolding decreasing_dist_def by (smt (verit, best) \<Phi>_def eventually_at_top_dense)
    qed
    then have 4: "limitin mtopology \<sigma> a sequentially"
      using \<sigma> \<open>a \<in> M\<close> by (simp add: \<Phi>_def limitin_metric)
    show False
      using 2 assms [OF 1 _ decreasing_dist_imp_inj 4] \<sigma> by (force simp add: \<Phi>_def)
  qed
  then show ?thesis
    by (fastforce simp: eventually_atin_within_metric)
qed


lemma eventually_atin_within_B:
  assumes ev: "eventually P (atin_within mtopology a S)" 
    and ran: "range \<sigma> \<subseteq> (S \<inter> M) - {a}"
    and lim: "limitin mtopology \<sigma> a sequentially"
  shows "eventually (\<lambda>n. P (\<sigma> n)) sequentially"
proof -
  have "a \<in> M"
    using lim limitin_mspace by auto
  with ev obtain \<delta> where "0 < \<delta>" 
    and \<delta>: "\<And>\<sigma>. \<lbrakk>\<sigma> \<in> M; \<sigma> \<in> S; 0 < d \<sigma> a; d \<sigma> a < \<delta>\<rbrakk> \<Longrightarrow> P \<sigma>"
    by (auto simp: eventually_atin_within_metric)
  then have *: "\<And>n. \<sigma> n \<in> M \<and> d (\<sigma> n) a < \<delta> \<Longrightarrow> P (\<sigma> n)"
    using \<open>a \<in> M\<close> ran by auto
  have "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M \<and> d (\<sigma> n) a < \<delta>"
    using lim \<open>0 < \<delta>\<close> by (auto simp: limitin_metric)
  then show ?thesis
    by (simp add: "*" eventually_mono)
qed

lemma eventually_atin_within_sequentially:
     "eventually P (atin_within mtopology a S) \<longleftrightarrow>
        (\<forall>\<sigma>. range \<sigma> \<subseteq> (S \<inter> M) - {a} \<and>
            limitin mtopology \<sigma> a sequentially
            \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  by (metis eventually_atin_within_A eventually_atin_within_B)

lemma eventually_atin_within_sequentially_inj:
     "eventually P (atin_within mtopology a S) \<longleftrightarrow>
        (\<forall>\<sigma>. range \<sigma> \<subseteq> (S \<inter> M) - {a} \<and> inj \<sigma> \<and>
            limitin mtopology \<sigma> a sequentially
            \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  by (metis eventually_atin_within_A eventually_atin_within_B)

lemma eventually_atin_within_sequentially_decreasing:
     "eventually P (atin_within mtopology a S) \<longleftrightarrow>
        (\<forall>\<sigma>. range \<sigma> \<subseteq> (S \<inter> M) - {a} \<and> decreasing_dist \<sigma> a \<and>
            limitin mtopology \<sigma> a sequentially
            \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  by (metis eventually_atin_within_A eventually_atin_within_B)


lemma eventually_atin_sequentially:
   "eventually P (atin mtopology a) \<longleftrightarrow>
    (\<forall>\<sigma>. range \<sigma> \<subseteq> M - {a} \<and> limitin mtopology \<sigma> a sequentially
         \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  using eventually_atin_within_sequentially [where S=UNIV] by simp

lemma eventually_atin_sequentially_inj:
   "eventually P (atin mtopology a) \<longleftrightarrow>
    (\<forall>\<sigma>. range \<sigma> \<subseteq> M - {a} \<and> inj \<sigma> \<and>
        limitin mtopology \<sigma> a sequentially
        \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  using eventually_atin_within_sequentially_inj [where S=UNIV] by simp

lemma eventually_atin_sequentially_decreasing:
   "eventually P (atin mtopology a) \<longleftrightarrow>
    (\<forall>\<sigma>. range \<sigma> \<subseteq> M - {a} \<and> decreasing_dist \<sigma> a \<and>
         limitin mtopology \<sigma> a sequentially
        \<longrightarrow> eventually (\<lambda>n. P(\<sigma> n)) sequentially)"
  using eventually_atin_within_sequentially_decreasing [where S=UNIV] by simp

end

locale Metric_space12 = M1: Metric_space M1 d1 + M2: Metric_space M2 d2 for M1 d1 M2 d2
begin

lemma limit_atin_sequentially_within:
  "limitin M2.mtopology f l (atin_within M1.mtopology a S) \<longleftrightarrow>
     l \<in> M2 \<and>
     (\<forall>\<sigma>. range \<sigma> \<subseteq> S \<inter> M1 - {a} \<and>
          limitin M1.mtopology \<sigma> a sequentially
          \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
    by (auto simp add: M1.eventually_atin_within_sequentially limitin_def)

lemma limit_atin_sequentially_within_inj:
  "limitin M2.mtopology f l (atin_within M1.mtopology a S) \<longleftrightarrow>
     l \<in> M2 \<and>
     (\<forall>\<sigma>. range \<sigma> \<subseteq> S \<inter> M1 - {a} \<and> inj \<sigma> \<and>
          limitin M1.mtopology \<sigma> a sequentially
          \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
    by (auto simp add: M1.eventually_atin_within_sequentially_inj limitin_def)

lemma limit_atin_sequentially_within_decreasing:
  "limitin M2.mtopology f l (atin_within M1.mtopology a S) \<longleftrightarrow>
     l \<in> M2 \<and>
     (\<forall>\<sigma>. range \<sigma> \<subseteq> S \<inter> M1 - {a} \<and> M1.decreasing_dist \<sigma> a \<and> 
          limitin M1.mtopology \<sigma> a sequentially
          \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
    by (auto simp add: M1.eventually_atin_within_sequentially_decreasing limitin_def)

lemma limit_atin_sequentially:
   "limitin M2.mtopology f l (atin M1.mtopology a) \<longleftrightarrow>
        l \<in> M2 \<and>
        (\<forall>\<sigma>. range \<sigma> \<subseteq> M1 - {a} \<and>
            limitin M1.mtopology \<sigma> a sequentially
            \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
  using limit_atin_sequentially_within [where S=UNIV] by simp

lemma limit_atin_sequentially_inj:
   "limitin M2.mtopology f l (atin M1.mtopology a) \<longleftrightarrow>
        l \<in> M2 \<and>
        (\<forall>\<sigma>. range \<sigma> \<subseteq> M1 - {a} \<and> inj \<sigma> \<and>
            limitin M1.mtopology \<sigma> a sequentially
            \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
  using limit_atin_sequentially_within_inj [where S=UNIV] by simp

lemma limit_atin_sequentially_decreasing:
  "limitin M2.mtopology f l (atin M1.mtopology a) \<longleftrightarrow>
     l \<in> M2 \<and>
     (\<forall>\<sigma>. range \<sigma> \<subseteq> M1 - {a} \<and> M1.decreasing_dist \<sigma> a \<and> 
          limitin M1.mtopology \<sigma> a sequentially
          \<longrightarrow> limitin M2.mtopology (f \<circ> \<sigma>) l sequentially)"
  using limit_atin_sequentially_within_decreasing [where S=UNIV] by simp

end


context Metric_space
begin

lemma atin_within_imp_M:
   "atin_within mtopology x S \<noteq> bot \<Longrightarrow> x \<in> M"
  by (metis derived_set_of_trivial_limit in_derived_set_of topspace_mtopology)

lemma atin_within_sequentially_sequence:
  assumes "atin_within mtopology x S \<noteq> bot"
  obtains \<sigma> where "range \<sigma> \<subseteq> S \<inter> M - {x}" 
          "decreasing_dist \<sigma> x" "inj \<sigma>" "limitin mtopology \<sigma> x sequentially"
  by (metis eventually_atin_within_A eventually_False assms)

lemma derived_set_of_sequentially:
  "mtopology derived_set_of S =
   {x \<in> M. \<exists>\<sigma>. range \<sigma> \<subseteq> S \<inter> M - {x} \<and> limitin mtopology \<sigma> x sequentially}"
proof -
  have False
    if "range \<sigma> \<subseteq> S \<inter> M - {x}"
      and "limitin mtopology \<sigma> x sequentially"
      and "atin_within mtopology x S = bot"
    for x \<sigma>
  proof -
    have "\<forall>\<^sub>F n in sequentially. P (\<sigma> n)" for P
      using that by (metis eventually_atin_within_B eventually_bot)
    then show False
      by (meson eventually_False_sequentially eventually_mono)
  qed
  then show ?thesis
    using derived_set_of_trivial_limit 
    by (fastforce elim!: atin_within_sequentially_sequence intro: atin_within_imp_M)
qed

lemma derived_set_of_sequentially_alt:
  "mtopology derived_set_of S =
   {x. \<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> limitin mtopology \<sigma> x sequentially}"
proof -
  have *: "\<exists>\<sigma>. range \<sigma> \<subseteq> S \<inter> M - {x} \<and> limitin mtopology \<sigma> x sequentially"
    if \<sigma>: "range \<sigma> \<subseteq> S - {x}" and lim: "limitin mtopology \<sigma> x sequentially" for x \<sigma>
  proof -
    obtain N where "\<forall>n\<ge>N. \<sigma> n \<in> M \<and> d (\<sigma> n) x < 1"
      using lim limit_metric_sequentially by fastforce
    with \<sigma> obtain a where a:"a \<in> S \<inter> M - {x}" by auto
    show ?thesis
    proof (intro conjI exI)
      show "range (\<lambda>n. if \<sigma> n \<in> M then \<sigma> n else a) \<subseteq> S \<inter> M - {x}"
        using a \<sigma> by fastforce
      show "limitin mtopology (\<lambda>n. if \<sigma> n \<in> M then \<sigma> n else a) x sequentially"
        using lim limit_metric_sequentially by fastforce
    qed
  qed
  show ?thesis
    by (auto simp: limitin_mspace derived_set_of_sequentially intro!: *)
qed

lemma derived_set_of_sequentially_inj:
   "mtopology derived_set_of S =
    {x \<in> M. \<exists>\<sigma>. range \<sigma> \<subseteq> S \<inter> M - {x} \<and> inj \<sigma> \<and> limitin mtopology \<sigma> x sequentially}"
proof -
  have False
    if "x \<in> M" and "range \<sigma> \<subseteq> S \<inter> M - {x}"
      and "limitin mtopology \<sigma> x sequentially"
      and "atin_within mtopology x S = bot"
    for x \<sigma>
  proof -
    have "\<forall>\<^sub>F n in sequentially. P (\<sigma> n)" for P
      using that derived_set_of_sequentially_alt derived_set_of_trivial_limit by fastforce
    then show False
      by (meson eventually_False_sequentially eventually_mono)
  qed
  then show ?thesis
    using derived_set_of_trivial_limit 
    by (fastforce elim!: atin_within_sequentially_sequence intro: atin_within_imp_M)
qed


lemma derived_set_of_sequentially_inj_alt:
   "mtopology derived_set_of S =
    {x. \<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> inj \<sigma> \<and> limitin mtopology \<sigma> x sequentially}"
proof -
  have "\<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> inj \<sigma> \<and> limitin mtopology \<sigma> x sequentially"
    if "atin_within mtopology x S \<noteq> bot" for x
    by (metis Diff_empty Int_subset_iff atin_within_sequentially_sequence subset_Diff_insert that)
  moreover have False
    if "range (\<lambda>x. \<sigma> (x::nat)) \<subseteq> S - {x}"
      and "limitin mtopology \<sigma> x sequentially"
      and "atin_within mtopology x S = bot"
    for x \<sigma>
  proof -
    have "\<forall>\<^sub>F n in sequentially. P (\<sigma> n)" for P
      using that derived_set_of_sequentially_alt derived_set_of_trivial_limit by fastforce
    then show False
      by (meson eventually_False_sequentially eventually_mono)
  qed
  ultimately show ?thesis
    using derived_set_of_trivial_limit by (fastforce intro: atin_within_imp_M)
qed

lemma derived_set_of_sequentially_decreasing:
   "mtopology derived_set_of S =
    {x \<in> M. \<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> decreasing_dist \<sigma> x \<and> limitin mtopology \<sigma> x sequentially}"
proof -
  have "\<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> decreasing_dist \<sigma> x \<and> limitin mtopology \<sigma> x sequentially"
    if "atin_within mtopology x S \<noteq> bot" for x
    by (metis Diff_empty atin_within_sequentially_sequence le_infE subset_Diff_insert that)
  moreover have False
    if "x \<in> M" and "range \<sigma> \<subseteq> S - {x}"
      and "limitin mtopology \<sigma> x sequentially"
      and "atin_within mtopology x S = bot"
    for x \<sigma>
  proof -
    have "\<forall>\<^sub>F n in sequentially. P (\<sigma> n)" for P
      using that derived_set_of_sequentially_alt derived_set_of_trivial_limit by fastforce
    then show False
      by (meson eventually_False_sequentially eventually_mono)
  qed
  ultimately show ?thesis
    using derived_set_of_trivial_limit by (fastforce intro: atin_within_imp_M)
qed

lemma derived_set_of_sequentially_decreasing_alt:
   "mtopology derived_set_of S =
    {x. \<exists>\<sigma>. range \<sigma> \<subseteq> S - {x} \<and> decreasing_dist \<sigma> x \<and> limitin mtopology \<sigma> x sequentially}"
  using derived_set_of_sequentially_alt derived_set_of_sequentially_decreasing by auto

lemma closure_of_sequentially:
   "mtopology closure_of S = 
    {x \<in> M. \<exists>\<sigma>. range \<sigma> \<subseteq> S \<inter> M \<and> limitin mtopology \<sigma> x sequentially}"
  by (auto simp: closure_of derived_set_of_sequentially)

end (*Metric_space*)


subsection\<open>Cauchy sequences and complete metric spaces\<close>

context Metric_space
begin

definition MCauchy :: "(nat \<Rightarrow> 'a) \<Rightarrow> bool"
  where "MCauchy \<sigma> \<equiv> range \<sigma> \<subseteq> M \<and> (\<forall>\<epsilon>>0. \<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>)"

definition mcomplete
  where "mcomplete \<equiv> (\<forall>\<sigma>. MCauchy \<sigma> \<longrightarrow> (\<exists>x. limitin mtopology \<sigma> x sequentially))"

lemma mcomplete_empty [iff]: "Metric_space.mcomplete {} d"
  by (simp add: Metric_space.MCauchy_def Metric_space.mcomplete_def subspace)

lemma MCauchy_imp_MCauchy_suffix: "MCauchy \<sigma> \<Longrightarrow> MCauchy (\<sigma> \<circ> (+)n)"
  unfolding MCauchy_def image_subset_iff comp_apply
  by (metis UNIV_I add.commute trans_le_add1) 

lemma mcomplete:
   "mcomplete \<longleftrightarrow>
    (\<forall>\<sigma>. (\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M) \<and>
     (\<forall>\<epsilon>>0. \<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>) \<longrightarrow>
     (\<exists>x. limitin mtopology \<sigma> x sequentially))" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
  proof clarify
    fix \<sigma>
    assume "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M"
      and \<sigma>: "\<forall>\<epsilon>>0. \<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>"
    then obtain N where "\<And>n. n\<ge>N \<Longrightarrow> \<sigma> n \<in> M"
      by (auto simp add: eventually_sequentially)
    with \<sigma> have "MCauchy (\<sigma> \<circ> (+)N)"
      unfolding MCauchy_def image_subset_iff comp_apply by (meson le_add1 trans_le_add2)
    then obtain x where "limitin mtopology (\<sigma> \<circ> (+)N) x sequentially"
      using L MCauchy_imp_MCauchy_suffix mcomplete_def by blast
    then have "limitin mtopology \<sigma> x sequentially"
      unfolding o_def by (auto simp add: add.commute limitin_sequentially_offset_rev)
    then show "\<exists>x. limitin mtopology \<sigma> x sequentially" ..
  qed
qed (simp add: mcomplete_def MCauchy_def image_subset_iff)

lemma mcomplete_empty_mspace: "M = {} \<Longrightarrow> mcomplete"
  using MCauchy_def mcomplete_def by blast

lemma MCauchy_const [simp]: "MCauchy (\<lambda>n. a) \<longleftrightarrow> a \<in> M"
  using MCauchy_def mdist_refl by auto

lemma convergent_imp_MCauchy:
  assumes "range \<sigma> \<subseteq> M" and lim: "limitin mtopology \<sigma> l sequentially"
  shows "MCauchy \<sigma>"
  unfolding MCauchy_def image_subset_iff
proof (intro conjI strip)
  fix \<epsilon>::real
  assume "\<epsilon> > 0"
  then have "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M \<and> d (\<sigma> n) l < \<epsilon>/2"
    using half_gt_zero lim limitin_metric by blast
  then obtain N where "\<And>n. n\<ge>N \<Longrightarrow> \<sigma> n \<in> M \<and> d (\<sigma> n) l < \<epsilon>/2"
    by (force simp add: eventually_sequentially)
  then show "\<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>"
    by (smt (verit) Metric_space.limitin_mspace Metric_space.mdist_reverse_triangle Metric_space_axioms field_sum_of_halves lim)
qed (use assms in blast)


lemma mcomplete_alt:
   "mcomplete \<longleftrightarrow> (\<forall>\<sigma>. MCauchy \<sigma> \<longleftrightarrow> range \<sigma> \<subseteq> M \<and> (\<exists>x. limitin mtopology \<sigma> x sequentially))"
  using MCauchy_def convergent_imp_MCauchy mcomplete_def by blast

lemma MCauchy_subsequence:
  assumes "strict_mono r" "MCauchy \<sigma>"
  shows "MCauchy (\<sigma> \<circ> r)"
proof -
  have "d (\<sigma> (r n)) (\<sigma> (r n')) < \<epsilon>"
    if "N \<le> n" "N \<le> n'" "strict_mono r" "\<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>"
    for \<epsilon> N n n'
    using that by (meson le_trans strict_mono_imp_increasing)
  then show ?thesis
    using assms 
    by (simp add: MCauchy_def) blast
qed

lemma MCauchy_offset:
  assumes cau: "MCauchy (\<sigma> \<circ> (+)k)" and \<sigma>: "\<And>n. n < k \<Longrightarrow> \<sigma> n \<in> M" 
  shows "MCauchy \<sigma>"
  unfolding MCauchy_def image_subset_iff
proof (intro conjI strip)
  fix n
  show "\<sigma> n \<in> M"
    using assms
    unfolding MCauchy_def image_subset_iff
    by (metis UNIV_I comp_apply le_iff_add linorder_not_le)
next
  fix \<epsilon> :: real
  assume "\<epsilon> > 0"
  obtain N where "\<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d ((\<sigma> \<circ> (+)k) n) ((\<sigma> \<circ> (+)k) n') < \<epsilon>"
    using cau \<open>\<epsilon> > 0\<close> by (fastforce simp: MCauchy_def)
  then show "\<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>"
    unfolding o_def
    apply (rule_tac x="k+N" in exI)
    by (smt (verit, del_insts) add.assoc le_add1 less_eqE)
qed

lemma MCauchy_convergent_subsequence:
  assumes cau: "MCauchy \<sigma>" and "strict_mono r" 
     and lim: "limitin mtopology (\<sigma> \<circ> r) a sequentially"
  shows "limitin mtopology \<sigma> a sequentially"
  unfolding limitin_metric
proof (intro conjI strip)
  show "a \<in> M"
    by (meson assms limitin_mspace)
  fix \<epsilon> :: real
  assume "\<epsilon> > 0"
  then obtain N1 where N1: "\<And>n n'. \<lbrakk>n\<ge>N1; n'\<ge>N1\<rbrakk> \<Longrightarrow> d (\<sigma> n) (\<sigma> n') < \<epsilon>/2"
    using cau unfolding MCauchy_def by (meson half_gt_zero)
  obtain N2 where N2: "\<And>n. n \<ge> N2 \<Longrightarrow> (\<sigma> \<circ> r) n \<in> M \<and> d ((\<sigma> \<circ> r) n) a < \<epsilon>/2"
    by (metis (no_types, lifting) lim \<open>\<epsilon> > 0\<close> half_gt_zero limit_metric_sequentially)
  have "\<sigma> n \<in> M \<and> d (\<sigma> n) a < \<epsilon>" if "n \<ge> max N1 N2" for n
  proof (intro conjI)
    show "\<sigma> n \<in> M"
      using MCauchy_def cau by blast
    have "N1 \<le> r n"
      by (meson \<open>strict_mono r\<close> le_trans max.cobounded1 strict_mono_imp_increasing that)
    then show "d (\<sigma> n) a < \<epsilon>"
      using N1[of n "r n"] N2[of n] \<open>\<sigma> n \<in> M\<close> \<open>a \<in> M\<close> triangle that by fastforce
  qed
  then show "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M \<and> d (\<sigma> n) a < \<epsilon>"
    using eventually_sequentially by blast
qed

lemma MCauchy_interleaving_gen:
  "MCauchy (\<lambda>n. if even n then x(n div 2) else y(n div 2)) \<longleftrightarrow>
    (MCauchy x \<and> MCauchy y \<and> (\<lambda>n. d (x n) (y n)) \<longlonglongrightarrow> 0)" (is "?lhs=?rhs")
proof
  assume L: ?lhs
  have evens: "strict_mono (\<lambda>n::nat. 2 * n)" and odds: "strict_mono (\<lambda>n::nat. Suc (2 * n))"
    by (auto simp: strict_mono_def)
  show ?rhs
  proof (intro conjI)
    show "MCauchy x" "MCauchy y"
      using MCauchy_subsequence [OF evens L] MCauchy_subsequence [OF odds L] by (auto simp: o_def)
    show "(\<lambda>n. d (x n) (y n)) \<longlonglongrightarrow> 0"
      unfolding LIMSEQ_iff
    proof (intro strip)
      fix \<epsilon> :: real
      assume "\<epsilon> > 0"
      then obtain N where N: 
        "\<And>n n'. \<lbrakk>n\<ge>N; n'\<ge>N\<rbrakk> \<Longrightarrow> d (if even n then x (n div 2) else y (n div 2))
                                   (if even n' then x (n' div 2) else y (n' div 2))  < \<epsilon>"
        using L MCauchy_def by fastforce
      have "d (x n) (y n) < \<epsilon>" if "n\<ge>N" for n
        using N [of "2*n" "Suc(2*n)"] that by auto
      then show "\<exists>N. \<forall>n\<ge>N. norm (d (x n) (y n) - 0) < \<epsilon>"
        by auto
    qed
  qed
next
  assume R: ?rhs
  show ?lhs
    unfolding MCauchy_def
  proof (intro conjI strip)
    show "range (\<lambda>n. if even n then x (n div 2) else y (n div 2)) \<subseteq> M"
      using R by (auto simp: MCauchy_def)
    fix \<epsilon> :: real
    assume "\<epsilon> > 0"
    obtain Nx where Nx: "\<And>n n'. \<lbrakk>n\<ge>Nx; n'\<ge>Nx\<rbrakk> \<Longrightarrow> d (x n) (x n')  < \<epsilon>/2"
      by (meson half_gt_zero MCauchy_def R \<open>\<epsilon> > 0\<close>)
    obtain Ny where Ny: "\<And>n n'. \<lbrakk>n\<ge>Ny; n'\<ge>Ny\<rbrakk> \<Longrightarrow> d (y n) (y n')  < \<epsilon>/2"
      by (meson half_gt_zero MCauchy_def R \<open>\<epsilon> > 0\<close>)
    obtain Nxy where Nxy: "\<And>n. n\<ge>Nxy \<Longrightarrow> d (x n) (y n) < \<epsilon>/2"
      using R \<open>\<epsilon> > 0\<close> half_gt_zero unfolding LIMSEQ_iff
      by (metis abs_mdist diff_zero real_norm_def)
    define N where "N \<equiv> 2 * Max{Nx,Ny,Nxy}"
    show "\<exists>N. \<forall>n n'. N \<le> n \<longrightarrow> N \<le> n' \<longrightarrow> d (if even n then x (n div 2) else y (n div 2)) (if even n' then x (n' div 2) else y (n' div 2)) < \<epsilon>"
    proof (intro exI strip)
      fix n n'
      assume "N \<le> n" and "N \<le> n'"
      then have "n div 2 \<ge> Nx" "n div 2 \<ge> Ny" "n div 2 \<ge> Nxy" "n' div 2 \<ge> Nx" "n' div 2 \<ge> Ny" 
        by (auto simp: N_def)
      then have dxyn: "d (x (n div 2)) (y (n div 2)) < \<epsilon>/2" 
            and dxnn': "d (x (n div 2)) (x (n' div 2)) < \<epsilon>/2"
            and dynn': "d (y (n div 2)) (y (n' div 2)) < \<epsilon>/2"
        using Nx Ny Nxy by blast+
      have inM: "x (n div 2) \<in> M" "x (n' div 2) \<in> M""y (n div 2) \<in> M" "y (n' div 2) \<in> M"
        using Metric_space.MCauchy_def Metric_space_axioms R by blast+
      show "d (if even n then x (n div 2) else y (n div 2)) (if even n' then x (n' div 2) else y (n' div 2)) < \<epsilon>"
      proof (cases "even n")
        case nt: True
        show ?thesis
        proof (cases "even n'")
          case True
          with \<open>\<epsilon> > 0\<close> nt dxnn' show ?thesis by auto
        next
          case False
          with nt dxyn dynn' inM triangle show ?thesis
            by fastforce
        qed
      next
        case nf: False
        show ?thesis 
        proof (cases "even n'")
          case True
          then show ?thesis
            by (smt (verit) \<open>\<epsilon> > 0\<close> dxyn dxnn' triangle commute inM field_sum_of_halves)
        next
          case False
          with \<open>\<epsilon> > 0\<close> nf dynn' show ?thesis by auto
        qed
      qed
    qed
  qed
qed

lemma MCauchy_interleaving:
   "MCauchy (\<lambda>n. if even n then \<sigma>(n div 2) else a) \<longleftrightarrow>
    range \<sigma> \<subseteq> M \<and> limitin mtopology \<sigma> a sequentially"  (is "?lhs=?rhs")
proof -
  have "?lhs \<longleftrightarrow> (MCauchy \<sigma> \<and> a \<in> M \<and> (\<lambda>n. d (\<sigma> n) a) \<longlonglongrightarrow> 0)"
    by (simp add: MCauchy_interleaving_gen [where y = "\<lambda>n. a"])
  also have "... = ?rhs"
    by (metis MCauchy_def always_eventually convergent_imp_MCauchy limitin_metric_dist_null range_subsetD)
  finally show ?thesis .
qed

lemma mcomplete_nest:
   "mcomplete \<longleftrightarrow>
      (\<forall>C::nat \<Rightarrow>'a set. (\<forall>n. closedin mtopology (C n)) \<and>
          (\<forall>n. C n \<noteq> {}) \<and> decseq C \<and> (\<forall>\<epsilon>>0. \<exists>n a. C n \<subseteq> mcball a \<epsilon>)
          \<longrightarrow> \<Inter> (range C) \<noteq> {})" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
  proof (intro strip conjI , elim conjE)
    fix C :: "nat \<Rightarrow> 'a set"
    assume clo: "\<forall>n. closedin mtopology (C n)"
      and ne: "\<forall>n. C n \<noteq> ({}::'a set)"
      and dec: "decseq C"
      and cover [rule_format]: "\<forall>\<epsilon>>0. \<exists>n a. C n \<subseteq> mcball a \<epsilon>"
    obtain \<sigma> where \<sigma>: "\<And>n. \<sigma> n \<in> C n"
      by (meson ne empty_iff set_eq_iff)
    have "MCauchy \<sigma>"
      unfolding MCauchy_def
    proof (intro conjI strip)
      show "range \<sigma> \<subseteq> M"
        using \<sigma> clo metric_closedin_iff_sequentially_closed by auto 
      fix \<epsilon> :: real
      assume "\<epsilon> > 0"
      then obtain N a where N: "C N \<subseteq> mcball a (\<epsilon>/3)"
        using cover by fastforce
      have "d (\<sigma> m) (\<sigma> n) < \<epsilon>" if "N \<le> m" "N \<le> n" for m n
      proof -
        have "d a (\<sigma> m) \<le> \<epsilon>/3" "d a (\<sigma> n) \<le> \<epsilon>/3"
          using dec N \<sigma> that by (fastforce simp add: decseq_def)+
        then have "d (\<sigma> m) (\<sigma> n) \<le> \<epsilon>/3 + \<epsilon>/3"
          using triangle \<sigma> commute dec decseq_def subsetD that N
          by (smt (verit, ccfv_threshold) in_mcball)
        also have "... < \<epsilon>"
          using \<open>\<epsilon> > 0\<close> by auto
        finally show ?thesis .
      qed
      then show "\<exists>N. \<forall>m n. N \<le> m \<longrightarrow> N \<le> n \<longrightarrow> d (\<sigma> m) (\<sigma> n) < \<epsilon>"
        by blast
    qed
    then obtain x where x: "limitin mtopology \<sigma> x sequentially"
      using L mcomplete_def by blast
    have "x \<in> C n" for n
    proof (rule limitin_closedin [OF x])
      show "closedin mtopology (C n)"
        by (simp add: clo)
      show "\<forall>\<^sub>F x in sequentially. \<sigma> x \<in> C n"
        by (metis \<sigma> dec decseq_def eventually_sequentiallyI subsetD)
    qed auto
    then show "\<Inter> (range C) \<noteq> {}"
      by blast
qed
next
  assume R: ?rhs  
  show ?lhs
    unfolding mcomplete_def
  proof (intro strip)
    fix \<sigma>
    assume "MCauchy \<sigma>"
    then have "range \<sigma> \<subseteq> M"
      using MCauchy_def by blast
    define C where "C \<equiv> \<lambda>n. mtopology closure_of (\<sigma> ` {n..})"
    have "\<forall>n. closedin mtopology (C n)" 
      by (auto simp: C_def)
    moreover
    have ne: "\<And>n. C n \<noteq> {}"
      using \<open>MCauchy \<sigma>\<close> by (auto simp: C_def MCauchy_def disjnt_iff closure_of_eq_empty_gen)
    moreover
    have dec: "decseq C"
      unfolding monotone_on_def
    proof (intro strip)
      fix m n::nat
      assume "m \<le> n"
      then have "{n..} \<subseteq> {m..}"
        by auto
      then show "C n \<subseteq> C m"
        unfolding C_def by (meson closure_of_mono image_mono)
    qed
    moreover
    have C: "\<exists>N u. C N \<subseteq> mcball u \<epsilon>" if "\<epsilon>>0" for \<epsilon>
    proof -
      obtain N where "\<And>m n. N \<le> m \<and> N \<le> n \<Longrightarrow> d (\<sigma> m) (\<sigma> n) < \<epsilon>"
        by (meson MCauchy_def \<open>0 < \<epsilon>\<close> \<open>MCauchy \<sigma>\<close>)
      then have "\<sigma> ` {N..} \<subseteq> mcball (\<sigma> N) \<epsilon>"
        using MCauchy_def \<open>MCauchy \<sigma>\<close> by (force simp: less_eq_real_def)
      then have "C N \<subseteq> mcball (\<sigma> N) \<epsilon>"
        by (simp add: C_def closure_of_minimal)
      then show ?thesis
        by blast
    qed
    ultimately obtain l where x: "l \<in> \<Inter> (range C)"
      by (metis R ex_in_conv)
    then have *: "\<And>\<epsilon> N. 0 < \<epsilon> \<Longrightarrow> \<exists>n'. N \<le> n' \<and> l \<in> M \<and> \<sigma> n' \<in> M \<and> d l (\<sigma> n') < \<epsilon>"
      by (force simp add: C_def metric_closure_of)
    then have "l \<in> M"
      using gt_ex by blast
    show "\<exists>l. limitin mtopology \<sigma> l sequentially"
      unfolding limitin_metric
    proof (intro conjI strip exI)
      show "l \<in> M"
        using \<open>\<forall>n. closedin mtopology (C n)\<close> closedin_subset x by fastforce
      fix \<epsilon>::real
      assume "\<epsilon> > 0"
      obtain N where N: "\<And>m n. N \<le> m \<and> N \<le> n \<Longrightarrow> d (\<sigma> m) (\<sigma> n) < \<epsilon>/2"
        by (meson MCauchy_def \<open>0 < \<epsilon>\<close> \<open>MCauchy \<sigma>\<close> half_gt_zero)
      with * [of "\<epsilon>/2" N]
      have "\<forall>n\<ge>N. \<sigma> n \<in> M \<and> d (\<sigma> n) l < \<epsilon>"
        by (smt (verit) \<open>range \<sigma> \<subseteq> M\<close> commute field_sum_of_halves range_subsetD triangle)
      then show "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> M \<and> d (\<sigma> n) l < \<epsilon>"
        using eventually_sequentially by blast
    qed
  qed
qed


lemma mcomplete_nest_sing:
   "mcomplete \<longleftrightarrow>
    (\<forall>C. (\<forall>n. closedin mtopology (C n)) \<and>
          (\<forall>n. C n \<noteq> {}) \<and> decseq C \<and> (\<forall>e>0. \<exists>n a. C n \<subseteq> mcball a e)
         \<longrightarrow> (\<exists>l. l \<in> M \<and> \<Inter> (range C) = {l}))"
proof -
  have *: False
    if clo: "\<forall>n. closedin mtopology (C n)"
      and cover: "\<forall>\<epsilon>>0. \<exists>n a. C n \<subseteq> mcball a \<epsilon>"
      and no_sing: "\<And>y. y \<in> M \<Longrightarrow> \<Inter> (range C) \<noteq> {y}"
      and l: "\<forall>n. l \<in> C n"
    for C :: "nat \<Rightarrow> 'a set" and l
  proof -
    have inM: "\<And>x. x \<in> \<Inter> (range C) \<Longrightarrow> x \<in> M"
      using closedin_metric clo by fastforce
    then have "l \<in> M"
      by (simp add: l)
    have False if l': "l' \<in> \<Inter> (range C)" and "l' \<noteq> l" for l'
    proof -
      have "l' \<in> M"
        using inM l' by blast
      obtain n a where na: "C n \<subseteq> mcball a (d l l' / 3)"
        using inM \<open>l \<in> M\<close> l' \<open>l' \<noteq> l\<close> cover by force
      then have "d a l \<le> (d l l' / 3)" "d a l' \<le> (d l l' / 3)" "a \<in> M"
        using l l' na in_mcball by auto
      then have "d l l' \<le> (d l l' / 3) + (d l l' / 3)"
        using \<open>l \<in> M\<close> \<open>l' \<in> M\<close> mdist_reverse_triangle by fastforce
      then show False
        using nonneg [of l l'] \<open>l' \<noteq> l\<close> \<open>l \<in> M\<close> \<open>l' \<in> M\<close> zero by force
    qed
    then show False
      by (metis l \<open>l \<in> M\<close> no_sing INT_I empty_iff insertI1 is_singletonE is_singletonI')
  qed
  show ?thesis
    unfolding mcomplete_nest imp_conjL 
    apply (intro all_cong1 imp_cong refl)
    using * 
    by (smt (verit) Inter_iff ex_in_conv range_constant range_eqI)
qed

lemma mcomplete_fip:
   "mcomplete \<longleftrightarrow>
    (\<forall>\<C>. (\<forall>C \<in> \<C>. closedin mtopology C) \<and>
         (\<forall>e>0. \<exists>C a. C \<in> \<C> \<and> C \<subseteq> mcball a e) \<and> (\<forall>\<F>. finite \<F> \<and> \<F> \<subseteq> \<C> \<longrightarrow> \<Inter> \<F> \<noteq> {})
        \<longrightarrow> \<Inter> \<C> \<noteq> {})" 
   (is "?lhs = ?rhs")
proof
  assume L: ?lhs 
  show ?rhs
    unfolding mcomplete_nest_sing
  proof (intro strip, elim conjE)
    fix \<C> :: "'a set set"
    assume clo: "\<forall>C\<in>\<C>. closedin mtopology C"
      and cover: "\<forall>e>0. \<exists>C a. C \<in> \<C> \<and> C \<subseteq> mcball a e"
      and fip: "\<forall>\<F>. finite \<F> \<and> \<F> \<subseteq> \<C> \<longrightarrow> \<Inter> \<F> \<noteq> {}"
    then have "\<forall>n. \<exists>C. C \<in> \<C> \<and> (\<exists>a. C \<subseteq> mcball a (inverse (Suc n)))"
      by simp
    then obtain C where C: "\<And>n. C n \<in> \<C>" 
          and coverC: "\<And>n. \<exists>a. C n \<subseteq> mcball a (inverse (Suc n))"
      by metis
    define D where "D \<equiv> \<lambda>n. \<Inter> (C ` {..n})"
    have cloD: "closedin mtopology (D n)" for n
      unfolding D_def using clo C by blast
    have neD: "D n \<noteq> {}" for n
      using fip C by (simp add: D_def image_subset_iff)
    have decD: "decseq D"
      by (force simp: D_def decseq_def)
    have coverD: "\<exists>n a. D n \<subseteq> mcball a \<epsilon>" if " \<epsilon> >0" for \<epsilon>
    proof -
      obtain n where "inverse (Suc n) < \<epsilon>"
        using \<open>0 < \<epsilon>\<close> reals_Archimedean by blast
      then obtain a where "C n \<subseteq> mcball a \<epsilon>"
        by (meson coverC less_eq_real_def mcball_subset_concentric order_trans)
      then show ?thesis
        unfolding D_def by blast
    qed
    have *: "a \<in> \<Inter>\<C>" if a: "\<Inter> (range D) = {a}" and "a \<in> M" for a
    proof -
      have aC: "a \<in> C n" for n
        using that by (auto simp: D_def)
      have eqa: "\<And>u. (\<forall>n. u \<in> C n) \<Longrightarrow> a = u"
        using that by (auto simp: D_def)
      have "a \<in> T" if "T \<in> \<C>" for T
      proof -
        have cloT: "closedin mtopology (T \<inter> D n)" for n
          using clo cloD that by blast
        have "\<Inter> (insert T (C ` {..n})) \<noteq> {}" for n
          using that C by (intro fip [rule_format]) force
        then have neT: "T \<inter> D n \<noteq> {}" for n
          by (simp add: D_def)
        have decT: "decseq (\<lambda>n. T \<inter> D n)"
          by (force simp: D_def decseq_def)
        have coverT: "\<exists>n a. T \<inter> D n \<subseteq> mcball a \<epsilon>" if " \<epsilon> >0" for \<epsilon>
          by (meson coverD le_infI2 that)
        show ?thesis
          using L [unfolded mcomplete_nest_sing, rule_format, of "\<lambda>n. T \<inter> D n"] a
          by (force simp add: cloT neT decT coverT)
      qed
      then show ?thesis by auto
    qed
    show "\<Inter> \<C> \<noteq> {}"
      by (metis L cloD neD decD coverD * empty_iff mcomplete_nest_sing)
  qed
next
  assume R [rule_format]: ?rhs
  show ?lhs
    unfolding mcomplete_nest
  proof (intro strip, elim conjE)
    fix C :: "nat \<Rightarrow> 'a set"
    assume clo: "\<forall>n. closedin mtopology (C n)"
      and ne: "\<forall>n. C n \<noteq> {}"
      and dec: "decseq C"
      and cover: "\<forall>\<epsilon>>0. \<exists>n a. C n \<subseteq> mcball a \<epsilon>"
    have "\<Inter>(C ` N) \<noteq> {}" if "finite N" for N
    proof -
      obtain k where "N \<subseteq> {..k}"
        using \<open>finite N\<close> finite_nat_iff_bounded_le by auto
      with dec have "C k \<subseteq> \<Inter>(C ` N)" by (auto simp: decseq_def)
      then show ?thesis
        using ne by force
    qed
    with clo cover R [of "range C"] show "\<Inter> (range C) \<noteq> {}"
      by (metis (no_types, opaque_lifting) finite_subset_image image_iff UNIV_I)
  qed
qed


lemma mcomplete_fip_sing:
   "mcomplete \<longleftrightarrow>
    (\<forall>\<C>. (\<forall>C\<in>\<C>. closedin mtopology C) \<and>
     (\<forall>e>0. \<exists>c a. c \<in> \<C> \<and> c \<subseteq> mcball a e) \<and>
     (\<forall>\<F>. finite \<F> \<and> \<F> \<subseteq> \<C> \<longrightarrow> \<Inter> \<F> \<noteq> {}) \<longrightarrow>
     (\<exists>l. l \<in> M \<and> \<Inter> \<C> = {l}))"
   (is "?lhs = ?rhs")
proof
  have *: "l \<in> M" "\<Inter> \<C> = {l}"
    if clo: "Ball \<C> (closedin mtopology)"
      and cover: "\<forall>e>0. \<exists>C a. C \<in> \<C> \<and> C \<subseteq> mcball a e"
      and fin: "\<forall>\<F>. finite \<F> \<longrightarrow> \<F> \<subseteq> \<C> \<longrightarrow> \<Inter> \<F> \<noteq> {}"
      and l: "l \<in> \<Inter> \<C>"
    for \<C> :: "'a set set" and l
  proof -
    show "l \<in> M"
      by (meson Inf_lower2 clo cover gt_ex metric_closedin_iff_sequentially_closed subsetD that(4))
    show  "\<Inter> \<C> = {l}"
    proof (cases "\<C> = {}")
      case True
      then show ?thesis
        using cover mbounded_pos by auto
    next
      case False
      have CM: "\<And>a. a \<in> \<Inter>\<C> \<Longrightarrow> a \<in> M"
        using False clo closedin_subset by fastforce
      have "l' \<notin> \<Inter> \<C>" if "l' \<noteq> l" for l'
      proof 
        assume l': "l' \<in> \<Inter> \<C>"
        with CM have "l' \<in> M" by blast
        with that \<open>l \<in> M\<close> have gt0: "0 < d l l'"
          by simp
        then obtain C a where "C \<in> \<C>" and C: "C \<subseteq> mcball a (d l l' / 3)"
          using cover [rule_format, of "d l l' / 3"] by auto
        then have "d a l \<le> (d l l' / 3)" "d a l' \<le> (d l l' / 3)" "a \<in> M"
          using l l' in_mcball by auto
        then have "d l l' \<le> (d l l' / 3) + (d l l' / 3)"
          using \<open>l \<in> M\<close> \<open>l' \<in> M\<close> mdist_reverse_triangle by fastforce
        with gt0 show False by auto
      qed
      then show ?thesis
        using l by fastforce
    qed
  qed
  assume L: ?lhs
  with * show ?rhs
    unfolding mcomplete_fip imp_conjL ex_in_conv [symmetric]
    by (elim all_forward imp_forward2 asm_rl) (blast intro:  elim: )
next
  assume ?rhs then show ?lhs
    unfolding mcomplete_fip by (force elim!: all_forward)
qed

end

lemma MCauchy_iff_Cauchy [iff]: "Met.MCauchy = Cauchy"
  by (force simp add: Cauchy_def Met.MCauchy_def)

lemma mcomplete_iff_complete [iff]:
  "Met.mcomplete (Pure.type ::'a::metric_space itself) \<longleftrightarrow> complete (UNIV::'a set)"
  by (auto simp: Met.mcomplete_def complete_def)

lemma euclidean_metric: "Met.mcomplete (Pure.type ::'a::euclidean_space itself)"
  by blast

context submetric
begin 

lemma MCauchy_submetric:
   "sub.MCauchy \<sigma> \<longleftrightarrow> range \<sigma> \<subseteq> A \<and> MCauchy \<sigma>"
  using MCauchy_def sub.MCauchy_def subset by force

lemma closedin_mcomplete_imp_mcomplete:
  assumes clo: "closedin mtopology A" and "mcomplete"
  shows "sub.mcomplete"
  unfolding sub.mcomplete_def
proof (intro strip)
  fix \<sigma>
  assume "sub.MCauchy \<sigma>"
  then have \<sigma>: "MCauchy \<sigma>" "range \<sigma> \<subseteq> A"
    using MCauchy_submetric by blast+
  then obtain x where x: "limitin mtopology \<sigma> x sequentially"
    using \<open>mcomplete\<close> unfolding mcomplete_def by blast
  then have "x \<in> A"
    using \<sigma> clo metric_closedin_iff_sequentially_closed by force
  with \<sigma> x show "\<exists>x. limitin sub.mtopology \<sigma> x sequentially"
    using limitin_submetric_iff range_subsetD by fastforce
qed


lemma sequentially_closedin_mcomplete_imp_mcomplete:
  assumes "mcomplete" and "\<And>\<sigma> l. range \<sigma> \<subseteq> A \<and> limitin mtopology \<sigma> l sequentially \<Longrightarrow> l \<in> A"
  shows "sub.mcomplete"
  using assms closedin_mcomplete_imp_mcomplete metric_closedin_iff_sequentially_closed subset by blast

end


context Metric_space
begin

lemma mcomplete_Un:
  assumes A: "submetric M d A" "Metric_space.mcomplete A d" 
      and B: "submetric M d B" "Metric_space.mcomplete B d"
  shows   "submetric M d (A \<union> B)" "Metric_space.mcomplete (A \<union> B) d" 
proof -
  show "submetric M d (A \<union> B)"
    by (meson assms le_sup_iff submetric_axioms_def submetric_def) 
  then interpret MAB: Metric_space "A \<union> B" d
    by (meson submetric.subset subspace)
  interpret MA: Metric_space A d
    by (meson A submetric.subset subspace)
  interpret MB: Metric_space B d
    by (meson B submetric.subset subspace)
  show "Metric_space.mcomplete (A \<union> B) d"
    unfolding MAB.mcomplete_def
  proof (intro strip)
    fix \<sigma>
    assume "MAB.MCauchy \<sigma>"
    then have "range \<sigma> \<subseteq> A \<union> B"
      using MAB.MCauchy_def by blast
    then have "UNIV \<subseteq> \<sigma> -` A \<union> \<sigma> -` B"
      by blast
    then consider "infinite (\<sigma> -` A)" | "infinite (\<sigma> -` B)"
      using finite_subset by auto
    then show "\<exists>x. limitin MAB.mtopology \<sigma> x sequentially"
    proof cases
      case 1
      then obtain r where "strict_mono r" and r: "\<And>n::nat. r n \<in> \<sigma> -` A"
        using infinite_enumerate by blast 
      then have "MA.MCauchy (\<sigma> \<circ> r)"
        using MA.MCauchy_def MAB.MCauchy_def MAB.MCauchy_subsequence \<open>MAB.MCauchy \<sigma>\<close> by auto
      with A obtain x where "limitin MA.mtopology (\<sigma> \<circ> r) x sequentially"
        using MA.mcomplete_def by blast
      then have "limitin MAB.mtopology (\<sigma> \<circ> r) x sequentially"
        by (metis MA.limit_metric_sequentially MAB.limit_metric_sequentially UnCI)
      then show ?thesis
        using MAB.MCauchy_convergent_subsequence \<open>MAB.MCauchy \<sigma>\<close> \<open>strict_mono r\<close> by blast
    next
      case 2
      then obtain r where "strict_mono r" and r: "\<And>n::nat. r n \<in> \<sigma> -` B"
        using infinite_enumerate by blast 
      then have "MB.MCauchy (\<sigma> \<circ> r)"
        using MB.MCauchy_def MAB.MCauchy_def MAB.MCauchy_subsequence \<open>MAB.MCauchy \<sigma>\<close> by auto
      with B obtain x where "limitin MB.mtopology (\<sigma> \<circ> r) x sequentially"
        using MB.mcomplete_def by blast
      then have "limitin MAB.mtopology (\<sigma> \<circ> r) x sequentially"
        by (metis MB.limit_metric_sequentially MAB.limit_metric_sequentially UnCI)
      then show ?thesis
        using MAB.MCauchy_convergent_subsequence \<open>MAB.MCauchy \<sigma>\<close> \<open>strict_mono r\<close> by blast
    qed
  qed
qed

lemma mcomplete_Union:
  assumes "finite \<S>"
    and "\<And>A. A \<in> \<S> \<Longrightarrow> submetric M d A" "\<And>A. A \<in> \<S> \<Longrightarrow> Metric_space.mcomplete A d"
  shows   "submetric M d (\<Union>\<S>)" "Metric_space.mcomplete (\<Union>\<S>) d" 
  using assms
  by (induction rule: finite_induct) (auto simp: mcomplete_Un)

lemma mcomplete_Inter:
  assumes "finite \<S>" "\<S> \<noteq> {}"
    and sub: "\<And>A. A \<in> \<S> \<Longrightarrow> submetric M d A" 
    and comp: "\<And>A. A \<in> \<S> \<Longrightarrow> Metric_space.mcomplete A d"
  shows "submetric M d (\<Inter>\<S>)" "Metric_space.mcomplete (\<Inter>\<S>) d"
proof -
  show "submetric M d (\<Inter>\<S>)"
    using assms unfolding submetric_def submetric_axioms_def
    by (metis Inter_lower equals0I inf.orderE le_inf_iff) 
  then interpret MS: submetric M d "\<Inter>\<S>" 
    by (meson submetric.subset subspace)
  show "Metric_space.mcomplete (\<Inter>\<S>) d"
    unfolding MS.sub.mcomplete_def
  proof (intro strip)
    fix \<sigma>
    assume "MS.sub.MCauchy \<sigma>"
    then have "range \<sigma> \<subseteq> \<Inter>\<S>"
      using MS.MCauchy_submetric by blast
    obtain A where "A \<in> \<S>" and A: "Metric_space.mcomplete A d"
      using assms by blast
    then have "range \<sigma> \<subseteq> A"
      using \<open>range \<sigma> \<subseteq> \<Inter>\<S>\<close> by blast
    interpret SA: submetric M d A
      by (meson \<open>A \<in> \<S>\<close> sub submetric.subset subspace)
    have "MCauchy \<sigma>"
      using MS.MCauchy_submetric \<open>MS.sub.MCauchy \<sigma>\<close> by blast
    then obtain x where x: "limitin SA.sub.mtopology \<sigma> x sequentially"
      by (metis A SA.sub.MCauchy_def SA.sub.mcomplete_alt MCauchy_def \<open>range \<sigma> \<subseteq> A\<close>)
    show "\<exists>x. limitin MS.sub.mtopology \<sigma> x sequentially"
      apply (rule_tac x="x" in exI)
      unfolding MS.limitin_submetric_iff
    proof (intro conjI)
      show "x \<in> \<Inter> \<S>"
      proof clarsimp
        fix U
        assume "U \<in> \<S>"
        interpret SU: submetric M d U 
          by (meson \<open>U \<in> \<S>\<close> sub submetric.subset subspace)
        have "range \<sigma> \<subseteq> U"
          using \<open>U \<in> \<S>\<close> \<open>range \<sigma> \<subseteq> \<Inter> \<S>\<close> by blast
        moreover have "Metric_space.mcomplete U d"
          by (simp add: \<open>U \<in> \<S>\<close> comp)
        ultimately obtain x' where x': "limitin SU.sub.mtopology \<sigma> x' sequentially"
          using MCauchy_def SU.sub.MCauchy_def SU.sub.mcomplete_alt \<open>MCauchy \<sigma>\<close> by meson 
        have "x' = x"
        proof (intro limitin_metric_unique)
          show "limitin mtopology \<sigma> x' sequentially"
            by (meson SU.submetric_axioms submetric.limitin_submetric_iff x')
          show "limitin mtopology \<sigma> x sequentially"
            by (meson SA.submetric_axioms submetric.limitin_submetric_iff x)
        qed auto
        then show "x \<in> U"
          using SU.sub.limitin_mspace x' by blast
      qed
      show "\<forall>\<^sub>F n in sequentially. \<sigma> n \<in> \<Inter>\<S>"
        by (meson \<open>range \<sigma> \<subseteq> \<Inter> \<S>\<close> always_eventually range_subsetD)
      show "limitin mtopology \<sigma> x sequentially"
        by (meson SA.submetric_axioms submetric.limitin_submetric_iff x)
    qed
  qed
qed


lemma mcomplete_Int:
  assumes A: "submetric M d A" "Metric_space.mcomplete A d" 
      and B: "submetric M d B" "Metric_space.mcomplete B d"
    shows   "submetric M d (A \<inter> B)" "Metric_space.mcomplete (A \<inter> B) d"
  using mcomplete_Inter [of "{A,B}"] assms by force+


subsection\<open>Totally bounded subsets of metric spaces\<close>

definition mtotally_bounded 
  where "mtotally_bounded S \<equiv> \<forall>\<epsilon>>0. \<exists>K. finite K \<and> K \<subseteq> S \<and> S \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"

lemma mtotally_bounded_empty [iff]: "mtotally_bounded {}"
by (simp add: mtotally_bounded_def)

lemma finite_imp_mtotally_bounded:
   "\<lbrakk>finite S; S \<subseteq> M\<rbrakk> \<Longrightarrow> mtotally_bounded S"
  by (auto simp: mtotally_bounded_def)

lemma mtotally_bounded_imp_subset: "mtotally_bounded S \<Longrightarrow> S \<subseteq> M"
  by (force simp: mtotally_bounded_def intro!: zero_less_one)

lemma mtotally_bounded_sing [simp]:
   "mtotally_bounded {x} \<longleftrightarrow> x \<in> M"
  by (meson empty_subsetI finite.simps finite_imp_mtotally_bounded insert_subset mtotally_bounded_imp_subset)

lemma mtotally_bounded_Un:
  assumes  "mtotally_bounded S" "mtotally_bounded T"
  shows "mtotally_bounded (S \<union> T)"
proof -
  have "\<exists>K. finite K \<and> K \<subseteq> S \<union> T \<and> S \<union> T \<subseteq> (\<Union>x\<in>K. mball x e)"
    if  "e>0" and K: "finite K \<and> K \<subseteq> S \<and> S \<subseteq> (\<Union>x\<in>K. mball x e)"
      and L: "finite L \<and> L \<subseteq> T \<and> T \<subseteq> (\<Union>x\<in>L. mball x e)" for K L e
    using that by (rule_tac x="K \<union> L" in exI) auto
  with assms show ?thesis
    unfolding mtotally_bounded_def by presburger
qed
 
lemma mtotally_bounded_Union:
  assumes "finite f" "\<And>S. S \<in> f \<Longrightarrow> mtotally_bounded S"
  shows "mtotally_bounded (\<Union>f)"
  using assms by (induction f) (auto simp: mtotally_bounded_Un)

lemma mtotally_bounded_imp_mbounded:
  assumes "mtotally_bounded S"
  shows "mbounded S"
proof -
  obtain K where "finite K \<and> K \<subseteq> S \<and> S \<subseteq> (\<Union>x\<in>K. mball x 1)" 
    using assms by (force simp add: mtotally_bounded_def)
  then show ?thesis
    by (smt (verit) finite_imageI image_iff mbounded_Union mbounded_mball mbounded_subset)
qed


lemma mtotally_bounded_sequentially:
  "mtotally_bounded S \<longleftrightarrow>
    S \<subseteq> M \<and> (\<forall>\<sigma>::nat \<Rightarrow> 'a. range \<sigma> \<subseteq> S \<longrightarrow> (\<exists>r. strict_mono r \<and> MCauchy (\<sigma> \<circ> r)))"
  (is "_ \<longleftrightarrow> _ \<and> ?rhs")
proof (cases "S \<subseteq> M")
  case True
  show ?thesis
  proof -
    { fix \<sigma> :: "nat \<Rightarrow> 'a"                                                            
      assume L: "mtotally_bounded S" and \<sigma>: "range \<sigma> \<subseteq> S"
      have "\<exists>j > i. d (\<sigma> i) (\<sigma> j) < 3*\<epsilon>/2 \<and> infinite (\<sigma> -` mball (\<sigma> j) (\<epsilon>/2))"
        if inf: "infinite (\<sigma> -` mball (\<sigma> i) \<epsilon>)" and "\<epsilon> > 0" for i \<epsilon>
      proof -
        obtain K where "finite K" "K \<subseteq> S" and K: "S \<subseteq> (\<Union>x\<in>K. mball x (\<epsilon>/4))"
          by (metis L mtotally_bounded_def \<open>\<epsilon> > 0\<close> zero_less_divide_iff zero_less_numeral)
        then have K_imp_ex: "\<And>y. y \<in> S \<Longrightarrow> \<exists>x\<in>K. d x y < \<epsilon>/4"
          by fastforce
        have False if "\<forall>x\<in>K. d x (\<sigma> i) < \<epsilon> + \<epsilon>/4 \<longrightarrow> finite (\<sigma> -` mball x (\<epsilon>/4))"
        proof -
          have "\<exists>w. w \<in> K \<and> d w (\<sigma> i) < 5 * \<epsilon>/4 \<and> d w (\<sigma> j) < \<epsilon>/4"
            if "d (\<sigma> i) (\<sigma> j) < \<epsilon>" for j
          proof -
            obtain w where w: "d w (\<sigma> j) < \<epsilon>/4" "w \<in> K"
              using K_imp_ex \<sigma> by blast
            then have "d w (\<sigma> i) < \<epsilon> + \<epsilon>/4"
              by (smt (verit, ccfv_SIG) True \<open>K \<subseteq> S\<close> \<sigma> rangeI subset_eq that triangle')
            with w show ?thesis
              using in_mball by auto
          qed
          then have "(\<sigma> -` mball (\<sigma> i) \<epsilon>) \<subseteq> (\<Union>x\<in>K. if d x (\<sigma> i) < \<epsilon> + \<epsilon>/4 then \<sigma> -` mball x (\<epsilon>/4) else {})"
            using True \<open>K \<subseteq> S\<close> by force
          then show False
            using finite_subset inf \<open>finite K\<close> that by fastforce
        qed
        then obtain x where "x \<in> K" and dxi: "d x (\<sigma> i) < \<epsilon> + \<epsilon>/4" and infx: "infinite (\<sigma> -` mball x (\<epsilon>/4))"
          by blast
        then obtain j where "j \<in> ((\<sigma> -` mball x (\<epsilon>/4)) - {..i})"
          using bounded_nat_set_is_finite by (meson Diff_infinite_finite finite_atMost)
        then have "j > i" and dxj: "d x (\<sigma> j) < \<epsilon>/4" 
          by auto
        have "(\<sigma> -` mball x (\<epsilon>/4)) \<subseteq> (\<sigma> -` mball y (\<epsilon>/2))" if "d x y < \<epsilon>/4" "y \<in> M" for y
          using that by (simp add: mball_subset Metric_space_axioms vimage_mono)
        then have infj: "infinite (\<sigma> -` mball (\<sigma> j) (\<epsilon>/2))"
          by (meson True \<open>d x (\<sigma> j) < \<epsilon>/4\<close> \<sigma> in_mono infx rangeI finite_subset)
        have "\<sigma> i \<in> M" "\<sigma> j \<in> M" "x \<in> M"  
          using True \<open>K \<subseteq> S\<close> \<open>x \<in> K\<close> \<sigma> by force+
        then have "d (\<sigma> i) (\<sigma> j) \<le> d x (\<sigma> i) + d x (\<sigma> j)"
          using triangle'' by blast
        also have "\<dots> < 3*\<epsilon>/2"
          using dxi dxj by auto
        finally have "d (\<sigma> i) (\<sigma> j) < 3*\<epsilon>/2" .
        with \<open>i < j\<close> infj show ?thesis by blast
      qed
      then obtain nxt where nxt: "\<And>i \<epsilon>. \<lbrakk>\<epsilon> > 0; infinite (\<sigma> -` mball (\<sigma> i) \<epsilon>)\<rbrakk> \<Longrightarrow> 
                 nxt i \<epsilon> > i \<and> d (\<sigma> i) (\<sigma> (nxt i \<epsilon>)) < 3*\<epsilon>/2 \<and> infinite (\<sigma> -` mball (\<sigma> (nxt i \<epsilon>)) (\<epsilon>/2))"
        by metis
      have "mbounded S"
        using L by (simp add: mtotally_bounded_imp_mbounded)
      then obtain B where B: "\<forall>y \<in> S. d (\<sigma> 0) y \<le> B" and "B > 0"
        by (meson \<sigma> mbounded_alt_pos range_subsetD)
      define eps where "eps \<equiv> \<lambda>n. (B+1) / 2^n"
      have [simp]: "eps (Suc n) = eps n / 2" "eps n > 0" for n
        using \<open>B > 0\<close> by (auto simp add: eps_def)
      have "UNIV \<subseteq> \<sigma> -` mball (\<sigma> 0) (B+1)"
        using B True \<sigma> unfolding image_iff subset_iff
        by (smt (verit, best) UNIV_I in_mball vimageI)
      then have inf0: "infinite (\<sigma> -` mball (\<sigma> 0) (eps 0))"
        using finite_subset by (auto simp: eps_def)
      define r where "r \<equiv> rec_nat 0 (\<lambda>n rec. nxt rec (eps n))"
      have [simp]: "r 0 = 0" "r (Suc n) = nxt (r n) (eps n)" for n
        by (auto simp add: r_def)
      have \<sigma>rM[simp]: "\<sigma> (r n) \<in> M" for n
        using True \<sigma> by blast
      have inf: "infinite (\<sigma> -` mball (\<sigma> (r n)) (eps n))" for n
      proof (induction n)
        case 0 then show ?case  
          by (simp add: inf0)
      next
        case (Suc n) then show ?case
          using nxt [of "eps n" "r n"] by simp
      qed
      then have "r (Suc n) > r n" for n
        by (simp add: nxt)
      then have "strict_mono r"
        using strict_monoI_Suc by blast
      have d_less: "d (\<sigma> (r n)) (\<sigma> (r (Suc n))) < 3 * eps n / 2" for n
        using nxt [OF _ inf] by simp
      have eps_plus: "eps (k + n) = eps n * (1/2)^k" for k n
        by (simp add: eps_def power_add field_simps)
      have *: "d (\<sigma> (r n)) (\<sigma> (r (k + n))) < 3 * eps n" for n k
      proof -
        have "d (\<sigma> (r n)) (\<sigma> (r (k+n))) \<le> 3/2 * eps n * (\<Sum>i<k. (1/2)^i)"
        proof (induction k)
          case 0 then show ?case 
            by simp
        next
          case (Suc k)
          have "d (\<sigma> (r n)) (\<sigma> (r (Suc k + n))) \<le> d (\<sigma> (r n)) (\<sigma> (r (k + n))) + d (\<sigma> (r (k + n))) (\<sigma> (r (Suc (k + n))))"
            by (metis \<sigma>rM add.commute add_Suc_right triangle)
          with d_less[of "k+n"] Suc show ?case
            by (simp add: algebra_simps eps_plus)
        qed
        also have "\<dots> < 3/2 * eps n * 2"
          using geometric_sum [of "1/2::real" k] by simp
        finally show ?thesis by simp
      qed
      have "\<exists>N. \<forall>n\<ge>N. \<forall>n'\<ge>N. d (\<sigma> (r n)) (\<sigma> (r n')) < \<epsilon>" if "\<epsilon> > 0" for \<epsilon>
      proof -
        define N where "N \<equiv> nat \<lceil>(log 2 (6*(B+1) / \<epsilon>))\<rceil>"
        have \<section>: "b \<le> 2 ^ nat \<lceil>log 2 b\<rceil>" for b
          by (smt (verit) less_log_of_power real_nat_ceiling_ge)
        have N: "6 * eps N \<le> \<epsilon>"
          using \<section> [of "(6*(B+1) / \<epsilon>)"] that by (auto simp: N_def eps_def field_simps)
        have "d (\<sigma> (r N)) (\<sigma> (r n)) < 3 * eps N" if "n \<ge> N" for n
          by (metis * add.commute nat_le_iff_add that)
        then have "\<forall>n\<ge>N. \<forall>n'\<ge>N. d (\<sigma> (r n)) (\<sigma> (r n')) < 3 * eps N + 3 * eps N"
          by (smt (verit, best) \<sigma>rM triangle'')
        with N show ?thesis
          by fastforce
      qed
      then have "MCauchy (\<sigma> \<circ> r)"
        unfolding MCauchy_def using True \<sigma> by auto
      then have "\<exists>r. strict_mono r \<and> MCauchy (\<sigma> \<circ> r)"
        using \<open>strict_mono r\<close> by blast      
    }
    moreover
    { assume R: ?rhs
      have "mtotally_bounded S"
        unfolding mtotally_bounded_def
      proof (intro strip)
        fix \<epsilon> :: real
        assume "\<epsilon> > 0"
        have False if \<section>: "\<And>K. \<lbrakk>finite K; K \<subseteq> S\<rbrakk> \<Longrightarrow> \<exists>s\<in>S. s \<notin> (\<Union>x\<in>K. mball x \<epsilon>)"
        proof -
          obtain f where f: "\<And>K. \<lbrakk>finite K; K \<subseteq> S\<rbrakk> \<Longrightarrow> f K \<in> S \<and> f K \<notin> (\<Union>x\<in>K. mball x \<epsilon>)"
            using \<section> by metis
          define \<sigma> where "\<sigma> \<equiv> wfrec less_than (\<lambda>seq n. f (seq ` {..<n}))"
          have \<sigma>_eq: "\<sigma> n = f (\<sigma> ` {..<n})" for n
            by (simp add: cut_apply def_wfrec [OF \<sigma>_def])
          have [simp]: "\<sigma> n \<in> S" for n
            using wf_less_than
          proof (induction n rule: wf_induct_rule)
            case (less n) with f show ?case
              by (auto simp add: \<sigma>_eq [of n])
          qed
          then have "range \<sigma> \<subseteq> S" by blast
          have \<sigma>: "p < n \<Longrightarrow> \<epsilon> \<le> d (\<sigma> p) (\<sigma> n)" for n p
            using f[of "\<sigma> ` {..<n}"] True by (fastforce simp add: \<sigma>_eq [of n] Ball_def)
          then obtain r where "strict_mono r" "MCauchy (\<sigma> \<circ> r)"
            by (meson R \<open>range \<sigma> \<subseteq> S\<close>)
          with \<open>0 < \<epsilon>\<close> obtain N 
            where N: "\<And>n n'. \<lbrakk>n\<ge>N; n'\<ge>N\<rbrakk> \<Longrightarrow> d (\<sigma> (r n)) (\<sigma> (r n')) < \<epsilon>"
            by (force simp add: MCauchy_def)
          show ?thesis
            using N [of N "Suc (r N)"] \<open>strict_mono r\<close>
            by (smt (verit) Suc_le_eq \<sigma> le_SucI order_refl strict_mono_imp_increasing)
        qed
        then show "\<exists>K. finite K \<and> K \<subseteq> S \<and> S \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"
          by blast
      qed
    }
    ultimately show ?thesis 
      using True by blast
  qed
qed (use mtotally_bounded_imp_subset in auto)


lemma mtotally_bounded_subset:
   "\<lbrakk>mtotally_bounded S; T \<subseteq> S\<rbrakk> \<Longrightarrow> mtotally_bounded T"
  by (meson mtotally_bounded_sequentially order_trans) 

lemma mtotally_bounded_submetric:
  assumes "mtotally_bounded S" "S \<subseteq> T" "T \<subseteq> M"
  shows "Metric_space.mtotally_bounded T d S"
proof -
  interpret submetric M d T
    by (simp add: Metric_space_axioms assms submetric.intro submetric_axioms.intro)
  show ?thesis
    using assms
    unfolding sub.mtotally_bounded_def mtotally_bounded_def
    by (force simp: subset_iff elim!: all_forward ex_forward)
qed

lemma mtotally_bounded_absolute:
   "mtotally_bounded S \<longleftrightarrow> S \<subseteq> M \<and> Metric_space.mtotally_bounded S d S "
proof -
  have "mtotally_bounded S" if "S \<subseteq> M" "Metric_space.mtotally_bounded S d S"
  proof -
    interpret submetric M d S
      by (simp add: Metric_space_axioms submetric_axioms.intro submetric_def \<open>S \<subseteq> M\<close>)
    show ?thesis
      using that
      by (metis MCauchy_submetric Metric_space.mtotally_bounded_sequentially Metric_space_axioms subspace)
  qed
  moreover have "mtotally_bounded S \<Longrightarrow> Metric_space.mtotally_bounded S d S"
    by (simp add: mtotally_bounded_imp_subset mtotally_bounded_submetric)
  ultimately show ?thesis
    using mtotally_bounded_imp_subset by blast
qed

lemma mtotally_bounded_closure_of:
  assumes "mtotally_bounded S"
  shows "mtotally_bounded (mtopology closure_of S)"
proof -
  have "S \<subseteq> M"
    by (simp add: assms mtotally_bounded_imp_subset)
  have "mtotally_bounded(mtopology closure_of S)"
    unfolding mtotally_bounded_def
  proof (intro strip)
    fix \<epsilon>::real
    assume "\<epsilon> > 0"
    then obtain K where "finite K" "K \<subseteq> S" and K: "S \<subseteq> (\<Union>x\<in>K. mball x (\<epsilon>/2))"
      by (metis assms mtotally_bounded_def half_gt_zero)
    have "mtopology closure_of S \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"
      unfolding metric_closure_of
    proof clarsimp
      fix x
      assume "x \<in> M" and x: "\<forall>r>0. \<exists>y\<in>S. y \<in> M \<and> d x y < r"
      then obtain y where "y \<in> S" and y: "d x y < \<epsilon>/2"
        using \<open>0 < \<epsilon>\<close> half_gt_zero by blast
      then obtain x' where "x' \<in> K" "y \<in> mball x' (\<epsilon>/2)"
        using K by auto
      then have "d x' x < \<epsilon>/2 + \<epsilon>/2"
        using triangle y \<open>x \<in> M\<close> commute by fastforce
      then show "\<exists>x'\<in>K. x' \<in> M \<and> d x' x < \<epsilon>"
        using \<open>K \<subseteq> S\<close> \<open>S \<subseteq> M\<close> \<open>x' \<in> K\<close> by force
    qed
    then show "\<exists>K. finite K \<and> K \<subseteq> mtopology closure_of S \<and> mtopology closure_of S \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"
      using closure_of_subset_Int  \<open>K \<subseteq> S\<close> \<open>finite K\<close> K by fastforce
  qed
  then show ?thesis
    by (simp add: assms inf.absorb2 mtotally_bounded_imp_subset)
qed

lemma mtotally_bounded_closure_of_eq:
   "S \<subseteq> M \<Longrightarrow> mtotally_bounded (mtopology closure_of S) \<longleftrightarrow> mtotally_bounded S"
  by (metis closure_of_subset mtotally_bounded_closure_of mtotally_bounded_subset topspace_mtopology)

lemma mtotally_bounded_cauchy_sequence:
  assumes "MCauchy \<sigma>"
  shows "mtotally_bounded (range \<sigma>)"
  unfolding MCauchy_def mtotally_bounded_def
proof (intro strip)
  fix \<epsilon>::real
  assume "\<epsilon> > 0"
  then obtain N where "\<And>n. N \<le> n \<Longrightarrow> d (\<sigma> N) (\<sigma> n) < \<epsilon>"
    using assms by (force simp add: MCauchy_def)
  then have "\<And>m. \<exists>n\<le>N. \<sigma> n \<in> M \<and> \<sigma> m \<in> M \<and> d (\<sigma> n) (\<sigma> m) < \<epsilon>"
    by (metis MCauchy_def assms mdist_refl nle_le range_subsetD)
  then
  show "\<exists>K. finite K \<and> K \<subseteq> range \<sigma> \<and> range \<sigma> \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"
    by (rule_tac x="\<sigma> ` {0..N}" in exI) force
qed

lemma MCauchy_imp_mbounded:
   "MCauchy \<sigma> \<Longrightarrow> mbounded (range \<sigma>)"
  by (simp add: mtotally_bounded_cauchy_sequence mtotally_bounded_imp_mbounded)


subsection\<open>Compactness in metric spaces\<close>

lemma Bolzano_Weierstrass_property:
  assumes "S \<subseteq> U" "S \<subseteq> M"
  shows
   "(\<forall>\<sigma>::nat\<Rightarrow>'a. range \<sigma> \<subseteq> S
         \<longrightarrow> (\<exists>l r. l \<in> U \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially)) \<longleftrightarrow>
    (\<forall>T. T \<subseteq> S \<and> infinite T \<longrightarrow> U \<inter> mtopology derived_set_of T \<noteq> {})"  (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
  proof clarify
    fix T
    assume "T \<subseteq> S" and "infinite T"
      and T: "U \<inter> mtopology derived_set_of T = {}"
    then obtain \<sigma> :: "nat\<Rightarrow>'a" where "inj \<sigma>" "range \<sigma> \<subseteq> T"
      by (meson infinite_countable_subset)
    with L obtain l r where "l \<in> U" "strict_mono r" 
           and lr: "limitin mtopology (\<sigma> \<circ> r) l sequentially"
      by (meson \<open>T \<subseteq> S\<close> subset_trans)
    then obtain \<epsilon> where "\<epsilon> > 0" and \<epsilon>: "\<And>y. y \<in> T \<Longrightarrow> y = l \<or> \<not> d l y < \<epsilon>"
      using T \<open>T \<subseteq> S\<close> \<open>S \<subseteq> M\<close> 
      by (force simp add: metric_derived_set_of limitin_metric disjoint_iff)
    with lr have "\<forall>\<^sub>F n in sequentially. \<sigma> (r n) \<in> M \<and> d (\<sigma> (r n)) l < \<epsilon>"
      by (auto simp: limitin_metric)
    then obtain N where N: "d (\<sigma> (r N)) l < \<epsilon>" "d (\<sigma> (r (Suc N))) l < \<epsilon>"
      using less_le_not_le by (auto simp: eventually_sequentially)
    moreover have "\<sigma> (r N) \<noteq> l \<or> \<sigma> (r (Suc N)) \<noteq> l"
      by (meson \<open>inj \<sigma>\<close> \<open>strict_mono r\<close> injD n_not_Suc_n strict_mono_eq)
    ultimately
    show False
       using \<epsilon> \<open>range \<sigma> \<subseteq> T\<close> commute by fastforce
  qed
next
  assume R: ?rhs 
  show ?lhs
  proof (intro strip)
    fix \<sigma> :: "nat \<Rightarrow> 'a"
    assume "range \<sigma> \<subseteq> S"
    show "\<exists>l r. l \<in> U \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially"
    proof (cases "finite (range \<sigma>)")
      case True
      then obtain m where "infinite (\<sigma> -` {\<sigma> m})"
        by (metis image_iff inf_img_fin_dom nat_not_finite)
      then obtain r where [iff]: "strict_mono r" and r: "\<And>n::nat. r n \<in> \<sigma> -` {\<sigma> m}"
        using infinite_enumerate by blast 
      have [iff]: "\<sigma> m \<in> U" "\<sigma> m \<in> M"
        using \<open>range \<sigma> \<subseteq> S\<close> assms by blast+
      show ?thesis
      proof (intro conjI exI)
        show "limitin mtopology (\<sigma> \<circ> r) (\<sigma> m) sequentially"
          using r by (simp add: limitin_metric)
      qed auto
    next
      case False
      then obtain l where "l \<in> U" and l: "l \<in> mtopology derived_set_of (range \<sigma>)"
        by (meson R \<open>range \<sigma> \<subseteq> S\<close> disjoint_iff)
      then obtain g where g: "\<And>\<epsilon>. \<epsilon>>0 \<Longrightarrow> \<sigma> (g \<epsilon>) \<noteq> l \<and> d l (\<sigma> (g \<epsilon>)) < \<epsilon>"
        by (simp add: metric_derived_set_of) metis
      have "range \<sigma> \<subseteq> M"
        using \<open>range \<sigma> \<subseteq> S\<close> assms by auto
      have "l \<in> M"
        using derived_set_of_sequentially_decreasing l by blast
      define E where  \<comment>\<open>a construction to ensure monotonicity\<close>
        "E \<equiv> \<lambda>rec n. insert (inverse (Suc n)) ((\<lambda>i. d l (\<sigma> i)) ` (\<Union>k<n. {0..rec k})) - {0}"
      define r where "r \<equiv> wfrec less_than (\<lambda>rec n. g (Min (E rec n)))"
      have "(\<Union>k<n. {0..cut r less_than n k}) = (\<Union>k<n. {0..r k})" for n
        by (auto simp: cut_apply)
      then have r_eq: "r n = g (Min (E r n))" for n
        by (metis E_def def_wfrec [OF r_def] wf_less_than)
      have dl_pos[simp]: "d l (\<sigma> (r n)) > 0" for n
        using wf_less_than
      proof (induction n rule: wf_induct_rule)
        case (less n) 
        then have *: "Min (E r n) > 0"
          using \<open>l \<in> M\<close> \<open>range \<sigma> \<subseteq> M\<close> by (auto simp add: E_def image_subset_iff)
        show ?case
          using g [OF *] r_eq [of n]
          by (metis \<open>l \<in> M\<close> \<open>range \<sigma> \<subseteq> M\<close> mdist_pos_less range_subsetD)
      qed
      then have non_l: "\<sigma> (r n) \<noteq> l" for n
        using \<open>range \<sigma> \<subseteq> M\<close> mdist_pos_eq by blast
      have Min_pos: "Min (E r n) > 0" for n
        using dl_pos \<open>l \<in> M\<close> \<open>range \<sigma> \<subseteq> M\<close> by (auto simp: E_def image_subset_iff)
      have d_small: "d (\<sigma>(r n)) l < inverse(Suc n)" for n
      proof -
        have "d (\<sigma>(r n)) l < Min (E r n)"
          by (simp add: \<open>0 < Min (E r n)\<close> commute g r_eq) 
        also have "... \<le> inverse(Suc n)"
          by (simp add: E_def)
        finally show ?thesis .
      qed
      have DD: "d l (\<sigma> (r n)) < d l (\<sigma> i)" if \<section>: "p < n" "i \<le> r p" "\<sigma> i \<noteq> l" for i p n
      proof -
        have 1: "d l (\<sigma> i) \<in> E r n"
          using \<section> \<open>l \<in> M\<close> \<open>range \<sigma> \<subseteq> M\<close> 
          by (force simp: E_def image_subset_iff image_iff)
        have "d l (\<sigma> (g (Min (E r n)))) < Min (E r n)"
          by (rule conjunct2 [OF g [OF Min_pos]])
        also have "Min (E r n) \<le> d l (\<sigma> i)"
          using 1 unfolding E_def by (force intro!: Min.coboundedI)
        finally show ?thesis
          by (simp add: r_eq) 
      qed
      have r: "r p < r n" if "p < n" for p n
        using DD [OF that] non_l by (meson linorder_not_le order_less_irrefl) 
      show ?thesis
      proof (intro exI conjI)
        show "strict_mono r"
          by (simp add: r strict_monoI)
        show "limitin mtopology (\<sigma> \<circ> r) l sequentially"
          unfolding limitin_metric
        proof (intro conjI strip)
          show "l \<in> M"
            using derived_set_of_sequentially_inj l by blast
          fix \<epsilon> :: real
          assume "\<epsilon> > 0"
          then have "\<forall>\<^sub>F n in sequentially. inverse(Suc n) < \<epsilon>"
            using Archimedean_eventually_inverse by auto
          then show "\<forall>\<^sub>F n in sequentially. (\<sigma> \<circ> r) n \<in> M \<and> d ((\<sigma> \<circ> r) n) l < \<epsilon>"
            by (smt (verit) \<open>range \<sigma> \<subseteq> M\<close> commute comp_apply d_small eventually_mono range_subsetD)
        qed
      qed (use \<open>l \<in> U\<close> in auto)
    qed
  qed
qed

lemma A: 
  assumes "compactin mtopology S" "T \<subseteq> S" "infinite T"
  shows "S \<inter> mtopology derived_set_of T \<noteq> {}"
  by (simp add: assms compactin_imp_Bolzano_Weierstrass)

lemma B:
  fixes \<sigma> :: "nat \<Rightarrow> 'a"
  assumes "S \<subseteq> M" "range \<sigma> \<subseteq> S"
    and "\<And>T. \<lbrakk>T \<subseteq> S \<and> infinite T\<rbrakk> \<Longrightarrow> S \<inter> mtopology derived_set_of T \<noteq> {}"
  shows "\<exists>l r. l \<in> S \<and> strict_mono r \<and> limitin mtopology (\<sigma> o r) l sequentially"
  using Bolzano_Weierstrass_property assms by blast

lemma C:
  assumes "S \<subseteq> M"
  assumes "\<And>\<sigma>:: nat \<Rightarrow> 'a. range \<sigma> \<subseteq> S \<Longrightarrow>
                (\<exists>l r. l \<in> S \<and> strict_mono r \<and> limitin mtopology (\<sigma> o r) l sequentially)"
  shows "mtotally_bounded S"
  unfolding mtotally_bounded_sequentially
  by (metis convergent_imp_MCauchy assms image_comp image_mono subset_UNIV subset_trans)

lemma D:
  assumes "S \<subseteq> M" "S \<subseteq> \<Union>\<C>" and opeU: "\<And>U. U \<in> \<C> \<Longrightarrow> openin mtopology U"
  assumes \<section>: "(\<forall>\<sigma>::nat\<Rightarrow>'a. range \<sigma> \<subseteq> S
         \<longrightarrow> (\<exists>l r. l \<in> S \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially))"
  shows "\<exists>\<epsilon>>0. \<forall>x \<in> S. \<exists>U \<in> \<C>. mball x \<epsilon> \<subseteq> U"
proof (rule ccontr)
  assume "\<not> (\<exists>\<epsilon>>0. \<forall>x \<in> S. \<exists>U \<in> \<C>. mball x \<epsilon> \<subseteq> U)"
  then have "\<forall>n. \<exists>x\<in>S. \<forall>U\<in>\<C>. \<not> mball x (inverse (Suc n)) \<subseteq> U"
    by simp
  then obtain \<sigma> where "\<And>n. \<sigma> n \<in> S" 
       and \<sigma>: "\<And>n U. U \<in> \<C> \<Longrightarrow> \<not> mball (\<sigma> n) (inverse (Suc n)) \<subseteq> U"
    by metis
  then obtain l r where "l \<in> S" "strict_mono r" 
         and lr: "limitin mtopology (\<sigma> \<circ> r) l sequentially"
    by (meson \<section> image_subsetI)
  with \<open>S \<subseteq> \<Union>\<C>\<close> obtain B where "l \<in> B" "B \<in> \<C>"
    by auto
  then obtain \<epsilon> where "\<epsilon> > 0" and \<epsilon>: "\<And>z. \<lbrakk>z \<in> M; d z l < \<epsilon>\<rbrakk> \<Longrightarrow> z \<in> B"
    by (metis opeU [OF \<open>B \<in> \<C>\<close>] commute in_mball openin_mtopology subset_iff)
  then have "\<forall>\<^sub>F n in sequentially. \<sigma> (r n) \<in> M \<and> d (\<sigma> (r n)) l < \<epsilon>/2"
    using lr half_gt_zero unfolding limitin_metric o_def by blast
  moreover have "\<forall>\<^sub>F n in sequentially. inverse (real (Suc n)) < \<epsilon>/2"
    using Archimedean_eventually_inverse \<open>0 < \<epsilon>\<close> half_gt_zero by blast
  ultimately obtain n where n: "d (\<sigma> (r n)) l < \<epsilon>/2" "inverse (real (Suc n)) < \<epsilon>/2"
    by (smt (verit, del_insts) eventually_sequentially le_add1 le_add2)
  have "x \<in> B" if "d (\<sigma> (r n)) x < inverse (Suc(r n))" "x \<in> M" for x
  proof -
    have rle: "inverse (real (Suc (r n))) \<le> inverse (real (Suc n))"
      using \<open>strict_mono r\<close> strict_mono_imp_increasing by auto
    have "d x l \<le> d (\<sigma> (r n)) x + d (\<sigma> (r n)) l"
      using that by (metis triangle \<open>\<And>n. \<sigma> n \<in> S\<close> \<open>l \<in> S\<close> \<open>S \<subseteq> M\<close> commute subsetD)
    also have "... < \<epsilon>"
      using that n rle by linarith
    finally show ?thesis
      by (simp add: \<epsilon> that)
  qed
  then show False
    using \<sigma> [of B "r n"] by (simp add: \<open>B \<in> \<C>\<close> subset_iff)
qed


lemma E:
  assumes "mtotally_bounded S" "S \<subseteq> M"
  and S: "\<And>\<C>. \<lbrakk>\<And>U. U \<in> \<C> \<Longrightarrow> openin mtopology U; S \<subseteq> \<Union>\<C>\<rbrakk> \<Longrightarrow> \<exists>\<epsilon>>0. \<forall>x \<in> S. \<exists>U \<in> \<C>. mball x \<epsilon> \<subseteq> U"
  shows "compactin mtopology S"
proof (clarsimp simp add: compactin_def assms)
  fix \<U> :: "'a set set"
  assume \<U>: "\<forall>x\<in>\<U>. openin mtopology x" and "S \<subseteq> \<Union> \<U>"
  then obtain \<epsilon> where "\<epsilon>>0" and \<epsilon>: "\<And>x. x \<in> S \<Longrightarrow> \<exists>U \<in> \<U>. mball x \<epsilon> \<subseteq> U"
    by (metis S)
  then obtain f where f: "\<And>x. x \<in> S \<Longrightarrow> f x \<in> \<U> \<and> mball x \<epsilon> \<subseteq> f x"
    by metis
  then obtain K where "finite K" "K \<subseteq> S" and K: "S \<subseteq> (\<Union>x\<in>K. mball x \<epsilon>)"
    by (metis \<open>0 < \<epsilon>\<close> \<open>mtotally_bounded S\<close> mtotally_bounded_def)
  show "\<exists>\<F>. finite \<F> \<and> \<F> \<subseteq> \<U> \<and> S \<subseteq> \<Union> \<F>"
  proof (intro conjI exI)
    show "finite (f ` K)"
      by (simp add: \<open>finite K\<close>)
    show "f ` K \<subseteq> \<U>"
      using \<open>K \<subseteq> S\<close> f by blast
    show "S \<subseteq> \<Union> (f ` K)"
      using K \<open>K \<subseteq> S\<close> by (force dest: f)
  qed
qed


lemma compactin_eq_Bolzano_Weierstrass:
  "compactin mtopology S \<longleftrightarrow>
   S \<subseteq> M \<and> (\<forall>T. T \<subseteq> S \<and> infinite T \<longrightarrow> S \<inter> mtopology derived_set_of T \<noteq> {})"
  using C D E
  by (smt (verit, del_insts) Bolzano_Weierstrass_property Set.basic_monos(1) compactin_imp_Bolzano_Weierstrass compactin_subspace topspace_mtopology)

lemma compactin_sequentially:
  shows "compactin mtopology S \<longleftrightarrow>
        S \<subseteq> M \<and>
        ((\<forall>\<sigma>::nat\<Rightarrow>'a. range \<sigma> \<subseteq> S
         \<longrightarrow> (\<exists>l r. l \<in> S \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially)))"
  by (metis Bolzano_Weierstrass_property compactin_eq_Bolzano_Weierstrass subset_refl)

lemma compactin_imp_mtotally_bounded: 
  "compactin mtopology S \<Longrightarrow> mtotally_bounded S"
  by (simp add: C compactin_sequentially)

lemma lebesgue_number:
    "\<lbrakk>compactin mtopology S; S \<subseteq> \<Union>\<C>; \<And>U. U \<in> \<C> \<Longrightarrow> openin mtopology U\<rbrakk>
    \<Longrightarrow> \<exists>\<epsilon>>0. \<forall>x \<in> S. \<exists>U \<in> \<C>. mball x \<epsilon> \<subseteq> U"
  by (simp add: D compactin_sequentially)

lemma compact_space_sequentially:
   "compact_space mtopology \<longleftrightarrow>
    (\<forall>\<sigma>::nat\<Rightarrow>'a. range \<sigma> \<subseteq> M
         \<longrightarrow> (\<exists>l r. l \<in> M \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially))"
  by (simp add: compact_space_def compactin_sequentially)

lemma compact_space_eq_Bolzano_Weierstrass:
   "compact_space mtopology \<longleftrightarrow>
    (\<forall>S. S \<subseteq> M \<and> infinite S \<longrightarrow> mtopology derived_set_of S \<noteq> {})"
  using Int_absorb1 [OF derived_set_of_subset_topspace [of mtopology]]
  by (force simp add: compact_space_def compactin_eq_Bolzano_Weierstrass)

lemma compact_space_nest:
   "compact_space mtopology \<longleftrightarrow>
    (\<forall>C. (\<forall>n::nat. closedin mtopology (C n)) \<and> (\<forall>n. C n \<noteq> {}) \<and> decseq C \<longrightarrow> \<Inter>(range C) \<noteq> {})"
   (is "?lhs=?rhs")
proof
  assume L: ?lhs
  show ?rhs
  proof clarify
    fix C :: "nat \<Rightarrow> 'a set"
    assume "\<forall>n. closedin mtopology (C n)"
      and "\<forall>n. C n \<noteq> {}"
      and "decseq C"
      and "\<Inter> (range C) = {}"
    then obtain K where K: "finite K" "\<Inter>(C ` K) = {}"
      by (metis L compact_space_imp_nest decseq_def)
    then obtain k where "K \<subseteq> {..k}"
      using finite_nat_iff_bounded_le by auto
    then have "C k \<subseteq> \<Inter>(C ` K)"
      using \<open>decseq C\<close> by (auto simp:decseq_def)
    then show False
      by (simp add: K \<open>\<forall>n. C n \<noteq> {}\<close>)
  qed
next
  assume R [rule_format]: ?rhs
  show ?lhs
    unfolding compact_space_sequentially
  proof (intro strip)
    fix \<sigma> :: "nat \<Rightarrow> 'a"
    assume \<sigma>: "range \<sigma> \<subseteq> M"
    have "mtopology closure_of \<sigma> ` {n..} \<noteq> {}" for n
      using \<open>range \<sigma> \<subseteq> M\<close> by (auto simp: closure_of_eq_empty image_subset_iff)
    moreover have "decseq (\<lambda>n. mtopology closure_of \<sigma> ` {n..})"
      using closure_of_mono image_mono by (smt (verit) atLeast_subset_iff decseq_def) 
    ultimately obtain l where l: "\<And>n. l \<in> mtopology closure_of \<sigma> ` {n..}"
      using R [of "\<lambda>n. mtopology closure_of (\<sigma> ` {n..})"] by auto
    then have "l \<in> M" and "\<And>n. \<forall>r>0. \<exists>k\<ge>n. \<sigma> k \<in> M \<and> d l (\<sigma> k) < r"
      using metric_closure_of by fastforce+
    then obtain f where f: "\<And>n r. r>0 \<Longrightarrow> f n r \<ge> n \<and> \<sigma> (f n r) \<in> M \<and> d l (\<sigma> (f n r)) < r"
      by metis
    define r where "r = rec_nat (f 0 1) (\<lambda>n rec. (f (Suc rec) (inverse (Suc (Suc n)))))"
    have r: "d l (\<sigma>(r n)) < inverse(Suc n)" for n
      by (induction n) (auto simp: rec_nat_0_imp [OF r_def] rec_nat_Suc_imp [OF r_def] f)
    have "r n < r(Suc n)" for n
      by (simp add: Suc_le_lessD f r_def)
    then have "strict_mono r"
      using strict_monoI_Suc by blast
    moreover have "limitin mtopology (\<sigma> \<circ> r) l sequentially"
      proof (clarsimp simp: limitin_metric \<open>l \<in> M\<close>)
        fix \<epsilon> :: real
        assume "\<epsilon> > 0"
        then have "(\<forall>\<^sub>F n in sequentially. inverse (real (Suc n)) < \<epsilon>)"
          using Archimedean_eventually_inverse by blast
        then show "\<forall>\<^sub>F n in sequentially. \<sigma> (r n) \<in> M \<and> d (\<sigma> (r n)) l < \<epsilon>"
          by eventually_elim (metis commute \<open>range \<sigma> \<subseteq> M\<close>  order_less_trans r range_subsetD)
      qed
    ultimately show "\<exists>l r. l \<in> M \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially"
      using \<open>l \<in> M\<close> by blast
  qed
qed


lemma (in discrete_metric) mcomplete_discrete_metric:
  "disc.mcomplete"
proof (clarsimp simp add: disc.mcomplete_def)
  fix \<sigma> :: "nat \<Rightarrow> 'a"
  assume "disc.MCauchy \<sigma>"
  then obtain N where "\<And>n. N \<le> n \<Longrightarrow> \<sigma> N = \<sigma> n"
    unfolding disc.MCauchy_def by (metis dd_def dual_order.refl order_less_irrefl zero_less_one)
  moreover have "range \<sigma> \<subseteq> M"
    using \<open>disc.MCauchy \<sigma>\<close> disc.MCauchy_def by blast
  ultimately have "limitin disc.mtopology \<sigma> (\<sigma> N) sequentially"
    by (metis disc.limit_metric_sequentially disc.zero range_subsetD)
  then show "\<exists>x. limitin disc.mtopology \<sigma> x sequentially" ..
qed

lemma compact_space_imp_mcomplete: "compact_space mtopology \<Longrightarrow> mcomplete"
  by (simp add: compact_space_nest mcomplete_nest)

lemma (in submetric) compactin_imp_mcomplete:
   "compactin mtopology A \<Longrightarrow> sub.mcomplete"
  by (simp add: compactin_subspace mtopology_submetric sub.compact_space_imp_mcomplete)

lemma (in submetric) mcomplete_imp_closedin:
  assumes "sub.mcomplete"
  shows "closedin mtopology A"
proof -
  have "l \<in> A"
    if "range \<sigma> \<subseteq> A" and l: "limitin mtopology \<sigma> l sequentially"
    for \<sigma> :: "nat \<Rightarrow> 'a" and l
  proof -
    have "sub.MCauchy \<sigma>"
      using convergent_imp_MCauchy subset that by (force simp add: MCauchy_submetric)
    then have "limitin sub.mtopology \<sigma> l sequentially"
      using assms unfolding sub.mcomplete_def
      using l limitin_metric_unique limitin_submetric_iff trivial_limit_sequentially by blast
    then show ?thesis
      using limitin_submetric_iff by blast
  qed
  then show ?thesis
    using metric_closedin_iff_sequentially_closed subset by auto
qed

lemma (in submetric) closedin_eq_mcomplete:
   "mcomplete \<Longrightarrow> (closedin mtopology A \<longleftrightarrow> sub.mcomplete)"
  using closedin_mcomplete_imp_mcomplete mcomplete_imp_closedin by blast

lemma compact_space_eq_mcomplete_mtotally_bounded:
   "compact_space mtopology \<longleftrightarrow> mcomplete \<and> mtotally_bounded M"
  by (meson C compact_space_imp_mcomplete compact_space_sequentially limitin_mspace 
            mcomplete_alt mtotally_bounded_sequentially subset_refl)


lemma compact_closure_of_imp_mtotally_bounded:
   "\<lbrakk>compactin mtopology (mtopology closure_of S); S \<subseteq> M\<rbrakk>
      \<Longrightarrow> mtotally_bounded S"
  using compactin_imp_mtotally_bounded mtotally_bounded_closure_of_eq by blast

lemma mtotally_bounded_eq_compact_closure_of:
  assumes "mcomplete"
  shows "mtotally_bounded S \<longleftrightarrow> S \<subseteq> M \<and> compactin mtopology (mtopology closure_of S)"
  (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
    unfolding compactin_subspace
  proof (intro conjI)
    show "S \<subseteq> M"
      using L by (simp add: mtotally_bounded_imp_subset)
    show "mtopology closure_of S \<subseteq> topspace mtopology"
      by (simp add: \<open>S \<subseteq> M\<close> closure_of_minimal)
    then have MSM: "mtopology closure_of S \<subseteq> M"
      by auto
    interpret S: submetric M d "mtopology closure_of S"
    proof qed (use MSM in auto)
    have "S.sub.mtotally_bounded (mtopology closure_of S)"
      using L mtotally_bounded_absolute mtotally_bounded_closure_of by blast
    then
    show "compact_space (subtopology mtopology (mtopology closure_of S))"
      using S.closedin_mcomplete_imp_mcomplete S.mtopology_submetric S.sub.compact_space_eq_mcomplete_mtotally_bounded assms by force
  qed
qed (auto simp: compact_closure_of_imp_mtotally_bounded)



lemma compact_closure_of_eq_Bolzano_Weierstrass:
   "compactin mtopology (mtopology closure_of S) \<longleftrightarrow>
    (\<forall>T. infinite T \<and> T \<subseteq> S \<and> T \<subseteq> M \<longrightarrow> mtopology derived_set_of T \<noteq> {})"  (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
  proof (intro strip, elim conjE)
    fix T
    assume T: "infinite T" "T \<subseteq> S" "T \<subseteq> M"
    show "mtopology derived_set_of T \<noteq> {}"
    proof (intro compact_closure_of_imp_Bolzano_Weierstrass)
      show "compactin mtopology (mtopology closure_of S)"
        by (simp add: L)
    qed (use T in auto)
  qed
next
  have "compactin mtopology (mtopology closure_of S)"
    if \<section>: "\<And>T. \<lbrakk>infinite T; T \<subseteq> S\<rbrakk> \<Longrightarrow> mtopology derived_set_of T \<noteq> {}" and "S \<subseteq> M" for S
    unfolding compactin_sequentially
  proof (intro conjI strip)
    show MSM: "mtopology closure_of S \<subseteq> M"
      using closure_of_subset_topspace by fastforce
    fix \<sigma> :: "nat \<Rightarrow> 'a"
    assume \<sigma>: "range \<sigma> \<subseteq> mtopology closure_of S"
    then have "\<exists>y \<in> S. d (\<sigma> n) y < inverse(Suc n)" for n
      by (simp add: metric_closure_of image_subset_iff) (metis inverse_Suc of_nat_Suc)
    then obtain \<tau> where \<tau>: "\<And>n. \<tau> n \<in> S \<and> d (\<sigma> n) (\<tau> n) < inverse(Suc n)"
      by metis
    then have "range \<tau> \<subseteq> S"
      by blast
    moreover
    have *: "\<forall>T. T \<subseteq> S \<and> infinite T \<longrightarrow> mtopology closure_of S \<inter> mtopology derived_set_of T \<noteq> {}"
      using "\<section>"(1) derived_set_of_mono derived_set_of_subset_closure_of by fastforce
    moreover have "S \<subseteq> mtopology closure_of S"
      by (simp add: \<open>S \<subseteq> M\<close> closure_of_subset)
    ultimately obtain l r where lr:
      "l \<in> mtopology closure_of S" "strict_mono r" "limitin mtopology (\<tau> \<circ> r) l sequentially"
      using Bolzano_Weierstrass_property \<open>S \<subseteq> M\<close> by metis
    then have "l \<in> M"
      using limitin_mspace by blast
    have dr_less: "d ((\<sigma> \<circ> r) n) ((\<tau> \<circ> r) n) < inverse(Suc n)" for n
    proof -
      have "d ((\<sigma> \<circ> r) n) ((\<tau> \<circ> r) n) < inverse(Suc (r n))"
        using \<tau> by auto
      also have "... \<le> inverse(Suc n)"
        using lr strict_mono_imp_increasing by auto
      finally show ?thesis .
    qed
    have "limitin mtopology (\<sigma> \<circ> r) l sequentially"
      unfolding limitin_metric
    proof (intro conjI strip)
      show "l \<in> M"
        using limitin_mspace lr by blast
      fix \<epsilon> :: real
      assume "\<epsilon> > 0"
      then have "\<forall>\<^sub>F n in sequentially. (\<tau> \<circ> r) n \<in> M \<and> d ((\<tau> \<circ> r) n) l < \<epsilon>/2"
        using lr half_gt_zero limitin_metric by blast 
      moreover have "\<forall>\<^sub>F n in sequentially. inverse (real (Suc n)) < \<epsilon>/2"
        using Archimedean_eventually_inverse \<open>0 < \<epsilon>\<close> half_gt_zero by blast
      then have "\<forall>\<^sub>F n in sequentially. d ((\<sigma> \<circ> r) n) ((\<tau> \<circ> r) n) < \<epsilon>/2"
        by eventually_elim (smt (verit, del_insts) dr_less)
      ultimately have "\<forall>\<^sub>F n in sequentially. d ((\<sigma> \<circ> r) n) l < \<epsilon>/2 + \<epsilon>/2"
        by eventually_elim (smt (verit) triangle \<open>l \<in> M\<close> MSM \<sigma> comp_apply order_trans range_subsetD)      
      then show "\<forall>\<^sub>F n in sequentially. (\<sigma> \<circ> r) n \<in> M \<and> d ((\<sigma> \<circ> r) n) l < \<epsilon>"
        apply eventually_elim
        using \<open>mtopology closure_of S \<subseteq> M\<close> \<sigma> by auto
    qed
    with lr show "\<exists>l r. l \<in> mtopology closure_of S \<and> strict_mono r \<and> limitin mtopology (\<sigma> \<circ> r) l sequentially"
      by blast
  qed
  then show "?rhs \<Longrightarrow> ?lhs"
    by (metis Int_subset_iff closure_of_restrict inf_le1 topspace_mtopology)
qed

end

lemma (in discrete_metric) mtotally_bounded_discrete_metric:
   "disc.mtotally_bounded S \<longleftrightarrow> finite S \<and> S \<subseteq> M" (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
  proof
    show "finite S"
      by (metis (no_types) L closure_of_subset_Int compactin_discrete_topology disc.mtotally_bounded_eq_compact_closure_of
          disc.topspace_mtopology discrete_metric.mcomplete_discrete_metric inf.absorb_iff2 mtopology_discrete_metric finite_subset)
    show "S \<subseteq> M"
      by (simp add: L disc.mtotally_bounded_imp_subset)
  qed
qed (simp add: disc.finite_imp_mtotally_bounded)


context Metric_space
begin

lemma derived_set_of_infinite_openin_metric:
   "mtopology derived_set_of S =
    {x \<in> M. \<forall>U. x \<in> U \<and> openin mtopology U \<longrightarrow> infinite(S \<inter> U)}"
  by (simp add: derived_set_of_infinite_openin Hausdorff_space_mtopology)

lemma derived_set_of_infinite_1: 
  assumes "infinite (S \<inter> mball x \<epsilon>)" 
  shows "infinite (S \<inter> mcball x \<epsilon>)"
  by (meson Int_mono assms finite_subset mball_subset_mcball subset_refl)

lemma derived_set_of_infinite_2:
  assumes "openin mtopology U" "\<And>\<epsilon>. 0 < \<epsilon> \<Longrightarrow> infinite (S \<inter> mcball x \<epsilon>)" and "x \<in> U"
  shows "infinite (S \<inter> U)"
  by (metis assms openin_mtopology_mcball finite_Int inf.absorb_iff2 inf_assoc)

lemma derived_set_of_infinite_mball:
  "mtopology derived_set_of S = {x \<in> M. \<forall>e>0. infinite(S \<inter> mball x e)}"
  unfolding derived_set_of_infinite_openin_metric
  by (meson centre_in_mball_iff openin_mball derived_set_of_infinite_1 derived_set_of_infinite_2)

lemma derived_set_of_infinite_mcball:
  "mtopology derived_set_of S = {x \<in> M. \<forall>e>0. infinite(S \<inter> mcball x e)}"
  unfolding derived_set_of_infinite_openin_metric
  by (meson centre_in_mball_iff openin_mball derived_set_of_infinite_1 derived_set_of_infinite_2)

end


subsection\<open>Continuity via bases/subbases, hence upper and lower semicontinuity\<close>


lemma continuous_map_into_topology_base:
  assumes P: "openin Y = arbitrary union_of P"
    and f: "\<And>x. x \<in> topspace X \<Longrightarrow> f x \<in> topspace Y"
    and ope: "\<And>U. P U \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U}"
  shows "continuous_map X Y f"
proof -
  have *: "\<And>\<U>. (\<And>t. t \<in> \<U> \<Longrightarrow> P t) \<Longrightarrow> openin X {x \<in> topspace X. \<exists>U\<in>\<U>. f x \<in> U}"
    by (smt (verit) Ball_Collect ope mem_Collect_eq openin_subopen)
  show ?thesis
    using P by (auto simp: continuous_map_def arbitrary_def union_of_def intro!: f *)
qed

lemma continuous_map_into_topology_base_eq:
  assumes P: "openin Y = arbitrary union_of P"
  shows
   "continuous_map X Y f \<longleftrightarrow>
    (\<forall>x \<in> topspace X. f x \<in> topspace Y) \<and> (\<forall>U. P U \<longrightarrow> openin X {x \<in> topspace X. f x \<in> U})"
 (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  then have "\<And>x. x \<in> topspace X \<Longrightarrow> f x \<in> topspace Y"
    by (meson continuous_map_def)
  moreover have "\<And>U. P U \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U}"
    using L assms continuous_map openin_topology_base_unique by fastforce
  ultimately show ?rhs by auto
qed (simp add: assms continuous_map_into_topology_base)

lemma continuous_map_into_topology_subbase:
  fixes U P
  defines "Y \<equiv> topology(arbitrary union_of (finite intersection_of P relative_to U))"
  assumes f: "\<And>x. x \<in> topspace X \<Longrightarrow> f x \<in> topspace Y"
    and ope: "\<And>U. P U \<Longrightarrow> openin X {x \<in> topspace X. f x \<in> U}"
  shows "continuous_map X Y f"
proof (intro continuous_map_into_topology_base)
  show "openin Y = arbitrary union_of (finite intersection_of P relative_to U)"
    unfolding Y_def using istopology_subbase topology_inverse' by blast
  show "openin X {x \<in> topspace X. f x \<in> V}"
    if \<section>: "(finite intersection_of P relative_to U) V" for V 
  proof -
    define finv where "finv \<equiv> \<lambda>V. {x \<in> topspace X. f x \<in> V}"
    obtain \<U> where \<U>: "finite \<U>" "\<And>V. V \<in> \<U> \<Longrightarrow> P V"
                      "{x \<in> topspace X. f x \<in> V} = (\<Inter>V \<in> insert U \<U>. finv V)"
      using \<section> by (fastforce simp: finv_def intersection_of_def relative_to_def)
    show ?thesis
      unfolding \<U>
    proof (intro openin_Inter ope)
      have U: "U = topspace Y"
        unfolding Y_def using topspace_subbase by fastforce
      fix V
      assume V: "V \<in> finv ` insert U \<U>"
      with U f have "openin X {x \<in> topspace X. f x \<in> U}"
        by (auto simp: openin_subopen [of X "Collect _"])
      then show "openin X V"
        using V \<U>(2) ope by (fastforce simp: finv_def)
    qed (use \<open>finite \<U>\<close> in auto)
  qed
qed (use f in auto)

lemma continuous_map_into_topology_subbase_eq:
  assumes "Y = topology(arbitrary union_of (finite intersection_of P relative_to U))"
  shows
   "continuous_map X Y f \<longleftrightarrow>
    (\<forall>x \<in> topspace X. f x \<in> topspace Y) \<and> (\<forall>U. P U \<longrightarrow> openin X {x \<in> topspace X. f x \<in> U})"
   (is "?lhs=?rhs")
proof
  assume L: ?lhs 
  show ?rhs
    proof (intro conjI strip)
  show "\<And>x. x \<in> topspace X \<Longrightarrow> f x \<in> topspace Y"
    using L continuous_map_def by fastforce
  fix V
  assume "P V"
  have "U = topspace Y"
    unfolding assms using topspace_subbase by fastforce
  then have eq: "{x \<in> topspace X. f x \<in> V} = {x \<in> topspace X. f x \<in> U \<inter> V}"
    using L by (auto simp: continuous_map)
  have "openin Y (U \<inter> V)"
    unfolding assms openin_subbase
    by (meson \<open>P V\<close> arbitrary_union_of_inc finite_intersection_of_inc relative_to_inc)
  show "openin X {x \<in> topspace X. f x \<in> V}"
    using L \<open>openin Y (U \<inter> V)\<close> continuous_map eq by fastforce
qed
next
  show "?rhs \<Longrightarrow> ?lhs"
    unfolding assms
    by (intro continuous_map_into_topology_subbase) auto
qed 

lemma continuous_map_upper_lower_semicontinuous_lt_gen:
  fixes U :: "'a::order_topology set"
  shows "continuous_map X (subtopology euclidean U) f \<longleftrightarrow>
         (\<forall>x \<in> topspace X. f x \<in> U) \<and>
         (\<forall>a. openin X {x \<in> topspace X. f x > a}) \<and>
         (\<forall>a. openin X {x \<in> topspace X. f x < a})"
  by (auto simp add: continuous_map_into_topology_subbase_eq [OF subbase_subtopology_euclidean [symmetric, of U]] 
           greaterThan_def lessThan_def image_iff   simp flip: all_simps)

lemma continuous_map_upper_lower_semicontinuous_lt:
  fixes f :: "'a \<Rightarrow> 'b::order_topology"
  shows "continuous_map X euclidean f \<longleftrightarrow>
         (\<forall>a. openin X {x \<in> topspace X. f x > a}) \<and>
         (\<forall>a. openin X {x \<in> topspace X. f x < a})"
  using continuous_map_upper_lower_semicontinuous_lt_gen [where U=UNIV]
  by auto

lemma Int_Collect_imp_eq: "A \<inter> {x. x\<in>A \<longrightarrow> P x} = {x\<in>A. P x}"
  by blast

lemma continuous_map_upper_lower_semicontinuous_le_gen:
  shows
    "continuous_map X (subtopology euclideanreal U) f \<longleftrightarrow>
         (\<forall>x \<in> topspace X. f x \<in> U) \<and>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<ge> a}) \<and>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<le> a})"
  unfolding continuous_map_upper_lower_semicontinuous_lt_gen
  by (auto simp add: closedin_def Diff_eq Compl_eq not_le Int_Collect_imp_eq)

lemma continuous_map_upper_lower_semicontinuous_le:
   "continuous_map X euclideanreal f \<longleftrightarrow>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<ge> a}) \<and>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<le> a})"
  using continuous_map_upper_lower_semicontinuous_le_gen [where U=UNIV]
  by auto

lemma continuous_map_upper_lower_semicontinuous_lte_gen:
   "continuous_map X (subtopology euclideanreal U) f \<longleftrightarrow>
         (\<forall>x \<in> topspace X. f x \<in> U) \<and>
         (\<forall>a. openin X {x \<in> topspace X. f x < a}) \<and>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<le> a})"
  unfolding continuous_map_upper_lower_semicontinuous_lt_gen
  by (auto simp add: closedin_def Diff_eq Compl_eq not_le Int_Collect_imp_eq)

lemma continuous_map_upper_lower_semicontinuous_lte:
   "continuous_map X euclideanreal f \<longleftrightarrow>
         (\<forall>a. openin X {x \<in> topspace X. f x < a}) \<and>
         (\<forall>a. closedin X {x \<in> topspace X. f x \<le> a})"
  using continuous_map_upper_lower_semicontinuous_lte_gen [where U=UNIV]
  by auto


subsection\<open>Continuous functions on metric spaces\<close>

context Metric_space
begin

lemma continuous_map_to_metric:
   "continuous_map X mtopology f \<longleftrightarrow>
    (\<forall>x \<in> topspace X. \<forall>r>0. \<exists>U. openin X U \<and> x \<in> U \<and> (\<forall>y\<in>U. f y \<in> mball (f x) r))"
   (is "?lhs=?rhs")
proof
  show "?lhs \<Longrightarrow> ?rhs"
    unfolding continuous_map_eq_topcontinuous_at topcontinuous_at_def
    by (metis centre_in_mball_iff openin_mball topspace_mtopology)
next
  assume R: ?rhs
  then have "\<forall>x\<in>topspace X. f x \<in> M"
    by (meson gt_ex in_mball)
  moreover 
  have "\<And>x V. \<lbrakk>x \<in> topspace X; openin mtopology V; f x \<in> V\<rbrakk> \<Longrightarrow> \<exists>U. openin X U \<and> x \<in> U \<and> (\<forall>y\<in>U. f y \<in> V)"
    unfolding openin_mtopology by (metis Int_iff R inf.orderE)
  ultimately
  show ?lhs
    by (simp add: continuous_map_eq_topcontinuous_at topcontinuous_at_def)
qed 

lemma continuous_map_from_metric:
   "continuous_map mtopology X f \<longleftrightarrow>
    f ` M \<subseteq> topspace X \<and>
    (\<forall>a \<in> M. \<forall>U. openin X U \<and> f a \<in> U \<longrightarrow> (\<exists>r>0. \<forall>x. x \<in> M \<and> d a x < r \<longrightarrow> f x \<in> U))"
proof (cases "f ` M \<subseteq> topspace X")
  case True
  then show ?thesis
    by (fastforce simp add: continuous_map openin_mtopology subset_eq)
next
  case False
  then show ?thesis
    by (simp add: continuous_map_eq_image_closure_subset_gen)
qed

lemma continuous_map_uniform_limit:
   "\<And>F X m f::K=>A->B g.
        \<not> trivial_limit F \<and>
        eventually (\<lambda>n. continuous_map X mtopology (f n)) F \<and>
        (\<forall>e. 0 < e
             \<Longrightarrow> eventually
                   (\<lambda>n. \<forall>x. x \<in> topspace X
                            \<Longrightarrow> g x \<in> M \<and> d f n x g x < e)
                 F)
        \<Longrightarrow> continuous_map X mtopology g"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_MAP_TO_METRIC] THEN
  DISCH_THEN(CONJUNCTS_THEN ASSUME_TAC) THEN X_GEN_TAC `x::A` THEN
  DISCH_TAC THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(CONJUNCTS_THEN2 MP_TAC (MP_TAC \<circ> SPEC `e / 3`)) THEN
  ASM_REWRITE_TAC[REAL_ARITH `0 < e / 3 \<longleftrightarrow> 0 < e`; IMP_IMP] THEN
  REWRITE_TAC[GSYM EVENTUALLY_AND] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP EVENTUALLY_HAPPENS) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `k::K` THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `x::A`)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `e / 3`) THEN
  ASM_REWRITE_TAC[REAL_ARITH `0 < e / 3 \<longleftrightarrow> 0 < e`] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `u::A=>bool` THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `y::A` THEN
  DISCH_THEN(fun th -> DISCH_TAC THEN MP_TAC th) THEN FIRST_X_ASSUM(fun th ->
    MP_TAC(SPEC `y::A` th) THEN MP_TAC(SPEC `x::A` th)) THEN
  SUBGOAL_THEN `(y::A) \<in> topspace X` ASSUME_TAC THENL
   [ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]; ASM_REWRITE_TAC[]] THEN
  ASM_SIMP_TAC[IN_MBALL] THEN CONV_TAC METRIC_ARITH);;

lemma continuous_map_uniform_limit_alt:
   "\<And>F X m f::K=>A->B g.
        \<not> trivial_limit F \<and>
        image g (topspace X) \<subseteq> M \<and>
        eventually (\<lambda>n. continuous_map X mtopology (f n)) F \<and>
        (\<forall>e. 0 < e
             \<Longrightarrow> eventually
                   (\<lambda>n. \<forall>x. x \<in> topspace X \<Longrightarrow> d f n x g x < e)
                 F)
        \<Longrightarrow> continuous_map X mtopology g"
oops
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC `F::K F` CONTINUOUS_MAP_UNIFORM_LIMIT) THEN
  EXISTS_TAC `f::K=>A->B` THEN ASM_SIMP_TAC[]);;

lemma continuous_map_uniformly_cauchy_limit:
   "\<And>X ms f::num=>A->B.
      \<not> trivial_limit sequentially \<and> mcomplete ms \<and>
      eventually (\<lambda>n. continuous_map X (mtopology ms) (f n)) sequentially \<and>
      (\<forall>e. 0 < e
           \<Longrightarrow> \<exists>N. \<forall>m n x. N \<le> m \<and> N \<le> n \<and> x \<in> topspace X
                           \<Longrightarrow> d ms (f m x,f n x) < e)
      \<Longrightarrow> \<exists>g. continuous_map X (mtopology ms) g \<and>
              \<forall>e. 0 < e
                  \<Longrightarrow> eventually
                       (\<lambda>n. \<forall>x. x \<in> topspace X
                                \<Longrightarrow> d ms (f n x,g x) < e)
                       sequentially"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   `\<forall>x. x \<in> topspace X
        \<Longrightarrow> \<exists>l. limitin (mtopology ms) (\<lambda>n. (f::num=>A->B) n x) l sequentially`
  MP_TAC THENL
   [X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [MCOMPLETE]) THEN
    REWRITE_TAC[MCauchy] THEN CONJ_TAC THENL
     [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
        EVENTUALLY_MONO)) THEN
      ASM_SIMP_TAC[continuous_map; TOPSPACE_MTOPOLOGY];
      ASM_MESON_TAC[]];
    GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM] THEN
    REWRITE_TAC[SKOLEM_THM]] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::A=>B` THEN DISCH_TAC THEN
  MATCH_MP_TAC(TAUT `q \<and> (q \<Longrightarrow> p) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
   [X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e / 2`) THEN
    ASM_REWRITE_TAC[REAL_HALF; EVENTUALLY_SEQUENTIALLY] THEN
    DISCH_THEN(X_CHOOSE_THEN `N::num` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [EVENTUALLY_SEQUENTIALLY]) THEN
    REWRITE_TAC[continuous_map; LEFT_IMP_EXISTS_THM; TOPSPACE_MTOPOLOGY] THEN
    X_GEN_TAC `P::num` THEN DISCH_TAC THEN EXISTS_TAC `MAX N P` THEN
    ASM_REWRITE_TAC[ARITH_RULE `MAX N P \<le> n \<longleftrightarrow> N \<le> n \<and> P \<le> n`] THEN
    X_GEN_TAC `n::num` THEN STRIP_TAC THEN X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::A`) THEN ASM_REWRITE_TAC[LIMIT_METRIC] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `e / 2`)) THEN
    ASM_REWRITE_TAC[REAL_HALF; EVENTUALLY_SEQUENTIALLY] THEN
    DISCH_THEN(X_CHOOSE_THEN `M::num` (MP_TAC \<circ> SPEC `MAX M (MAX N P)`)) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`n::num`; `MAX M (MAX N P)`; `x::A`]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `n::num`) THEN
    ASM_SIMP_TAC[ARITH_RULE `n \<le> MAX M N \<longleftrightarrow> n \<le> M \<or> n \<le> N`; LE_REFL] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `x::A` \<circ> CONJUNCT1) THEN
    UNDISCH_TAC `(g::A=>B) x \<in> mspace ms` THEN ASM_REWRITE_TAC[] THEN
    CONV_TAC METRIC_ARITH;
    DISCH_TAC THEN
    MATCH_MP_TAC(ISPEC `sequentially` CONTINUOUS_MAP_UNIFORM_LIMIT_ALT) THEN
    EXISTS_TAC `f::num=>A->B` THEN
    RULE_ASSUM_TAC(REWRITE_RULE[limitin; TOPSPACE_MTOPOLOGY]) THEN
    ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE]]);;


lemma metric_continuous_map:
   "continuous_map mtopology (mtopology m') f \<longleftrightarrow>
     (\<forall>x \<in> M. f x \<in> mspace m') \<and>
     (\<forall>a \<in> M. \<forall>e>0. \<exists>d>0.  (\<forall>x. x \<in> M \<and> d a x < d
                          \<longrightarrow> d m' (f a, f x) < e)))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_map; TOPSPACE_MTOPOLOGY] THEN
  EQ_TAC THEN SIMP_TAC[] THENL
  [INTRO_TAC "f cont; !a e; e a" THEN
   REMOVE_THEN "cont" (MP_TAC \<circ> SPEC `mball m' (f (a::A):B,e)`) THEN
   REWRITE_TAC[OPEN_IN_MBALL] THEN
   ASM_SIMP_TAC[OPEN_IN_MTOPOLOGY; \<subseteq>; IN_MBALL; IN_ELIM_THM] THEN
   DISCH_THEN (MP_TAC \<circ> SPEC `a::A`) THEN ASM_SIMP_TAC[MDIST_REFL];
   SIMP_TAC[OPEN_IN_MTOPOLOGY; \<subseteq>; IN_MBALL; IN_ELIM_THM] THEN
   ASM_MESON_TAC[]]);;

subsection\<open>Combining theorems for continuous functions into the reals\<close>


lemma continuous_map_real_const:
   "continuous_map X euclideanreal (\<lambda>x::A. c)"
oops
  REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV]);;

lemma continuous_map_real_mul:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x * g x)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_MUL]);;

lemma continuous_map_real_pow:
   "\<And>X (f::A=>real) n.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x ^ n)"
oops
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  INDUCT_TAC THEN
  ASM_SIMP_TAC[real_pow; CONTINUOUS_MAP_REAL_CONST; CONTINUOUS_MAP_REAL_MUL]);;

lemma continuous_map_real_lmul:
   "\<And>X c f::A=>real.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. c * f x)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_LMUL]);;

lemma continuous_map_real_lmul_eq:
   "\<And>X c f::A=>real.
        continuous_map X euclideanreal (\<lambda>x. c * f x) \<longleftrightarrow>
        c = 0 \<or> continuous_map X euclideanreal f"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `c = 0` THEN
  ASM_REWRITE_TAC[REAL_MUL_LZERO; CONTINUOUS_MAP_REAL_CONST] THEN
  EQ_TAC THEN REWRITE_TAC[CONTINUOUS_MAP_REAL_LMUL] THEN DISCH_THEN(MP_TAC \<circ>
   SPEC `inverse c:real` \<circ> MATCH_MP CONTINUOUS_MAP_REAL_LMUL) THEN
  ASM_SIMP_TAC[REAL_MUL_ASSOC; REAL_MUL_LINV; REAL_MUL_LID; ETA_AX]);;

lemma continuous_map_real_rmul:
   "\<And>X c f::A=>real.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x * c)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_RMUL]);;

lemma continuous_map_real_rmul_eq:
   "\<And>X c f::A=>real.
        continuous_map X euclideanreal (\<lambda>x. f x * c) \<longleftrightarrow>
        c = 0 \<or> continuous_map X euclideanreal f"
oops
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_LMUL_EQ]);;

lemma continuous_map_real_neg:
   "\<And>X f::A=>real.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. --(f x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_NEG]);;

lemma continuous_map_real_neg_eq:
   "\<And>X f::A=>real.
        continuous_map X euclideanreal (\<lambda>x. --(f x)) \<longleftrightarrow>
        continuous_map X euclideanreal f"
oops
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_LMUL_EQ] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV);;

lemma continuous_map_real_add:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x + g x)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_ADD]);;

lemma continuous_map_real_sub:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x - g x)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_SUB]);;

lemma continuous_map_real_abs:
   "\<And>X f::A=>real.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. abs(f x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_ABS]);;

lemma continuous_map_real_max:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. max (f x) (g x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_MAX]);;

lemma continuous_map_real_min:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. min (f x) (g x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_MIN]);;

lemma continuous_map_sum:
   "\<And>X f::A=>K->real k.
        finite k \<and>
        (\<forall>i. i \<in> k \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x i))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. sum k (f x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_SUM]);;

lemma continuous_map_real_product:
   "\<And>X f::A=>K->real k.
        finite k \<and>
        (\<forall>i. i \<in> k \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x i))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. product k (f x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_PRODUCT]);;

lemma continuous_map_real_inv:
   "\<And>X f::A=>real.
        continuous_map X euclideanreal f \<and>
        (\<forall>x. x \<in> topspace X \<Longrightarrow> \<not> (f x = 0))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. inverse(f x))"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_INV]);;

lemma continuous_map_real_div:
   "\<And>X f g::A=>real.
        continuous_map X euclideanreal f \<and>
        continuous_map X euclideanreal g \<and>
        (\<forall>x. x \<in> topspace X \<Longrightarrow> \<not> (g x = 0))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x / g x)"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_REAL_DIV]);;

lemma continuous_map_inf:
   "\<And>X f::A=>K->real k.
        finite k \<and>
        (\<forall>i. i \<in> k \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x i))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. inf {f x i | i \<in> k})"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_INF]);;

lemma continuous_map_sup:
   "\<And>X f::A=>K->real k.
        finite k \<and>
        (\<forall>i. i \<in> k \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x i))
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. sup {f x i | i \<in> k})"
oops
  SIMP_TAC[CONTINUOUS_MAP_ATPOINTOF; LIMIT_SUP]);;

lemma continuous_map_real_shrink:
 (`continuous_map euclideanreal (
                   subtopology euclideanreal (real_interval(-- 1,1)))
                  (\<lambda>x. x / (1 + abs x))"
oops
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
  REWRITE_TAC[IN_REAL_INTERVAL; REAL_BOUNDS_LT; REAL_SHRINK_RANGE] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_DIV THEN
  REWRITE_TAC[CONTINUOUS_MAP_ID; REAL_ARITH `\<not> (1 + abs x = 0)`] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_ADD THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
  GEN_REWRITE_TAC RAND_CONV [GSYM ETA_AX] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_ABS THEN
  REWRITE_TAC[CONTINUOUS_MAP_ID]);;

lemma continuous_map_real_grow:
 (`continuous_map (subtopology euclideanreal (real_interval(-- 1,1)),
                   euclideanreal)
                  (\<lambda>x. x / (1 - abs x))"
oops
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_DIV THEN
  SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_ID] THEN
  SIMP_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; IN_REAL_INTERVAL] THEN
  CONJ_TAC THENL [MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB; REAL_ARITH_TAC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
  GEN_REWRITE_TAC RAND_CONV [GSYM ETA_AX] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_ABS THEN
  REWRITE_TAC[CONTINUOUS_MAP_ID]);;

lemma homeomorphic_maps_real_shrink:
 (`homeomorphic_maps
     (euclideanreal,subtopology euclideanreal (real_interval(-- 1,1)))
     ((\<lambda>x. x / (1 + abs x)),(\<lambda>y. y / (1 - abs y)))"
oops
  REWRITE_TAC[homeomorphic_maps] THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_SHRINK; CONTINUOUS_MAP_REAL_GROW] THEN
  REWRITE_TAC[REAL_GROW_SHRINK; REAL_SHRINK_GROW_EQ] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; IN_REAL_INTERVAL] THEN
  REAL_ARITH_TAC);;

lemma continuous_map_cases_le:
   "\<And>X X' p q f (g::A=>B).
        continuous_map X euclideanreal p \<and>
        continuous_map X euclideanreal q \<and>
        continuous_map
         (subtopology X {x \<in> topspace X. p x \<le> q x},X') f \<and>
        continuous_map
         (subtopology X {x \<in> topspace X. q x \<le> p x},X') g \<and>
        (\<forall>x \<in> topspace X. p x = q x \<Longrightarrow> f x = g x)
        \<Longrightarrow> continuous_map X X' (\<lambda>x. if p x \<le> q x then f x else g x)"
oops
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH `x \<le> y \<longleftrightarrow> y - x >= 0`] THEN
  ONCE_REWRITE_TAC[SET_RULE `x >= 0 \<longleftrightarrow> x \<in> {t. t >= 0}`] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_CASES_FUNCTION THEN
  EXISTS_TAC `euclideanreal` THEN ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_SUB] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; REAL_ARITH `\<not> (x >= y) \<longleftrightarrow> x::real < y`;
    SET_RULE `- {x. P x} = {x. \<not> P x}`] THEN
  REWRITE_TAC[EUCLIDEANREAL_CLOSURE_OF_HALFSPACE_GE;
              EUCLIDEANREAL_CLOSURE_OF_HALFSPACE_LT;
              EUCLIDEANREAL_FRONTIER_OF_HALFSPACE_GE] THEN
  ASM_REWRITE_TAC[IN_ELIM_THM; REAL_SUB_0; real_ge; REAL_SUB_LE] THEN
  ASM_REWRITE_TAC[REAL_ARITH `p - q \<le> 0 \<longleftrightarrow> p \<le> q`] THEN
  ASM_MESON_TAC[]);;

lemma continuous_map_cases_lt:
   "\<And>X X' p q f (g::A=>B).
        continuous_map X euclideanreal p \<and>
        continuous_map X euclideanreal q \<and>
        continuous_map
         (subtopology X {x \<in> topspace X. p x \<le> q x},X') f \<and>
        continuous_map
         (subtopology X {x \<in> topspace X. q x \<le> p x},X') g \<and>
        (\<forall>x \<in> topspace X. p x = q x \<Longrightarrow> f x = g x)
        \<Longrightarrow> continuous_map X X' (\<lambda>x. if p x < q x then f x else g x)"
oops
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH `x < y \<longleftrightarrow> y - x > 0`] THEN
  ONCE_REWRITE_TAC[SET_RULE `x > 0 \<longleftrightarrow> x \<in> {t. t > 0}`] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_CASES_FUNCTION THEN
  EXISTS_TAC `euclideanreal` THEN ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_SUB] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; REAL_ARITH `\<not> (x > y) \<longleftrightarrow> x::real \<le> y`;
    SET_RULE `- {x. P x} = {x. \<not> P x}`] THEN
  REWRITE_TAC[EUCLIDEANREAL_CLOSURE_OF_HALFSPACE_GT;
              EUCLIDEANREAL_CLOSURE_OF_HALFSPACE_LE;
              EUCLIDEANREAL_FRONTIER_OF_HALFSPACE_GT] THEN
  ASM_REWRITE_TAC[IN_ELIM_THM; REAL_SUB_0; real_ge; REAL_SUB_LE] THEN
  ASM_REWRITE_TAC[REAL_ARITH `p - q \<le> 0 \<longleftrightarrow> p \<le> q`] THEN
  ASM_MESON_TAC[]);;


subsection\<open>Paths and path-connectedness\<close>


let path_in = new_definition
 `path_in X (g::real=>A) \<longleftrightarrow>
  continuous_map (subtopology euclideanreal (real_interval[0,1]),X) g`;;

lemma path_in_compose:
   "\<And>X X' f::A=>B g::real=>A.
        path_in X g \<and> continuous_map X X' f \<Longrightarrow> path_in X' (f \<circ> g)"
oops
  REWRITE_TAC[path_in; CONTINUOUS_MAP_COMPOSE]);;

lemma path_in_subtopology:
   "\<And>X s g::real=>A.
        path_in (subtopology X s) g \<longleftrightarrow>
        path_in X g \<and> (\<forall>x. x \<in> real_interval[0,1] \<Longrightarrow> g x \<in> s)"
oops
  REWRITE_TAC[path_in; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  SIMP_TAC[continuous_map; TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL] THEN
  SET_TAC[]);;

lemma path_in_const:
   "path_in X (\<lambda>x. a) \<longleftrightarrow> a \<in> topspace X"
oops
  REWRITE_TAC[path_in; CONTINUOUS_MAP_CONST] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; REAL_INTERVAL_EQ_EMPTY] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV);;

let path_connected_space = new_definition
 `path_connected_space X \<longleftrightarrow>
        \<forall>x y::A. x \<in> topspace X \<and> y \<in> topspace X
                \<Longrightarrow> \<exists>g. path_in X g \<and> g 0 = x \<and> g 1 = y`;;

let path_connectedin = new_definition
 `path_connectedin X (s::A=>bool) \<longleftrightarrow>
  s \<subseteq> topspace X \<and> path_connected_space(subtopology X s)`;;

lemma path_connectedin_absolute:
   "
        path_connectedin (subtopology X s) s \<longleftrightarrow> path_connectedin X s"
oops
  REWRITE_TAC[path_connectedin; SUBTOPOLOGY_SUBTOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER; SUBSET_REFL] THEN
  REWRITE_TAC[INTER_ACI]);;

lemma path_connectedin_subset_topspace:
   " path_connectedin X s \<Longrightarrow> s \<subseteq> topspace X"
oops
  SIMP_TAC[path_connectedin]);;

lemma path_connectedin_subtopology:
   "\<And>X s t::A=>bool.
      path_connectedin (subtopology X s) t \<longleftrightarrow>
      path_connectedin X t \<and> t \<subseteq> s"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[path_connectedin; SUBTOPOLOGY_SUBTOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN
  ASM_CASES_TAC `(t::A=>bool) \<subseteq> s` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC[SET_RULE `t \<subseteq> s \<Longrightarrow> s \<inter> t = t`]);;

lemma path_connectedin:
   "
        path_connectedin X s \<longleftrightarrow>
        s \<subseteq> topspace X \<and>
        \<forall>x y. x \<in> s \<and> y \<in> s
              \<Longrightarrow> \<exists>g. path_in X g \<and>
                      image g (real_interval[0,1]) \<subseteq> s \<and>
                      g 0 = x \<and> g 1 = y"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_connectedin; path_connected_space] THEN
  ASM_CASES_TAC `(s::A=>bool) \<subseteq> topspace X` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; path_in; CONTINUOUS_MAP_IN_SUBTOPOLOGY;
               SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; INTER_UNIV; GSYM CONJ_ASSOC]);;

lemma path_connectedin_topspace:
   "path_connectedin X (topspace X) \<longleftrightarrow>
                    path_connected_space X"
oops
  REWRITE_TAC[path_connectedin; SUBSET_REFL; SUBTOPOLOGY_TOPSPACE]);;

lemma path_connected_imp_connected_space:
   "path_connected_space X \<Longrightarrow> connected_space X"
oops
  REWRITE_TAC[path_connected_space; CONNECTED_SPACE_SUBCONNECTED] THEN
  GEN_TAC THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x::A`; `y::A`]) THEN
  ASM_REWRITE_TAC[path_in; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::real=>A` THEN STRIP_TAC THEN
  EXISTS_TAC `image (g::real=>A) (real_interval [0,1])` THEN
  REPEAT CONJ_TAC THENL
   [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
      CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
    REWRITE_TAC[CONNECTED_IN_ABSOLUTE] THEN
    REWRITE_TAC[CONNECTED_IN_EUCLIDEANREAL_INTERVAL];
    REWRITE_TAC[IN_IMAGE] THEN EXISTS_TAC `0` THEN
    ASM_REWRITE_TAC[IN_REAL_INTERVAL; REAL_POS];
    REWRITE_TAC[IN_IMAGE] THEN EXISTS_TAC `1` THEN
    ASM_REWRITE_TAC[IN_REAL_INTERVAL; REAL_POS; REAL_LE_REFL]]);;

lemma path_connectedin_imp_connectedin:
   " path_connectedin X s \<Longrightarrow> connectedin X s"
oops
  SIMP_TAC[path_connectedin; connectedin] THEN
  SIMP_TAC[PATH_CONNECTED_IMP_CONNECTED_SPACE]);;

lemma path_connected_space_topspace_empty:
   "topspace X = {} \<Longrightarrow> path_connected_space X"
oops
  SIMP_TAC[path_connected_space; NOT_IN_EMPTY]);;

lemma path_connectedin_empty:
   "path_connectedin X {}"
oops
  SIMP_TAC[path_connectedin; PATH_CONNECTED_SPACE_TOPSPACE_EMPTY;
           EMPTY_SUBSET; TOPSPACE_SUBTOPOLOGY; INTER_EMPTY]);;

lemma path_connectedin_sing:
   "path_connectedin X {a} \<longleftrightarrow> a \<in> topspace X"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[PATH_CONNECTED_IN; SING_SUBSET] THEN
  ASM_CASES_TAC `(a::A) \<in> topspace X` THEN ASM_REWRITE_TAC[IN_SING] THEN
  REPEAT STRIP_TAC THEN EXISTS_TAC `(\<lambda>x. a):real=>A` THEN
  ASM_REWRITE_TAC[path_in; CONTINUOUS_MAP_CONST] THEN SET_TAC[]);;

lemma path_connectedin_continuous_map_image:
   "\<And>f::A=>B X X' s.
        continuous_map X X' f \<and> path_connectedin X s
        \<Longrightarrow> path_connectedin X' (f ` s)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[PATH_CONNECTED_IN] THEN
  STRIP_TAC THEN FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP
   CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
  CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[FORALL_IN_IMAGE_2]] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x::A`; `y::A`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::real=>A` THEN STRIP_TAC THEN
  EXISTS_TAC `f \<circ> (g::real=>A)` THEN
  ASM_SIMP_TAC[o_THM; IMAGE_o; IMAGE_SUBSET] THEN
  ASM_MESON_TAC[PATH_IN_COMPOSE]);;

lemma homeomorphic_path_connected_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (path_connected_space X \<longleftrightarrow> path_connected_space X')"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[homeomorphic_space; homeomorphic_maps; LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`f::A=>B`; `g::B=>A`] THEN STRIP_TAC THEN
  REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE] THEN EQ_TAC THEN DISCH_TAC THENL
   [SUBGOAL_THEN `topspace X' = f ` (topspace X)` SUBST1_TAC
    THENL [ALL_TAC; ASM_MESON_TAC[PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE]];
    SUBGOAL_THEN `topspace X = image (g::B=>A) (topspace X')` SUBST1_TAC
    THENL [ALL_TAC; ASM_MESON_TAC[PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE]]] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[continuous_map]) THEN ASM SET_TAC[]);;

lemma homeomorphic_map_path_connectedness:
   "\<And>f X X' u.
        homeomorphic_map X X' f \<and> u \<subseteq> topspace X
        \<Longrightarrow> (path_connectedin X' (f ` u) \<longleftrightarrow> path_connectedin X u)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[path_connectedin] THEN
  BINOP_TAC THENL
   [ALL_TAC;
    MATCH_MP_TAC HOMEOMORPHIC_PATH_CONNECTED_SPACE THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    REWRITE_TAC[HOMEOMORPHIC_SPACE] THEN EXISTS_TAC `f::A=>B` THEN
    MATCH_MP_TAC HOMEOMORPHIC_MAP_SUBTOPOLOGIES THEN
    ASM_REWRITE_TAC[]] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP]) THEN
  ASM SET_TAC[]);;

lemma homeomorphic_map_path_connectedness_eq:
   "\<And>f X X' u.
        homeomorphic_map X X' f
        \<Longrightarrow> (path_connectedin X u \<longleftrightarrow>
             u \<subseteq> topspace X \<and> path_connectedin X' (f ` u))"
oops
  MESON_TAC[HOMEOMORPHIC_MAP_PATH_CONNECTEDNESS;
            PATH_CONNECTED_IN_SUBSET_TOPSPACE]);;

lemma path_connected_space_quotient_map_image:
   "\<And>X X' (q::A=>B).
        quotient_map X X' q \<and> path_connected_space X
        \<Longrightarrow> path_connected_space X'"
oops
  REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE] THEN REPEAT STRIP_TAC THEN
  FIRST_ASSUM(SUBST1_TAC \<circ> SYM \<circ> MATCH_MP QUOTIENT_IMP_SURJECTIVE_MAP) THEN
  MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
  ASM_MESON_TAC[QUOTIENT_IMP_CONTINUOUS_MAP]);;

lemma path_connected_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> path_connected_space X
        \<Longrightarrow> path_connected_space X'"
oops
  MESON_TAC[PATH_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE;
            RETRACTION_IMP_QUOTIENT_MAP]);;

lemma path_connectedin_euclideanreal_interval:
 (`(\<forall>a b. path_connectedin euclideanreal (real_interval[a,b])) \<and>
   (\<forall>a b. path_connectedin euclideanreal (real_interval(a,b)))"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[PATH_CONNECTED_IN; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV] THEN
  MAP_EVERY X_GEN_TAC [`x::real`; `y::real`] THEN
  REWRITE_TAC[IN_REAL_INTERVAL] THEN STRIP_TAC THEN
  EXISTS_TAC `\<lambda>u. (1 - u) * x + u * y` THEN
  REWRITE_TAC[REAL_SUB_REFL; REAL_SUB_RZERO; REAL_MUL_LZERO] THEN
  REWRITE_TAC[REAL_MUL_LID; REAL_ADD_LID; REAL_ADD_RID] THEN
  (CONV_TAC \<circ> GEN_SIMPLIFY_CONV TOP_DEPTH_SQCONV (basic_ss []) 4)
   [path_in; CONTINUOUS_MAP_REAL_ADD; CONTINUOUS_MAP_REAL_RMUL;
    CONTINUOUS_MAP_ID; CONTINUOUS_MAP_REAL_SUB; CONTINUOUS_MAP_REAL_CONST;
    CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
  X_GEN_TAC `t::real` THEN STRIP_TAC THENL
   [MATCH_MP_TAC(REAL_ARITH
     `\<forall>x y::real.
       (a \<le> x \<and> y \<le> b) \<and> (x \<le> r \<and> r \<le> y) \<Longrightarrow> a \<le> r \<and> r \<le> b`);
    MATCH_MP_TAC(REAL_ARITH
     `\<forall>x y::real.
       (a < x \<and> y < b) \<and> (x \<le> r \<and> r \<le> y) \<Longrightarrow> a < r \<and> r < b`)] THEN
  MAP_EVERY EXISTS_TAC [`min x y::real`; `max x y::real`] THEN
  (CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC]) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(REAL_ARITH
      `(0 \<le> t * (y - x) \<or> 0 \<le> (1 - t) * (x - y)) \<and>
       (0 \<le> t * (x - y) \<or> 0 \<le> (1 - t) * (y - x))
       \<Longrightarrow> min x y \<le> (1 - t) * x + t * y \<and>
           (1 - t) * x + t * y \<le> max x y`) THEN
  ASM_MESON_TAC[REAL_SUB_LE; REAL_LE_MUL;
                REAL_ARITH `0 \<le> x - y \<or> 0 \<le> y - x`]);;

lemma path_connectedin_path_image:
   "\<And>X g::real=>A.
     path_in X g \<Longrightarrow> path_connectedin X (image g (real_interval[0,1]))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_in] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
  EXISTS_TAC `subtopology euclideanreal (real_interval [0,1])` THEN
  ASM_REWRITE_TAC[PATH_CONNECTED_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
  REWRITE_TAC[PATH_CONNECTED_IN_EUCLIDEANREAL_INTERVAL]);;

lemma connectedin_path_image:
   "\<And>X g::real=>A.
     path_in X g \<Longrightarrow> connectedin X (image g (real_interval[0,1]))"
oops
  SIMP_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN; PATH_CONNECTED_IN_PATH_IMAGE]);;

lemma compact_in_path_image:
   "\<And>X g::real=>A.
     path_in X g \<Longrightarrow> compactin X (image g (real_interval[0,1]))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_in] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] IMAGE_COMPACT_IN) THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
  REWRITE_TAC[COMPACT_IN_EUCLIDEANREAL_INTERVAL]);;

lemma path_start_in_topspace:
   "\<And>X g::real=>A. path_in X g \<Longrightarrow> g 0 \<in> topspace X"
oops
  REWRITE_TAC[path_in; continuous_map] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[INTER_UNIV; IN_REAL_INTERVAL] THEN REAL_ARITH_TAC);;

lemma path_finish_in_topspace:
   "\<And>X g::real=>A. path_in X g \<Longrightarrow> g 1 \<in> topspace X"
oops
  REWRITE_TAC[path_in; continuous_map] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[INTER_UNIV; IN_REAL_INTERVAL] THEN REAL_ARITH_TAC);;

lemma path_image_subset_topspace:
   "\<And>X g::real=>A.
    path_in X g \<Longrightarrow> image g (real_interval[0,1]) \<subseteq> topspace X"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_in] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; INTER_UNIV; TOPSPACE_EUCLIDEANREAL]);;

lemma path_connected_space_subconnected:
   "path_connected_space X \<longleftrightarrow>
         \<forall>x y::A. x \<in> topspace X \<and> y \<in> topspace X
                 \<Longrightarrow> \<exists>s. path_connectedin X s \<and>
                         x \<in> s \<and>
                         y \<in> s"
oops
  GEN_TAC THEN REWRITE_TAC[path_connected_space] THEN EQ_TAC THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `y::A` THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THENL
   [DISCH_THEN(X_CHOOSE_THEN `g::real=>A` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `image (g::real=>A) (real_interval[0,1])` THEN
    ASM_SIMP_TAC[PATH_CONNECTED_IN_PATH_IMAGE; PATH_IMAGE_SUBSET_TOPSPACE] THEN
    REWRITE_TAC[IN_IMAGE; IN_REAL_INTERVAL] THEN CONJ_TAC THENL
     [EXISTS_TAC `0`; EXISTS_TAC `1`] THEN
    ASM_REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV;
    DISCH_THEN(X_CHOOSE_THEN `s::A=>bool` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [PATH_CONNECTED_IN]) THEN
    ASM_MESON_TAC[]]);;

lemma path_connectedin_euclideanreal:
   "path_connectedin euclideanreal s \<longleftrightarrow> is_interval s"
oops
  GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[CONNECTED_IN_EUCLIDEANREAL; PATH_CONNECTED_IN_IMP_CONNECTED_IN];
    REWRITE_TAC[is_interval] THEN DISCH_TAC] THEN
  REWRITE_TAC[path_connectedin; TOPSPACE_EUCLIDEANREAL; SUBSET_UNIV] THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_SUBCONNECTED] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL; INTER_UNIV] THEN
  MAP_EVERY X_GEN_TAC [`x::real`; `y::real`] THEN STRIP_TAC THEN
  EXISTS_TAC `real_interval[min x y,max x y]` THEN
  REWRITE_TAC[PATH_CONNECTED_IN_EUCLIDEANREAL_INTERVAL; IN_REAL_INTERVAL;
              PATH_CONNECTED_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[REAL_LE_MAX; REAL_MIN_LE; REAL_LE_REFL] THEN
  REWRITE_TAC[\<subseteq>; IN_REAL_INTERVAL] THEN
  X_GEN_TAC `z::real` THEN STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  MAP_EVERY EXISTS_TAC [`min x y::real`; `max x y::real`] THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[real_min; real_max] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[]);;

lemma path_connectedin_discrete_topology:
   "\<And>u s::A=>bool.
       path_connectedin (discrete_topology u) s \<longleftrightarrow>
       s \<subseteq> u \<and> \<exists>a. s \<subseteq> {a}"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN;
              CONNECTED_IN_DISCRETE_TOPOLOGY];
    REWRITE_TAC[SET_RULE `s \<subseteq> u \<and> (\<exists>a. s \<subseteq> {a}) \<longleftrightarrow>
                          s = {} \<or> \<exists>a. a \<in> u \<and> s = {a}`] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[PATH_CONNECTED_IN_EMPTY] THEN
    ASM_REWRITE_TAC[PATH_CONNECTED_IN_SING; TOPSPACE_DISCRETE_TOPOLOGY]]);;

lemma path_connected_space_discrete_topology:
   "\<And>u::A=>bool.
        path_connected_space (discrete_topology u) \<longleftrightarrow>
        \<exists>a. u \<subseteq> {a}"
oops
  REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE;
              PATH_CONNECTED_IN_DISCRETE_TOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_DISCRETE_TOPOLOGY] THEN SET_TAC[]);;

lemma path_connected_space_prod_topology:
   "        path_connected_space(prod_topology top1 top2) \<longleftrightarrow>
        topspace(prod_topology top1 top2) = {} \<or>
        path_connected_space top1 \<and> path_connected_space top2"
oops
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THEN
  ASM_SIMP_TAC[PATH_CONNECTED_SPACE_TOPSPACE_EMPTY] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_PROD_TOPOLOGY;
        CROSS_EQ_EMPTY; DE_MORGAN_THM]) THEN
  EQ_TAC THENL
   [REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE] THEN REPEAT STRIP_TAC THENL
     [MP_TAC(ISPECL [`fst::A#B=>A`; `prod_topology top1 top2:(A#B)topology`;
                     `top1::A topology`;
                     `topspace(prod_topology top1 top2:(A#B)topology)`]
        PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE);
      MP_TAC(ISPECL [`snd::A#B=>B`; `prod_topology top1 top2:(A#B)topology`;
                     `top2::B topology`;
                     `topspace(prod_topology top1 top2:(A#B)topology)`]
        PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE)] THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND] THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY] THEN
    ASM_REWRITE_TAC[IMAGE_FST_CROSS; IMAGE_SND_CROSS];
    REWRITE_TAC[path_connected_space; NOT_EXISTS_THM] THEN STRIP_TAC] THEN
  REWRITE_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
  MAP_EVERY X_GEN_TAC [`x1::A`; `x2::B`; `y1::A`; `y2::B`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x2::B`; `y2::B`]) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x1::A`; `y1::A`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g1::real=>A` THEN STRIP_TAC THEN
  X_GEN_TAC `g2::real=>B` THEN STRIP_TAC THEN
  EXISTS_TAC `(\<lambda>t. g1 t,g2 t):real=>A#B` THEN
  ASM_REWRITE_TAC[path_in; CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX] THEN
  ASM_REWRITE_TAC[GSYM path_in]);;

lemma path_connectedin_cross:
   "\<And>top1 top2 s::A=>bool t::B=>bool.
        path_connectedin (prod_topology top1 top2) (s \<times> t) \<longleftrightarrow>
        s = {} \<or> t = {} \<or>
        path_connectedin top1 s \<and> path_connectedin top2 t"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_connectedin; SUBTOPOLOGY_CROSS] THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_PROD_TOPOLOGY; TOPSPACE_PROD_TOPOLOGY] THEN
  REWRITE_TAC[SUBSET_CROSS; CROSS_EQ_EMPTY; TOPSPACE_SUBTOPOLOGY] THEN
  ASM_CASES_TAC `s::A=>bool = {}` THEN ASM_REWRITE_TAC[INTER_EMPTY] THEN
  ASM_CASES_TAC `t::B=>bool = {}` THEN ASM_REWRITE_TAC[INTER_EMPTY] THEN
  ASM_CASES_TAC `(s::A=>bool) \<subseteq> topspace top1` THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC `(t::B=>bool) \<subseteq> topspace top2` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC[SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`]);;

lemma path_connected_space_product_topology:
   "\<And>tops::K=>A topology k.
        path_connected_space(product_topology k tops) \<longleftrightarrow>
        topspace(product_topology k tops) = {} \<or>
        \<forall>i. i \<in> k \<Longrightarrow> path_connected_space(tops i)"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(product_topology k (tops::K=>A topology)) = {}` THEN
  ASM_SIMP_TAC[PATH_CONNECTED_SPACE_TOPSPACE_EMPTY] THEN EQ_TAC THENL
   [REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE] THEN DISCH_TAC THEN
    X_GEN_TAC `i::K` THEN DISCH_TAC THEN FIRST_ASSUM(MP_TAC \<circ>
      ISPECL [`\<lambda>(f::K=>A). f i`; `(tops::K=>A topology) i`] \<circ>
      MATCH_MP(REWRITE_RULE[IMP_CONJ_ALT]
        PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION] THEN
    REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY] THEN
    REWRITE_TAC[IMAGE_PROJECTION_CARTESIAN_PRODUCT] THEN
    ASM_REWRITE_TAC[GSYM TOPSPACE_PRODUCT_TOPOLOGY; o_THM];
    DISCH_TAC] THEN
  REWRITE_TAC[path_connected_space; TOPSPACE_PRODUCT_TOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`x::K=>A`; `y::K=>A`] THEN STRIP_TAC THEN
  SUBGOAL_THEN
   `\<forall>i. \<exists>g. i \<in> k
            \<Longrightarrow> path_in ((tops::K=>A topology) i) g \<and>
                g 0 = x i \<and> g 1 = y i`
  MP_TAC THENL
   [X_GEN_TAC `i::K` THEN ASM_CASES_TAC `(i::K) \<in> k` THEN ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `i::K`) THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[path_connected_space] THEN DISCH_THEN MATCH_MP_TAC THEN
    RULE_ASSUM_TAC(REWRITE_RULE[PiE; o_DEF; IN_ELIM_THM]) THEN
    ASM_SIMP_TAC[];
    REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `g::K=>real->A` THEN STRIP_TAC THEN
  EXISTS_TAC `\<lambda>a i. if i \<in> k then (g::K=>real->A) i a else undefined` THEN
  REWRITE_TAC[] THEN CONJ_TAC THENL
   [SIMP_TAC[path_in; CONTINUOUS_MAP_COMPONENTWISE] THEN
    SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; EXTENSIONAL; IN_ELIM_THM] THEN
    ASM_SIMP_TAC[GSYM path_in; ETA_AX];
    CONJ_TAC THENL
     [UNDISCH_TAC `(x::K=>A) \<in> PiE k (topspace \<circ> tops)`;
      UNDISCH_TAC `(y::K=>A) \<in> PiE k (topspace \<circ> tops)`] THEN
    SIMP_TAC[PiE; EXTENSIONAL; IN_ELIM_THM] THEN
    REWRITE_TAC[FUN_EQ_THM; o_THM] THEN ASM_MESON_TAC[]]);;

lemma path_connectedin_cartesian_product:
   "\<And>tops::K=>A topology s k.
        path_connectedin (product_topology k tops) (PiE k s) \<longleftrightarrow>
        PiE k s = {} \<or>
        \<forall>i. i \<in> k \<Longrightarrow> path_connectedin (tops i) (s i)"
oops
  REWRITE_TAC[path_connectedin; SUBTOPOLOGY_CARTESIAN_PRODUCT] THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[SUBSET_CARTESIAN_PRODUCT; TOPSPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[CARTESIAN_PRODUCT_EQ_EMPTY; o_DEF; TOPSPACE_SUBTOPOLOGY] THEN
  SET_TAC[]);;


subsection\<open>Path components\<close>


let path_component_of = new_definition
 `path_component_of X x y \<longleftrightarrow>
        \<exists>g. path_in X g \<and> g 0 = x \<and> g 1 = y`;;

let path_components_of = new_definition
 `path_components_of X = {path_component_of X x |x| x \<in> topspace X}`;;

lemma path_component_in_topspace:
   "        path_component_of X x y \<Longrightarrow> x \<in> topspace X \<and> y \<in> topspace X"
oops
  REWRITE_TAC[path_component_of; path_in; continuous_map] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  REPEAT STRIP_TAC THEN REPEAT(FIRST_X_ASSUM(SUBST1_TAC \<circ> SYM)) THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN
  REAL_ARITH_TAC);;

lemma path_component_of_refl:
   "path_component_of X x x \<longleftrightarrow> x \<in> topspace X"
oops
  REPEAT GEN_TAC THEN
  EQ_TAC THENL [MESON_TAC[PATH_COMPONENT_IN_TOPSPACE]; DISCH_TAC] THEN
  REWRITE_TAC[path_component_of] THEN
  EXISTS_TAC `(\<lambda>t. x):real=>A` THEN ASM_REWRITE_TAC[PATH_IN_CONST]);;

lemma path_component_of_sym:
   "path_component_of X x y \<longleftrightarrow> path_component_of X y x"
oops
  REPEAT GEN_TAC THEN EQ_TAC THEN
  REWRITE_TAC[path_component_of; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::real=>A` THEN REWRITE_TAC[path_in] THEN STRIP_TAC THEN
  EXISTS_TAC `(g::real=>A) \<circ> (\<lambda>t. 1 - t)` THEN
  REWRITE_TAC[o_THM] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `subtopology euclideanreal (real_interval [0,1])` THEN
  ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
  REWRITE_TAC[IN_REAL_INTERVAL] THEN
  (CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST; CONTINUOUS_MAP_ID]);;

lemma path_component_of_trans:
   "        path_component_of X x y \<and> path_component_of X y z
        \<Longrightarrow> path_component_of X x z"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_component_of; path_in] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN `g1::real=>A` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN `g2::real=>A` STRIP_ASSUME_TAC)) THEN
  EXISTS_TAC
   `\<lambda>x. if x \<le> 1 / 2 then ((g1::real=>A) \<circ> (\<lambda>t. 2 * t)) x
        else (g2 \<circ> (\<lambda>t. 2 * t - 1)) x` THEN
  REWRITE_TAC[o_THM] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONTINUOUS_MAP_CASES_LE THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
  SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_ID] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `subtopology euclideanreal (real_interval [0,1])` THEN
  ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; SUBTOPOLOGY_SUBTOPOLOGY;
        TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE; IN_INTER;
        IN_REAL_INTERVAL; IN_ELIM_THM] THEN
  (CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
  REPEAT(MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB) THEN REPEAT CONJ_TAC THEN
  REPEAT(MATCH_MP_TAC CONTINUOUS_MAP_REAL_MUL) THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST; CONTINUOUS_MAP_ID]);;

lemma path_component_of_subtopology:
   "        path_component_of (subtopology X s) x y
        \<Longrightarrow> path_component_of X x y"
oops
  REWRITE_TAC[path_component_of; PATH_IN_SUBTOPOLOGY] THEN
  MESON_TAC[]);;

lemma path_component_of_mono:
   "        path_component_of (subtopology X s) x y \<and> s \<subseteq> t
        \<Longrightarrow> path_component_of (subtopology X t) x y"
oops
  REWRITE_TAC[path_component_of; PATH_IN_SUBTOPOLOGY] THEN
  MESON_TAC[\<subseteq>]);;

lemma path_component_of:
   "        path_component_of X x y \<longleftrightarrow>
        \<exists>t. path_connectedin X t \<and> x \<in> t \<and> y \<in> t"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[path_component_of] THEN
  EQ_TAC THENL [ALL_TAC; MESON_TAC[PATH_CONNECTED_IN]] THEN
  DISCH_THEN(X_CHOOSE_THEN `g::real=>A` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `image (g::real=>A) (real_interval[0,1])` THEN
  ASM_SIMP_TAC[PATH_CONNECTED_IN_PATH_IMAGE] THEN
  REPEAT(FIRST_X_ASSUM(SUBST1_TAC \<circ> SYM)) THEN CONJ_TAC THEN
  MATCH_MP_TAC FUN_IN_IMAGE THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV);;

lemma path_component_of_set:
   "        path_component_of X x =
        {y. \<exists>g. path_in X g \<and> g 0 = x \<and> g 1 = y}"
oops
  REWRITE_TAC[EXTENSION; IN_ELIM_THM] THEN
  REWRITE_TAC[\<in>; path_component_of]);;

lemma path_component_of_set_alt:
   "         path_component_of X x =
         {y. \<exists>t. path_connectedin X t \<and> x \<in> t \<and> y \<in> t}"
oops
  REPEAT GEN_TAC THEN GEN_REWRITE_TAC id [EXTENSION] THEN
  GEN_TAC THEN GEN_REWRITE_TAC LAND_CONV [\<in>] THEN
  REWRITE_TAC[PATH_COMPONENT_OF; IN_ELIM_THM]);;

lemma path_component_of_subtopology_eq:
   "      path_component_of (subtopology X u) x =
      path_component_of X x \<longleftrightarrow>
      path_component_of X x \<subseteq> u"
oops
  REWRITE_TAC[PATH_COMPONENT_OF_SET_ALT; PATH_CONNECTED_IN_SUBTOPOLOGY] THEN
  SET_TAC[]);;

lemma path_components_of_subtopology:
   "\<And>X u c::A=>bool.
        c \<in> path_components_of X \<and> c \<subseteq> u
        \<Longrightarrow> c \<in> path_components_of (subtopology X u)"
oops
  GEN_TAC THEN GEN_TAC THEN
  SIMP_TAC[path_components_of; IMP_CONJ; FORALL_IN_GSPEC] THEN
  X_GEN_TAC `x::A` THEN REPEAT DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `x::A` \<circ> GEN_REWRITE_RULE id [\<subseteq>]) THEN
  ANTS_TAC THENL
   [ASM_MESON_TAC[PATH_COMPONENT_OF_REFL; \<in>]; DISCH_TAC] THEN
  REWRITE_TAC[IN_ELIM_THM] THEN EXISTS_TAC `x::A` THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  ASM_MESON_TAC[PATH_COMPONENT_OF_SUBTOPOLOGY_EQ]);;

lemma path_component_of_subset_topspace:
   "(path_component_of X x) \<subseteq> topspace X"
oops
  REWRITE_TAC[\<subseteq>; \<in>] THEN MESON_TAC[PATH_COMPONENT_IN_TOPSPACE; \<in>]);;

lemma path_component_of_eq_empty:
   "path_component_of X x = {} \<longleftrightarrow> (x \<notin> topspace X)"
oops
  REWRITE_TAC[EXTENSION; NOT_IN_EMPTY] THEN
  MESON_TAC[\<in>; PATH_COMPONENT_OF_REFL; PATH_COMPONENT_IN_TOPSPACE]);;

lemma path_connected_space_iff_path_component:
   "        path_connected_space X \<longleftrightarrow>
        \<forall>x y. x \<in> topspace X \<and> y \<in> topspace X
              \<Longrightarrow> path_component_of X x y"
oops
  REWRITE_TAC[path_connected_space; path_component_of]);;

lemma path_connected_space_imp_path_component_of:
   "        path_connected_space X \<and> a \<in> topspace X \<and> b \<in> topspace X
        \<Longrightarrow> path_component_of X a b"
oops
  MESON_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT]);;

lemma path_connected_space_path_component_set:
   "path_connected_space X \<longleftrightarrow>
         \<forall>x::A. x \<in> topspace X \<Longrightarrow> path_component_of X x = topspace X"
oops
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT;
              GSYM SUBSET_ANTISYM_EQ] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_SUBSET_TOPSPACE] THEN SET_TAC[]);;

lemma path_component_of_maximal:
   "     path_connectedin X s \<and> x \<in> s \<Longrightarrow> s \<subseteq> (path_component_of X x)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[PATH_CONNECTED_IN] THEN STRIP_TAC THEN
  REWRITE_TAC[\<subseteq>; PATH_COMPONENT_OF_SET; IN_ELIM_THM] THEN
  ASM_MESON_TAC[]);;

lemma path_component_of_equiv:
   "        path_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        path_component_of X x = path_component_of X y"
oops
  REWRITE_TAC[FUN_EQ_THM] THEN
  MESON_TAC[PATH_COMPONENT_OF_REFL; PATH_COMPONENT_OF_TRANS;
            PATH_COMPONENT_OF_SYM]);;

lemma path_component_of_disjoint:
   "        disjnt (path_component_of X x) (path_component_of X y) \<longleftrightarrow>
        \<not> (path_component_of X x y)"
oops
  REWRITE_TAC[disjnt; EXTENSION; IN_INTER; NOT_IN_EMPTY] THEN
  REWRITE_TAC[\<in>] THEN
  MESON_TAC[PATH_COMPONENT_OF_SYM; PATH_COMPONENT_OF_TRANS]);;

lemma path_component_of_eq:
   "        path_component_of X x = path_component_of X y \<longleftrightarrow>
        (x \<notin> topspace X) \<and> (y \<notin> topspace X) \<or>
        x \<in> topspace X \<and> y \<in> topspace X \<and> path_component_of X x y"
oops
  MESON_TAC[PATH_COMPONENT_OF_REFL; PATH_COMPONENT_OF_EQUIV;
            PATH_COMPONENT_OF_EQ_EMPTY]);;

lemma path_connectedin_path_component_of:
   "path_connectedin X (path_component_of X x)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[path_connectedin; PATH_COMPONENT_OF_SUBSET_TOPSPACE] THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT] THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; PATH_COMPONENT_OF_SUBSET_TOPSPACE] THEN
  SUBGOAL_THEN
   `\<forall>y. y \<in> path_component_of X (x::A)
        \<Longrightarrow> path_component_of (subtopology X (path_component_of X x)) x y`
  MP_TAC THENL
   [X_GEN_TAC `y::A` THEN REWRITE_TAC[\<in>];
    MESON_TAC[PATH_COMPONENT_OF_SYM; PATH_COMPONENT_OF_TRANS]] THEN
  REWRITE_TAC[path_component_of] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `g::real=>A` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[PATH_IN_SUBTOPOLOGY; SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x \<in> t) \<longleftrightarrow> f ` s \<subseteq> t`] THEN
  MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
  ASM_SIMP_TAC[PATH_CONNECTED_IN_PATH_IMAGE; IN_IMAGE] THEN
  EXISTS_TAC `0::real` THEN ASM_REWRITE_TAC[IN_REAL_INTERVAL] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV);;

lemma unions_path_components_of:
   "\<Union> (path_components_of X) = topspace X"
oops
  GEN_TAC THEN REWRITE_TAC[path_components_of] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[UNIONS_SUBSET; FORALL_IN_GSPEC;
              PATH_COMPONENT_OF_SUBSET_TOPSPACE] THEN
  REWRITE_TAC[\<subseteq>; UNIONS_GSPEC; IN_ELIM_THM] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN EXISTS_TAC `x::A` THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[\<in>] THEN
  ASM_REWRITE_TAC[PATH_COMPONENT_OF_REFL]);;

lemma path_components_of_maximal:
   "\<And>X s c::A=>bool.
        c \<in> path_components_of X \<and> path_connectedin X s \<and> \<not> disjnt c s
        \<Longrightarrow> s \<subseteq> c"
oops
  REWRITE_TAC[path_components_of; IMP_CONJ; FORALL_IN_GSPEC;
    LEFT_IMP_EXISTS_THM; SET_RULE `\<not> disjnt P t \<longleftrightarrow> \<exists>x. P x \<and> x \<in> t`] THEN
  SIMP_TAC[PATH_COMPONENT_OF_EQUIV] THEN
  MESON_TAC[PATH_COMPONENT_OF_MAXIMAL]);;

lemma pairwise_disjoint_path_components_of:
   "pairwise disjnt (path_components_of X)"
oops
  SIMP_TAC[pairwise; IMP_CONJ; path_components_of; RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC[PATH_COMPONENT_OF_EQ; PATH_COMPONENT_OF_DISJOINT]);;

lemma complement_path_components_of_unions:
   "
        c \<in> path_components_of X
        \<Longrightarrow> topspace X - c = \<Union> (path_components_of X - {c})"
oops
  REWRITE_TAC[SET_RULE `s - {a} = s - {a}`] THEN
  ASM_SIMP_TAC[GSYM DIFF_UNIONS_PAIRWISE_DISJOINT;
               PAIRWISE_DISJOINT_PATH_COMPONENTS_OF; SING_SUBSET] THEN
  REWRITE_TAC[UNIONS_PATH_COMPONENTS_OF; UNIONS_1]);;

lemma nonempty_path_components_of:
   " c \<in> path_components_of X \<Longrightarrow> (c \<noteq> {})"
oops
  SIMP_TAC[path_components_of; FORALL_IN_GSPEC; PATH_COMPONENT_OF_EQ_EMPTY]);;

lemma path_components_of_subset:
   " c \<in> path_components_of X \<Longrightarrow> c \<subseteq> topspace X"
oops
  SIMP_TAC[path_components_of; FORALL_IN_GSPEC;
           PATH_COMPONENT_OF_SUBSET_TOPSPACE]);;

lemma path_connectedin_path_components_of:
   " c \<in> path_components_of X \<Longrightarrow> path_connectedin X c"
oops
  REWRITE_TAC[path_components_of; FORALL_IN_GSPEC] THEN
  REWRITE_TAC[PATH_CONNECTED_IN_PATH_COMPONENT_OF]);;

lemma path_component_in_path_components_of:
   "        path_component_of X a \<in> path_components_of X \<longleftrightarrow>
        a \<in> topspace X"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
    SIMP_TAC[GSYM PATH_COMPONENT_OF_EQ_EMPTY] THEN
    MESON_TAC[NONEMPTY_PATH_COMPONENTS_OF];
    REWRITE_TAC[path_components_of] THEN SET_TAC[]]);;

lemma path_connectedin_unions:
   "\<And>X u:(A=>bool)->bool.
        (\<forall>s. s \<in> u \<Longrightarrow> path_connectedin X s) \<and> \<not> (\<Inter> u = {})
        \<Longrightarrow> path_connectedin X (\<Union> u)"
oops
  REWRITE_TAC[path_connectedin] THEN SIMP_TAC[UNIONS_SUBSET] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC `a::A`) THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT] THEN
  SUBGOAL_THEN
   `\<forall>x. x \<in> topspace (subtopology X (\<Union> u))
        \<Longrightarrow> path_component_of (subtopology X (\<Union> u)) (a::A) x`
  MP_TAC THENL
   [REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IMP_CONJ_ALT; IN_INTER];
    ASM_MESON_TAC[PATH_COMPONENT_OF_SYM; PATH_COMPONENT_OF_TRANS]] THEN
  REWRITE_TAC[FORALL_IN_UNIONS] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `b::A`] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `s::A=>bool`) THEN
  ASM_REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPECL [`a::A`; `b::A`])) THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY; path_component_of; PATH_IN_SUBTOPOLOGY] THEN
  ASM SET_TAC[]);;

lemma path_connectedin_union:
   "\<And>X s t::A=>bool.
        path_connectedin X s \<and> path_connectedin X t \<and> \<not> (s \<inter> t = {})
        \<Longrightarrow> path_connectedin X (s \<union> t)"
oops
  REWRITE_TAC[GSYM UNIONS_2; GSYM INTERS_2] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC PATH_CONNECTED_IN_UNIONS THEN
  ASM SET_TAC[]);;

lemma path_connected_space_iff_components_eq:
   "        path_connected_space X \<longleftrightarrow>
        !c c'. c \<in> path_components_of X \<and>
               c' \<in> path_components_of X
               \<Longrightarrow> c = c'"
oops
  REWRITE_TAC[path_components_of; IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT] THEN
  SIMP_TAC[PATH_COMPONENT_OF_EQ] THEN MESON_TAC[]);;

lemma path_components_of_eq_empty:
   "path_components_of X = {} \<longleftrightarrow> topspace X = {}"
oops
  REWRITE_TAC[path_components_of] THEN SET_TAC[]);;

lemma path_components_of_empty_space:
   "topspace X = {} \<Longrightarrow> path_components_of X = {}"
oops
  REWRITE_TAC[PATH_COMPONENTS_OF_EQ_EMPTY]);;

lemma path_components_of_subset_sing:
   "
        path_components_of X \<subseteq> {s} \<longleftrightarrow>
        path_connected_space X \<and> (topspace X = {} \<or> topspace X = s)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_COMPONENTS_EQ; SET_RULE
   `(\<forall>x y. x \<in> s \<and> y \<in> s \<Longrightarrow> x = y) \<longleftrightarrow> s = {} \<or> \<exists>a. s = {a}`] THEN
  ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[PATH_COMPONENTS_OF_EMPTY_SPACE; EMPTY_SUBSET] THEN
  ASM_REWRITE_TAC[PATH_COMPONENTS_OF_EQ_EMPTY; SET_RULE
   `s \<subseteq> {a} \<longleftrightarrow> s = {} \<or> s = {a}`] THEN
  MESON_TAC[UNIONS_PATH_COMPONENTS_OF; UNIONS_1]);;

lemma path_connected_space_iff_components_subset_sing:
   "        path_connected_space X \<longleftrightarrow> \<exists>a. path_components_of X \<subseteq> {a}"
oops
  MESON_TAC[PATH_COMPONENTS_OF_SUBSET_SING]);;

lemma path_components_of_eq_sing:
   "
        path_components_of X = {s} \<longleftrightarrow>
        path_connected_space X \<and> \<not> (topspace X = {}) \<and> s = topspace X"
oops
  REWRITE_TAC[PATH_COMPONENTS_OF_SUBSET_SING;
              PATH_COMPONENTS_OF_EQ_EMPTY;
              SET_RULE `s = {a} \<longleftrightarrow> s \<subseteq> {a} \<and> (s \<noteq> {})`] THEN
  MESON_TAC[]);;

lemma path_components_of_path_connected_space:
   "        path_connected_space X
        \<Longrightarrow> path_components_of X =
            if topspace X = {} then {} else {topspace X}"
oops
  ASM_MESON_TAC[PATH_COMPONENTS_OF_EMPTY_SPACE;
                PATH_COMPONENTS_OF_EQ_SING]);;

lemma path_component_subset_connected_component_of:
   "path_component_of X x \<subseteq> connected_component_of X x"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `(x::A) \<in> topspace X` THENL
   [MATCH_MP_TAC CONNECTED_COMPONENT_OF_MAXIMAL THEN
    SIMP_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN;
             PATH_CONNECTED_IN_PATH_COMPONENT_OF] THEN
    REWRITE_TAC[\<in>] THEN ASM_REWRITE_TAC[PATH_COMPONENT_OF_REFL];
    ASM_MESON_TAC[PATH_COMPONENT_OF_EQ_EMPTY; EMPTY_SUBSET]]);;

lemma path_imp_connected_component_of:
   "path_component_of X x y \<Longrightarrow> connected_component_of X x y"
oops
  GEN_TAC THEN GEN_TAC THEN
  REWRITE_TAC[SET_RULE `(\<forall>y. P y \<Longrightarrow> Q y) \<longleftrightarrow> P \<subseteq> Q`] THEN
  REWRITE_TAC[ETA_AX; PATH_COMPONENT_SUBSET_CONNECTED_COMPONENT_OF]);;

lemma exists_path_component_of_superset:
   "
        path_connectedin X s \<and> \<not> (topspace X = {})
        \<Longrightarrow> \<exists>c. c \<in> path_components_of X \<and> s \<subseteq> c"
oops
  REPEAT STRIP_TAC THEN ASM_CASES_TAC `s::A=>bool = {}` THENL
   [ASM_REWRITE_TAC[EMPTY_SUBSET; MEMBER_NOT_EMPTY] THEN
    ASM_REWRITE_TAC[PATH_COMPONENTS_OF_EQ_EMPTY];
    UNDISCH_TAC `\<not> (s::A=>bool = {})` THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `a::A` THEN DISCH_TAC THEN
  EXISTS_TAC `path_component_of X (a::A)` THEN CONJ_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[path_connectedin]) THEN
    REWRITE_TAC[PATH_COMPONENT_IN_PATH_COMPONENTS_OF] THEN ASM SET_TAC[];
    MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
    ASM_REWRITE_TAC[]]);;

lemma path_component_of_eq_overlap:
   "      path_component_of X x = path_component_of X y \<longleftrightarrow>
      (x \<notin> topspace X) \<and> (y \<notin> topspace X) \<or>
      \<not> (path_component_of X x \<inter> path_component_of X y = {})"
oops
  REWRITE_TAC[GSYM disjnt; PATH_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_EQ] THEN
  MESON_TAC[PATH_COMPONENT_IN_TOPSPACE]);;

lemma path_component_of_nonoverlap:
   "     path_component_of X x \<inter> path_component_of X y = {} \<longleftrightarrow>
     (x \<notin> topspace X) \<or> (y \<notin> topspace X) \<or>
     \<not> (path_component_of X x = path_component_of X y)"
oops
  REWRITE_TAC[GSYM disjnt; PATH_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_EQ] THEN
  MESON_TAC[PATH_COMPONENT_IN_TOPSPACE]);;

lemma path_component_of_overlap:
   "    \<not> (path_component_of X x \<inter> path_component_of X y = {}) \<longleftrightarrow>
    x \<in> topspace X \<and> y \<in> topspace X \<and>
    path_component_of X x = path_component_of X y"
oops
  REWRITE_TAC[GSYM disjnt; PATH_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_EQ] THEN
  MESON_TAC[PATH_COMPONENT_IN_TOPSPACE]);;

lemma path_components_of_disjoint:
   "\<And>X c c'.
        c \<in> path_components_of X \<and> c' \<in> path_components_of X
        \<Longrightarrow> (disjnt c c' \<longleftrightarrow> (c \<noteq> c'))"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; path_components_of] THEN
  SIMP_TAC[FORALL_IN_GSPEC; disjnt; PATH_COMPONENT_OF_NONOVERLAP]);;

lemma path_components_of_overlap:
   "\<And>X c c'.
        c \<in> path_components_of X \<and> c' \<in> path_components_of X
        \<Longrightarrow> (\<not> (c \<inter> c' = {}) \<longleftrightarrow> c = c')"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; path_components_of] THEN
  SIMP_TAC[FORALL_IN_GSPEC; disjnt; PATH_COMPONENT_OF_NONOVERLAP]);;

lemma card_le_path_components_of_topspace:
   "path_components_of X \<lesssim> topspace X"
oops
  GEN_TAC THEN MATCH_MP_TAC CARD_LE_RELATIONAL_FULL THEN
  EXISTS_TAC `(\<in>):A->(A=>bool)->bool` THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP PATH_COMPONENTS_OF_SUBSET) THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP NONEMPTY_PATH_COMPONENTS_OF) THEN
    SET_TAC[];
    MESON_TAC[REWRITE_RULE[GSYM MEMBER_NOT_EMPTY; IN_INTER]
                PATH_COMPONENTS_OF_OVERLAP]]);;

lemma finite_path_components_of_finite:
   "        finite(topspace X) \<Longrightarrow> finite(path_components_of X)"
oops
  GEN_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CARD_LE_FINITE) THEN
  REWRITE_TAC[CARD_LE_PATH_COMPONENTS_OF_TOPSPACE]);;

lemma path_component_of_unique:
   "        x \<in> c \<and> path_connectedin X c \<and>
        (!c'. x \<in> c' \<and> path_connectedin X c' \<Longrightarrow> c' \<subseteq> c)
        \<Longrightarrow> path_component_of X x = c"
oops
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE `R = s \<longleftrightarrow> \<forall>x. R x \<longleftrightarrow> x \<in> s`] THEN
  REWRITE_TAC[PATH_COMPONENT_OF] THEN ASM SET_TAC[]);;

lemma path_component_of_discrete_topology:
   "path_component_of (discrete_topology u) x =
           if x \<in> u then {x} else {}"
oops
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[PATH_COMPONENT_OF_EQ_EMPTY;
                  TOPSPACE_DISCRETE_TOPOLOGY] THEN
  MATCH_MP_TAC PATH_COMPONENT_OF_UNIQUE THEN
  ASM_REWRITE_TAC[PATH_CONNECTED_IN_DISCRETE_TOPOLOGY;
                  IN_SING; SING_SUBSET] THEN
  SET_TAC[]);;

lemma path_components_of_discrete_topology:
   "\<And>u::A=>bool.
        path_components_of (discrete_topology u) = {{x} | x \<in> u}"
oops
  GEN_TAC THEN REWRITE_TAC[path_components_of] THEN
  REWRITE_TAC[TOPSPACE_DISCRETE_TOPOLOGY;
              PATH_COMPONENT_OF_DISCRETE_TOPOLOGY] THEN
  SET_TAC[]);;

lemma path_component_of_continuous_image:
   "\<And>X X' f x y.
        continuous_map X X' f \<and>
        path_component_of X x y
        \<Longrightarrow> path_component_of X' (f x) (f y)"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[path_component_of] THEN
  DISCH_THEN(X_CHOOSE_THEN `g::real=>A` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `f \<circ> (g::real=>A)` THEN ASM_REWRITE_TAC[o_THM] THEN
  ASM_MESON_TAC[PATH_IN_COMPOSE]);;

lemma homeomorphic_map_path_component_of:
   "\<And>f X X' x.
        homeomorphic_map X X' f \<and> x \<in> topspace X
        \<Longrightarrow> path_component_of X' (f x) =
            f ` (path_component_of X x)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[HOMEOMORPHIC_MAP_MAPS; homeomorphic_maps] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN `g::B=>A` STRIP_ASSUME_TAC) ASSUME_TAC) THEN
  REWRITE_TAC[EXTENSION; IN_IMAGE] THEN REWRITE_TAC[\<in>] THEN
  MP_TAC(ISPEC `X':B topology` PATH_COMPONENT_IN_TOPSPACE) THEN
  MP_TAC(ISPECL [`X::A topology`; `X':B topology`; `f::A=>B`]
        PATH_COMPONENT_OF_CONTINUOUS_IMAGE) THEN
  MP_TAC(ISPECL [`X':B topology`; `X::A topology`; `g::B=>A`]
        PATH_COMPONENT_OF_CONTINUOUS_IMAGE) THEN
  ASM_REWRITE_TAC[] THEN REPEAT
   (FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE)) THEN
  ASM SET_TAC[]);;

lemma homeomorphic_map_path_components_of:
   "\<And>f X X'.
      homeomorphic_map X X' f
      \<Longrightarrow> path_components_of X' = image (f `) (path_components_of X)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[path_components_of; SIMPLE_IMAGE] THEN
  FIRST_ASSUM(SUBST1_TAC \<circ> SYM \<circ> MATCH_MP HOMEOMORPHIC_IMP_SURJECTIVE_MAP) THEN
  REWRITE_TAC[GSYM IMAGE_o; o_DEF] THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x = g x) \<Longrightarrow> f ` s = g ` s`) THEN
  REWRITE_TAC[] THEN ASM_MESON_TAC[HOMEOMORPHIC_MAP_PATH_COMPONENT_OF]);;

lemma path_component_of_pair:
   "\<And>top1 top2 (x::A) (y::B).
        path_component_of (prod_topology top1 top2) (x,y) =
        path_component_of top1 x \<times> path_component_of top2 y"
oops
  REPEAT GEN_TAC THEN MATCH_MP_TAC(SET_RULE
   `(s = {} \<longleftrightarrow> t = {}) \<and> ((s \<noteq> {}) \<Longrightarrow> (s = t)) \<Longrightarrow> s = t`) THEN
  REWRITE_TAC[CROSS_EQ_EMPTY; PATH_COMPONENT_OF_EQ_EMPTY;
              TOPSPACE_PROD_TOPOLOGY; IN_CROSS; DE_MORGAN_THM] THEN
  STRIP_TAC THEN MATCH_MP_TAC PATH_COMPONENT_OF_UNIQUE THEN
  SIMP_TAC[PATH_CONNECTED_IN_CROSS; PATH_CONNECTED_IN_PATH_COMPONENT_OF] THEN
  REWRITE_TAC[IN_CROSS] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> ONCE_DEPTH_CONV) [\<in>] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_REFL] THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `c::A#B=>bool` THEN STRIP_TAC THEN
  TRANS_TAC SUBSET_TRANS `(fst ` c \<times> snd ` c):A#B=>bool` THEN
  CONJ_TAC THENL
   [REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_CROSS] THEN
    REWRITE_TAC[IN_IMAGE; EXISTS_PAIR_THM] THEN MESON_TAC[];
    REWRITE_TAC[SUBSET_CROSS] THEN REPEAT DISJ2_TAC THEN
    CONJ_TAC THEN MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
    REWRITE_TAC[IN_IMAGE; EXISTS_PAIR_THM] THEN
    (CONJ_TAC THENL [ALL_TAC; ASM_MESON_TAC[]]) THEN
    MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
    ASM_MESON_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND]]);;

lemma path_components_of_prod_topology:
   "\<And>(top1::A topology) (top2::B topology).
        path_components_of (prod_topology top1 top2) =
        {c1 \<times> c2 | c1 \<in> path_components_of top1 \<and>
                       c2 \<in> path_components_of top2}"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[path_components_of; TOPSPACE_PROD_TOPOLOGY; \<times>] THEN
  REWRITE_TAC[SET_RULE `{f z | z \<in> {x,y | P x y}} = {f(x,y) | P x y}`] THEN
  REWRITE_TAC[GSYM \<times>; PATH_COMPONENT_OF_PAIR] THEN SET_TAC[]);;

lemma path_component_of_product_topology:
   "\<And>k (tops::K=>A topology) x.
        path_component_of (product_topology k tops) x =
        if EXTENSIONAL k x
        then PiE k (\<lambda>i. path_component_of (tops i) (x i))
        else {}"
oops
  REPEAT GEN_TAC THEN MATCH_MP_TAC(SET_RULE
   `(s = {} \<longleftrightarrow> t = {}) \<and> ((s \<noteq> {}) \<Longrightarrow> (s = t)) \<Longrightarrow> s = t`) THEN
  REWRITE_TAC[MESON[] `(if p then x else y) = y \<longleftrightarrow> p \<Longrightarrow> x = y`] THEN
  REWRITE_TAC[PATH_COMPONENT_OF_EQ_EMPTY; CARTESIAN_PRODUCT_EQ_EMPTY] THEN
  REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; IN_ELIM_THM] THEN
  REWRITE_TAC[o_THM; GSYM PiE] THEN
  CONJ_TAC THENL [MESON_TAC[]; STRIP_TAC THEN ASM_REWRITE_TAC[]] THEN
  MATCH_MP_TAC PATH_COMPONENT_OF_UNIQUE THEN
  SIMP_TAC[PATH_CONNECTED_IN_CARTESIAN_PRODUCT;
           PATH_CONNECTED_IN_PATH_COMPONENT_OF] THEN
  ASM_REWRITE_TAC[PiE; IN_ELIM_THM] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[PATH_COMPONENT_OF_REFL; \<in>]; ALL_TAC] THEN
  X_GEN_TAC `c:(K=>A)->bool` THEN STRIP_TAC THEN
  TRANS_TAC SUBSET_TRANS
   `PiE k (\<lambda>i. image (\<lambda>x. x i) c):(K=>A)->bool` THEN
  REWRITE_TAC[GSYM PiE; SUBSET_CARTESIAN_PRODUCT] THEN
  CONJ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP PATH_CONNECTED_IN_SUBSET_TOPSPACE) THEN
    REWRITE_TAC[\<subseteq>; PiE; IN_ELIM_THM;
                TOPSPACE_PRODUCT_TOPOLOGY; o_THM; IN_IMAGE] THEN
    ASM_MESON_TAC[];
    DISJ2_TAC THEN X_GEN_TAC `i::K` THEN STRIP_TAC THEN
    MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
    REWRITE_TAC[IN_IMAGE] THEN CONJ_TAC THENL [ALL_TAC; ASM_MESON_TAC[]] THEN
    MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
    ASM_MESON_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION]]);;

lemma path_components_of_product_topology:
   "\<And>k (tops::K=>A topology).
        path_components_of (product_topology k tops) =
        { PiE k c |c|
          \<forall>i. i \<in> k \<Longrightarrow> c i \<in> path_components_of(tops i)}"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[path_components_of; PATH_COMPONENT_OF_PRODUCT_TOPOLOGY] THEN
  MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> p x) \<and> {PiE k y | y \<in> f ` s} = t
    \<Longrightarrow> {if p x then PiE k (f x) else z | x \<in> s} = t`) THEN
  CONJ_TAC THENL
   [SIMP_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; IN_ELIM_THM];
    ALL_TAC] THEN
  REWRITE_TAC[IN_ELIM_THM; RIGHT_IMP_EXISTS_THM; SKOLEM_THM] THEN
  REWRITE_TAC[IN_IMAGE; TOPSPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[PiE; IN_ELIM_THM] THEN
  REWRITE_TAC[GSYM PiE; o_THM] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [MATCH_MP_TAC(SET_RULE
     `(\<forall>x. P x \<Longrightarrow> Q x) \<Longrightarrow> {f x | P x} \<subseteq> {f x | Q x}`) THEN
    GEN_TAC THEN MATCH_MP_TAC MONO_EXISTS THEN SIMP_TAC[];
    REWRITE_TAC[\<subseteq>; FORALL_IN_GSPEC] THEN
    X_GEN_TAC `c::K=>A->bool` THEN DISCH_THEN(X_CHOOSE_TAC `x::K=>A`) THEN
    REWRITE_TAC[IN_ELIM_THM; CARTESIAN_PRODUCT_EQ] THEN
    REWRITE_TAC[LEFT_AND_EXISTS_THM] THEN
    ONCE_REWRITE_TAC[SWAP_EXISTS_THM] THEN
    REWRITE_TAC[GSYM CONJ_ASSOC; UNWIND_THM2] THEN
    EXISTS_TAC `RESTRICTION k (x::K=>A)` THEN
    SIMP_TAC[RESTRICTION; EXTENSIONAL; IN_ELIM_THM] THEN
    ASM_MESON_TAC[]]);;


subsection\<open>Special characterizations of classes of functions into and out of R\<close>


lemma embedding_map_into_euclideanreal:
   "\<And>X f::A=>real.
        path_connected_space X
        \<Longrightarrow> (embedding_map X euclideanreal f \<longleftrightarrow>
             continuous_map X euclideanreal f \<and>
             \<forall>x y. x \<in> topspace X \<and> y \<in> topspace X \<and> f x = f y
                   \<Longrightarrow> x = y)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[embedding_map; HOMEOMORPHIC_EQ_EVERYTHING_MAP] THEN
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN MESON_TAC[];
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)] THEN
  REWRITE_TAC[INJECTIVE_ON_LEFT_INVERSE; embedding_map] THEN
  REWRITE_TAC[HOMEOMORPHIC_MAP_MAPS; homeomorphic_maps] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::real=>A` THEN
  DISCH_TAC THEN ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[SUBSET_REFL; TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[FORALL_IN_IMAGE] THEN
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[GSYM MTOPOLOGY_SUBMETRIC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FROM_METRIC] THEN
  REWRITE_TAC[SUBMETRIC; REAL_EUCLIDEAN_METRIC; INTER_UNIV] THEN
  ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IMP_CONJ] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  X_GEN_TAC `t::A=>bool` THEN REPEAT STRIP_TAC THEN
  ABBREV_TAC `s = image (f::A=>real) (topspace X)` THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `topspace X::A=>bool` \<circ> MATCH_MP
   (REWRITE_RULE[IMP_CONJ] PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
  ASM_REWRITE_TAC[PATH_CONNECTED_IN_TOPSPACE;
                  PATH_CONNECTED_IN_EUCLIDEANREAL] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN
   `\<exists>u v d. 0 < d \<and> u \<in> topspace X \<and> v \<in> topspace X \<and>
            s \<inter> real_interval[f x - d,f x + d]
            \<subseteq> real_interval[(f::A=>real) u,f v]`
  STRIP_ASSUME_TAC THENL
   [ASM_CASES_TAC `\<exists>u. u \<in> topspace X \<and> (f::A=>real) u < f x` THENL
     [FIRST_X_ASSUM(X_CHOOSE_THEN `u::A` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC `u::A`;
      EXISTS_TAC `x::A`] THEN
    (ASM_CASES_TAC `\<exists>v. v \<in> topspace X \<and> (f::A=>real) x < f v` THENL
     [FIRST_X_ASSUM(X_CHOOSE_THEN `v::A` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC `v::A`;
      EXISTS_TAC `x::A`])
    THENL
     [EXISTS_TAC `min ((f::A=>real) x - f u) (f v - f x)`;
      EXISTS_TAC `(f::A=>real) x - f u`;
      EXISTS_TAC `(f::A=>real) v - f x`;
      EXISTS_TAC `1`] THEN
    (ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC]) THEN
    EXPAND_TAC "s" THEN REWRITE_TAC[\<subseteq>; IN_INTER; IMP_CONJ] THEN
    REWRITE_TAC[FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
    X_GEN_TAC `y::A` THEN DISCH_TAC THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::A` \<circ>
     GEN_REWRITE_RULE id [NOT_EXISTS_THM])) THEN
    ASM_REWRITE_TAC[] THEN ASM_REAL_ARITH_TAC;
    ALL_TAC] THEN
  SUBGOAL_THEN
    `\<exists>c::A=>bool. compactin X c \<and> connectedin X c \<and>
                 u \<in> c \<and> v \<in> c`
  STRIP_ASSUME_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [path_connected_space]) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`u::A`; `v::A`]) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `h::real=>A` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `image (h::real=>A) (real_interval[0,1])` THEN
    ASM_SIMP_TAC[COMPACT_IN_PATH_IMAGE; CONNECTED_IN_PATH_IMAGE] THEN
    MAP_EVERY EXPAND_TAC ["u"; "v"] THEN CONJ_TAC THEN
    MATCH_MP_TAC FUN_IN_IMAGE THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN
    CONV_TAC REAL_RAT_REDUCE_CONV;
    ALL_TAC] THEN
  SUBGOAL_THEN
   `continuous_map(subtopology euclideanreal
                    (s \<inter> real_interval [f(x::A) - d,f x + d]),
                   subtopology X c)
                  (g::real=>A)`
  MP_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_INVERSE_MAP THEN EXISTS_TAC `f::A=>real` THEN
    REWRITE_TAC[HAUSDORFF_SPACE_EUCLIDEANREAL] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; COMPACT_SPACE_SUBTOPOLOGY;
                 TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
    TRANS_TAC SUBSET_TRANS `real_interval[f(u::A),f v]` THEN
    ASM_SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; SET_RULE
      `c \<subseteq> u \<Longrightarrow> u \<inter> c = c`] THEN
    MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN
    ASM_SIMP_TAC[FUN_IN_IMAGE; GSYM CONNECTED_IN_EUCLIDEANREAL] THEN
    ASM_MESON_TAC[CONNECTED_IN_CONTINUOUS_MAP_IMAGE];
    ALL_TAC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  DISCH_THEN(MP_TAC \<circ> CONJUNCT1) THEN
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[GSYM MTOPOLOGY_SUBMETRIC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FROM_METRIC] THEN
  DISCH_THEN(MP_TAC \<circ> CONJUNCT2) THEN
  REWRITE_TAC[SUBMETRIC; REAL_EUCLIDEAN_METRIC; INTER_UNIV] THEN
  EXPAND_TAC "s" THEN REWRITE_TAC[IN_INTER; IMP_CONJ] THEN
  REWRITE_TAC[FORALL_IN_IMAGE] THEN DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN
  ASM_REWRITE_TAC[IN_REAL_INTERVAL] THEN
  ANTS_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `t::A=>bool`) THEN
  ASM_SIMP_TAC[LEFT_IMP_EXISTS_THM; IMP_IMP; GSYM CONJ_ASSOC] THEN
  X_GEN_TAC `e::real` THEN STRIP_TAC THEN
  EXISTS_TAC `min (d::real) e` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  X_GEN_TAC `y::A` THEN STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[] THEN ASM_REAL_ARITH_TAC);;

lemma monotone_map_into_euclideanreal_alt:
   "\<And>X (f::A=>real).
        continuous_map X euclideanreal f
        \<Longrightarrow> ((\<forall>k. is_interval k
                  \<Longrightarrow> connectedin X {x \<in> topspace X. f x \<in> k}) \<longleftrightarrow>
             connected_space X \<and> monotone_map X euclideanreal f)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[MONOTONE_MAP; TOPSPACE_EUCLIDEANREAL; SUBSET_UNIV] THEN
  EQ_TAC THEN STRIP_TAC THENL
   [CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `UNIV`) THEN
      REWRITE_TAC[IS_REALINTERVAL_UNIV; IN_UNIV; IN_GSPEC] THEN
      REWRITE_TAC[CONNECTED_IN_TOPSPACE];
      X_GEN_TAC `y::real` THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{y::real}`) THEN
      REWRITE_TAC[IS_REALINTERVAL_SING; IN_SING]];
    ALL_TAC] THEN
  SUBGOAL_THEN
   `\<forall>a b u v. a < b \<and>
              closedin X u \<and> closedin X v \<and>
              (u \<noteq> {}) \<and> (v \<noteq> {}) \<and> disjnt u v \<and>
              {x::A | x \<in> topspace X \<and> f x \<in> real_interval[a,b]} =
              u \<union> v \<and>
              disjnt u {x \<in> topspace X. f x = b} \<and>
              disjnt v {x \<in> topspace X. f x = a}
              \<Longrightarrow> False`
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONNECTED_SPACE_CLOSED_IN]) THEN
    REWRITE_TAC[] THEN MAP_EVERY EXISTS_TAC
     [`u \<union> {x \<in> topspace X. (f::A=>real) x \<in> {c. c \<le> a}}`;
      `v \<union> {x \<in> topspace X. (f::A=>real) x \<in> {c. b \<le> c}}`] THEN
    GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
     [CONJ_TAC THEN MATCH_MP_TAC CLOSED_IN_UNION THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
      EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[GSYM REAL_CLOSED_IN] THEN
      REWRITE_TAC[REAL_CLOSED_HALFSPACE_LE] THEN
      REWRITE_TAC[REWRITE_RULE[real_ge] REAL_CLOSED_HALFSPACE_GE];
      ALL_TAC] THEN
    REPEAT CONJ_TAC THENL
     [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
       `{x. x \<in> t \<and> R x}  = u \<union> v
        \<Longrightarrow> (\<forall>x. P x \<or> Q x \<or> R x)
            \<Longrightarrow> t \<subseteq> (u \<union> {x. x \<in> t \<and> P x}) \<union>
                         (v \<union> {x. x \<in> t \<and> Q x})`)) THEN
      REWRITE_TAC[IN_REAL_INTERVAL; IN_ELIM_THM] THEN REAL_ARITH_TAC;
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
       `{x. x \<in> t \<and> R x}  = u \<union> v
        \<Longrightarrow> disjnt u v \<and> (\<forall>x. \<not> (P x \<and> Q x)) \<and>
            disjnt u {x. x \<in> t \<and> Q x \<and> R x} \<and>
            disjnt v {x. x \<in> t \<and> P x \<and> R x}
            \<Longrightarrow> (u \<union> {x. x \<in> t \<and> P x}) \<inter>
                (v \<union> {x. x \<in> t \<and> Q x}) = {}`)) THEN
      ASM_SIMP_TAC[IN_ELIM_THM; IN_REAL_INTERVAL; REAL_ARITH
       `a < b \<Longrightarrow> (b \<le> x \<and> a \<le> x \<and> x \<le> b \<longleftrightarrow> x = b) \<and>
                  (x \<le> a \<and> a \<le> x \<and> x \<le> b \<longleftrightarrow> x = a)`] THEN
      ASM_REAL_ARITH_TAC;
      ASM SET_TAC[];
      ASM SET_TAC[]];
    X_GEN_TAC `k::real=>bool` THEN DISCH_TAC THEN
    REWRITE_TAC[CONNECTED_IN_CLOSED_IN; SUBSET_RESTRICT; SET_RULE
     `P \<and> Q \<and> R \<and> S \<and>
      \<not> (u \<inter> {x. x \<in> t \<and> f x \<in> k} = {}) \<and>
      \<not> (v \<inter> {x. x \<in> t \<and> f x \<in> k} = {}) \<longleftrightarrow>
      \<exists>a b. a \<in> k \<and> b \<in> k \<and> P \<and> Q \<and> R \<and> S \<and>
            \<not> disjnt u {x. x \<in> t \<and> f x = a} \<and>
            \<not> disjnt v {x. x \<in> t \<and> f x = b}`] THEN
    ONCE_REWRITE_TAC[MESON[]
     `\<not> (\<exists>a b c d. P a b c d) \<longleftrightarrow> \<forall>c d a b. \<not> P a b c d`] THEN
    MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
     [MESON_TAC[INTER_ACI; UNION_COMM]; ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`a::real`; `b::real`] THEN DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
    SUBGOAL_THEN
      `image (f::A=>real) u \<inter> f ` v \<inter> k = {}`
    ASSUME_TAC THENL
     [REWRITE_TAC[SET_RULE
       `(f ` u) \<inter> f ` v \<inter> k = {} \<longleftrightarrow>
        \<forall>a b. a \<in> u \<and> b \<in> v \<and> f a = f b \<and> f b \<in> k \<Longrightarrow> False`] THEN
      MAP_EVERY X_GEN_TAC [`p::A`; `q::A`] THEN REPEAT STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONNECTED_IN_CLOSED_IN] \<circ>
       SPEC `(f::A=>real) q`) THEN
      REWRITE_TAC[SUBSET_RESTRICT] THEN
      MAP_EVERY EXISTS_TAC [`u::A=>bool`; `v::A=>bool`] THEN
      ASM_REWRITE_TAC[] THEN
      REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
      ASM SET_TAC[];
      ALL_TAC] THEN
    FIRST_X_ASSUM(DISJ_CASES_TAC \<circ> GEN_REWRITE_RULE id [REAL_LE_LT])
    THENL [ALL_TAC; ASM SET_TAC[]] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL
     [`a::real`; `b::real`;
      `u \<inter> {x::A | x \<in> topspace X \<and> f x \<in> real_interval[a,b]}`;
      `v \<inter> {x::A | x \<in> topspace X \<and> f x \<in> real_interval[a,b]}`]) THEN
    ASM_REWRITE_TAC[] THEN GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
     [CONJ_TAC THEN MATCH_MP_TAC CLOSED_IN_INTER THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
      EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[GSYM REAL_CLOSED_IN] THEN
      REWRITE_TAC[REAL_CLOSED_REAL_INTERVAL];
      ALL_TAC] THEN
    GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
     [CONJ_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
       `\<not> disjnt u {x. x \<in> t \<and> f x = a}
        \<Longrightarrow> a \<in> s
            \<Longrightarrow> \<not> (u \<inter> {x. x \<in> t \<and> f x \<in> s} = {})`)) THEN
      REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC;
      SUBGOAL_THEN `real_interval[a,b] \<subseteq> k` ASSUME_TAC THENL
       [FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [is_interval]) THEN
        REWRITE_TAC[\<subseteq>; IN_REAL_INTERVAL] THEN REPEAT STRIP_TAC THEN
        ASM_MESON_TAC[];
        ASM SET_TAC[]]]]);;

lemma monotone_map_into_euclideanreal:
   "\<And>X (f::A=>real).
        connected_space X \<and> continuous_map X euclideanreal f
        \<Longrightarrow> (monotone_map X euclideanreal f \<longleftrightarrow>
             \<forall>k. is_interval k
                  \<Longrightarrow> connectedin X {x \<in> topspace X. f x \<in> k})"
oops
  SIMP_TAC[MONOTONE_MAP_INTO_EUCLIDEANREAL_ALT]);;

lemma monotone_map_euclideanreal_alt:
   "      (\<forall>c. is_interval c \<Longrightarrow> is_interval {x. x \<in> s \<and> f x \<in> c}) \<longleftrightarrow>
      is_interval s \<and>
      ((\<forall>x y. x \<in> s \<and> y \<in> s \<and> x \<le> y \<Longrightarrow> f x \<le> f y) \<or>
       (\<forall>x y. x \<in> s \<and> y \<in> s \<and> x \<le> y \<Longrightarrow> f y \<le> f x))"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [ALL_TAC; REWRITE_TAC[is_interval; IN_ELIM_THM] THEN SET_TAC[]] THEN
  DISCH_TAC THEN MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN
  CONJ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `UNIV`) THEN
    REWRITE_TAC[IS_REALINTERVAL_UNIV; IN_UNIV; IN_GSPEC];
    REWRITE_TAC[is_interval] THEN DISCH_TAC THEN
    REWRITE_TAC[REAL_NON_MONOTONE; NOT_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`a::real`; `b::real`; `c::real`] THEN
    STRIP_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{y.  y < (f::real=>real) b}`);
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{y. (f::real=>real) b < y}`)] THEN
    REWRITE_TAC[is_interval; IN_ELIM_THM; NOT_IMP] THEN
    (CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC]) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`a::real`; `c::real`; `b::real`]) THEN
    ASM_SIMP_TAC[REAL_LT_IMP_LE; REAL_LT_REFL]]);;

lemma monotone_map_euclideanreal:
   "is_interval s \<and>
         continuous_map(subtopology euclideanreal s,euclideanreal) f
         \<Longrightarrow> (monotone_map(subtopology euclideanreal s,euclideanreal) f \<longleftrightarrow>
              (\<forall>x y. x \<in> s \<and> y \<in> s \<and> x \<le> y \<Longrightarrow> f x \<le> f y) \<or>
              (\<forall>x y. x \<in> s \<and> y \<in> s \<and> x \<le> y \<Longrightarrow> f y \<le> f x))"
oops
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC[MONOTONE_MAP_INTO_EUCLIDEANREAL; CONNECTED_SPACE_SUBTOPOLOGY;
               CONNECTED_IN_EUCLIDEANREAL; CONNECTED_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; SUBSET_RESTRICT] THEN
  ASM_REWRITE_TAC[MONOTONE_MAP_EUCLIDEANREAL_ALT]);;

lemma injective_eq_monotone_map:
   "is_interval s \<and>
         continuous_map(subtopology euclideanreal s,euclideanreal) f
         \<Longrightarrow> ((\<forall>x y. x \<in> s \<and> y \<in> s \<and> f x = f y \<Longrightarrow> x = y) \<longleftrightarrow>
              (\<forall>x y. x \<in> s \<and> y \<in> s \<and> x < y \<Longrightarrow> f x < f y) \<or>
              (\<forall>x y. x \<in> s \<and> y \<in> s \<and> x < y \<Longrightarrow> f y < f x))"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[STRICTLY_INCREASING_ALT; STRICTLY_DECREASING_ALT] THEN
  REWRITE_TAC[TAUT `(p \<longleftrightarrow> q \<and> p \<or> r \<and> p) \<longleftrightarrow> (p \<Longrightarrow> q \<or> r)`] THEN
  REWRITE_TAC[INJECTIVE_ON_ALT] THEN DISCH_TAC THEN
  ASM_SIMP_TAC[GSYM MONOTONE_MAP_EUCLIDEANREAL] THEN
  MATCH_MP_TAC INJECTIVE_IMP_MONOTONE_MAP THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL; INTER_UNIV] THEN
  ASM SET_TAC[]);;

lemma injective_eq_real_open_map_euclideanreal:
   "is_interval s \<and>
         continuous_map(subtopology euclideanreal s,euclideanreal) f
         \<Longrightarrow> ((\<forall>x y. x \<in> s \<and> y \<in> s \<and> f x = f y \<Longrightarrow> x = y) \<longleftrightarrow>
              \<forall>u. real_open u \<and> u \<subseteq> s \<Longrightarrow> real_open(f ` u))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_SIMP_TAC[INJECTIVE_EQ_MONOTONE_MAP] THEN REWRITE_TAC[real_open] THEN
    STRIP_TAC THEN X_GEN_TAC `u::real=>bool` THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    REWRITE_TAC[FORALL_IN_IMAGE] THEN MATCH_MP_TAC MONO_FORALL THEN
    X_GEN_TAC `x::real` THEN
    ASM_CASES_TAC `(x::real) \<in> u` THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[REAL_ARITH
     `abs(y - x) < e \<longleftrightarrow> x - e < y \<and> y < x + e`] THEN
    REWRITE_TAC[GSYM IN_REAL_INTERVAL; GSYM \<subseteq>] THEN
    DISCH_THEN(X_CHOOSE_THEN `r::real` STRIP_ASSUME_TAC) THENL
     [EXISTS_TAC
       `min ((f::real=>real)(x + r / 2) - f x) (f x - f(x - r / 2))` THEN
      CONJ_TAC THENL
       [ASM_REWRITE_TAC[REAL_LT_MIN; REAL_SUB_LT] THEN
        CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN REPEAT CONJ_TAC THEN
        REPEAT(FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [\<subseteq>])) THEN
        REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC;
        ALL_TAC] THEN
      TRANS_TAC SUBSET_TRANS `real_interval[f(x - r / 2),f(x + r / 2)]` THEN
      CONJ_TAC THENL
       [SIMP_TAC[SUBSET_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC; ALL_TAC] THEN
      TRANS_TAC SUBSET_TRANS
        `image (f::real=>real) (real_interval(x - r,x + r))` THEN
      ASM_SIMP_TAC[IMAGE_SUBSET] THEN
      MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN CONJ_TAC THENL
       [REWRITE_TAC[GSYM CONNECTED_IN_EUCLIDEANREAL] THEN
        MATCH_MP_TAC CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
        EXISTS_TAC `subtopology euclideanreal s` THEN
        ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY; IS_REALINTERVAL_INTERVAL;
                        CONNECTED_IN_EUCLIDEANREAL] THEN
        ASM SET_TAC[];
        CONJ_TAC THEN MATCH_MP_TAC FUN_IN_IMAGE THEN
        REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC];
      EXISTS_TAC
       `min ((f::real=>real)(x - r / 2) - f x) (f x - f(x + r / 2))` THEN
      CONJ_TAC THENL
       [ASM_REWRITE_TAC[REAL_LT_MIN; REAL_SUB_LT] THEN
        CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN REPEAT CONJ_TAC THEN
        REPEAT(FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [\<subseteq>])) THEN
        REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC;
        ALL_TAC] THEN
      TRANS_TAC SUBSET_TRANS `real_interval[f(x + r / 2),f(x - r / 2)]` THEN
      CONJ_TAC THENL
       [SIMP_TAC[SUBSET_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC; ALL_TAC] THEN
      TRANS_TAC SUBSET_TRANS
        `image (f::real=>real) (real_interval(x - r,x + r))` THEN
      ASM_SIMP_TAC[IMAGE_SUBSET] THEN
      MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN CONJ_TAC THENL
       [REWRITE_TAC[GSYM CONNECTED_IN_EUCLIDEANREAL] THEN
        MATCH_MP_TAC CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
        EXISTS_TAC `subtopology euclideanreal s` THEN
        ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY; IS_REALINTERVAL_INTERVAL;
                        CONNECTED_IN_EUCLIDEANREAL] THEN
        ASM SET_TAC[];
        CONJ_TAC THEN MATCH_MP_TAC FUN_IN_IMAGE THEN
        REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC]];
    DISCH_TAC THEN MATCH_MP_TAC REAL_WLOG_LT THEN
    REWRITE_TAC[] THEN CONJ_TAC THENL [MESON_TAC[]; ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`a::real`; `b::real`] THEN REPEAT STRIP_TAC THEN
    SUBGOAL_THEN
     `\<exists>u v. image (f::real=>real) (real_interval[a,b]) = real_interval[u,v]`
    STRIP_ASSUME_TAC THENL
     [REWRITE_TAC[GSYM REAL_COMPACT_IS_REALINTERVAL] THEN CONJ_TAC THENL
       [REWRITE_TAC[real_compact_def] THEN
        MATCH_MP_TAC IMAGE_COMPACT_IN THEN
        EXISTS_TAC `subtopology euclideanreal s` THEN
        ASM_REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN
        REWRITE_TAC[COMPACT_IN_EUCLIDEANREAL_INTERVAL] THEN
        MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN
        ASM_REWRITE_TAC[];
        REWRITE_TAC[GSYM CONNECTED_IN_EUCLIDEANREAL] THEN
        MATCH_MP_TAC CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
        EXISTS_TAC `subtopology euclideanreal s` THEN
        ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN
        REWRITE_TAC[CONNECTED_IN_EUCLIDEANREAL_INTERVAL] THEN
        MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN
        ASM_REWRITE_TAC[]];
      SUBGOAL_THEN
       `\<exists>x. x \<in> real_interval(a,b) \<and>
            (f::real=>real) x \<in> {u,v}`
      STRIP_ASSUME_TAC THENL
       [REWRITE_TAC[REAL_OPEN_CLOSED_INTERVAL] THEN
        ASM_CASES_TAC `v::real = u` THENL
         [MATCH_MP_TAC(SET_RULE
           `f ` s = {u} \<and> \<not> (s - {a,b} = {})
            \<Longrightarrow> \<exists>x. x \<in> s - {a,b} \<and> f x \<in> {u,v}`) THEN
          ASM_REWRITE_TAC[GSYM REAL_OPEN_CLOSED_INTERVAL] THEN
          ASM_REWRITE_TAC[REAL_INTERVAL_SING; REAL_INTERVAL_NE_EMPTY];
          SUBGOAL_THEN
           `u \<in> image (f::real=>real) (real_interval [a,b]) \<and>
            v \<in> image (f::real=>real) (real_interval [a,b])`
          MP_TAC THENL
           [ASM_REWRITE_TAC[ENDS_IN_REAL_INTERVAL] THEN
            ASM_MESON_TAC[IMAGE_EQ_EMPTY; REAL_INTERVAL_NE_EMPTY;
                          REAL_LT_LE];
            REWRITE_TAC[IN_IMAGE] THEN MATCH_MP_TAC(SET_RULE
             `f a = f b \<and> (u \<noteq> v) \<Longrightarrow>
              (\<exists>x. u = f x \<and> x \<in> s) \<and> (\<exists>x. v = f x \<and> x \<in> s)
              \<Longrightarrow> \<exists>x. x \<in> s - {a,b} \<and> f x \<in> {u,v}`) THEN
            ASM_REWRITE_TAC[]]];
        ALL_TAC] THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `real_interval(a,b)`) THEN
      REWRITE_TAC[REAL_OPEN_REAL_INTERVAL] THEN
      MATCH_MP_TAC(TAUT `p \<and> \<not> q \<Longrightarrow> (p \<Longrightarrow> q) \<Longrightarrow> r`) THEN
      REWRITE_TAC[REAL_OPEN_CLOSED_INTERVAL] THEN CONJ_TAC THENL
       [MATCH_MP_TAC(SET_RULE `s \<subseteq> u \<Longrightarrow> s - t \<subseteq> u`) THEN
        MATCH_MP_TAC IS_REALINTERVAL_CONTAINS_INTERVAL THEN
        ASM_REWRITE_TAC[];
        ALL_TAC] THEN
      REWRITE_TAC[real_open; FORALL_IN_IMAGE] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `x::real`) THEN
      ASM_REWRITE_TAC[GSYM REAL_OPEN_CLOSED_INTERVAL] THEN
      DISCH_THEN(X_CHOOSE_THEN `d::real`
       (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
      REWRITE_TAC[REAL_OPEN_CLOSED_INTERVAL] THEN MATCH_MP_TAC(SET_RULE
        `(\<exists>x. P x \<and> (x \<notin> f ` s))
         \<Longrightarrow> \<not> (\<forall>x. P x \<Longrightarrow> x \<in> f ` (s - t))`) THEN
      ASM_REWRITE_TAC[] THEN
      FIRST_X_ASSUM(DISJ_CASES_THEN SUBST1_TAC \<circ> MATCH_MP (SET_RULE
       `x \<in> {a,b} \<Longrightarrow> x = a \<or> x = b`))
      THENL [EXISTS_TAC `u - d / 2`; EXISTS_TAC `v + d / 2`] THEN
      REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC]]);;


subsection\<open>Normal spaces including Urysohn's lemma and the Tietze extension theorem\<close>


let normal_space = new_definition
 `normal_space (X::A topology) \<longleftrightarrow>
        \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
              \<Longrightarrow> \<exists>u v. openin X u \<and> openin X v \<and>
                        s \<subseteq> u \<and> t \<subseteq> v \<and>
                        disjnt u v`;;

lemma normal_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> normal_space X \<Longrightarrow> normal_space X'"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ] THEN
  REWRITE_TAC[normal_space; retraction_map; retraction_maps;
              LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `r':B=>A` THEN REPEAT DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [`s::B=>bool`; `t::B=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL
   [`{x \<in> topspace X. (r::A=>B) x \<in> s}`;
    `{x \<in> topspace X. (r::A=>B) x \<in> t}`]) THEN
  ANTS_TAC THENL
   [REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    CONJ_TAC THEN MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
    ASM_MESON_TAC[];
    REWRITE_TAC[LEFT_IMP_EXISTS_THM; IN_ELIM_THM]] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [`{x. x \<in> topspace X' \<and> (r':B=>A) x \<in> u}`;
    `{x. x \<in> topspace X' \<and> (r':B=>A) x \<in> v}`] THEN
  GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
    ASM_MESON_TAC[];
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
    RULE_ASSUM_TAC(REWRITE_RULE[continuous_map]) THEN ASM SET_TAC[]]);;

lemma homeomorphic_normal_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (normal_space X \<longleftrightarrow> normal_space X')"
oops
  REWRITE_TAC[homeomorphic_space; HOMEOMORPHIC_MAPS_MAP] THEN
  ASM_MESON_TAC[NORMAL_SPACE_RETRACTION_MAP_IMAGE;
                HOMEOMORPHIC_IMP_RETRACTION_MAP]);;

lemma normal_space:
   "      normal_space (X::A topology) \<longleftrightarrow>
      \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
            \<Longrightarrow> \<exists>u. openin X u \<and>
                    s \<subseteq> u \<and> disjnt t (X closure_of u)"
oops
  GEN_TAC THEN REWRITE_TAC[normal_space] THEN
  AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `s::A=>bool` THEN REWRITE_TAC[] THEN AP_TERM_TAC THEN
  GEN_REWRITE_TAC id [FUN_EQ_THM] THEN X_GEN_TAC `t::A=>bool` THEN
  REWRITE_TAC[] THEN MATCH_MP_TAC(TAUT
   `(p \<Longrightarrow> (q \<longleftrightarrow> r)) \<Longrightarrow> (p \<Longrightarrow> q \<longleftrightarrow> p \<Longrightarrow> r)`) THEN STRIP_TAC THEN
  AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `u::A=>bool` THEN REWRITE_TAC[] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN `v::A=>bool` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[] THEN FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
     `t \<subseteq> v \<Longrightarrow> v \<inter> c = {} \<Longrightarrow> disjnt t c`)) THEN
    ASM_SIMP_TAC[OPEN_IN_INTER_CLOSURE_OF_EQ_EMPTY] THEN ASM SET_TAC[];
    STRIP_TAC THEN EXISTS_TAC `topspace X - X closure_of u::A=>bool` THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE; CLOSED_IN_CLOSURE_OF] THEN
    MP_TAC(ISPECL [`X::A topology`; `u::A=>bool`] CLOSURE_OF_SUBSET) THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN ASM SET_TAC[]]);;

lemma normal_space_alt:
   "      normal_space (X::A topology) \<longleftrightarrow>
      \<forall>s u. closedin X s \<and> openin X u \<and> s \<subseteq> u
            \<Longrightarrow> \<exists>v. openin X v \<and> s \<subseteq> v \<and> X closure_of v \<subseteq> u"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; FORALL_OPEN_IN] THEN
  REWRITE_TAC[SET_RULE `s \<subseteq> t - u \<longleftrightarrow> s \<subseteq> t \<and> disjnt u s`] THEN
  REWRITE_TAC[CLOSURE_OF_SUBSET_TOPSPACE; NORMAL_SPACE] THEN
  MESON_TAC[CLOSED_IN_SUBSET; DISJOINT_SYM]);;

lemma normal_space_closures:
   "        normal_space X \<longleftrightarrow>
        \<forall>s t. s \<subseteq> topspace X \<and> t \<subseteq> topspace X \<and>
              disjnt (X closure_of s) (X closure_of t)
              \<Longrightarrow> \<exists>u v. openin X u \<and>
                        openin X v \<and>
                        s \<subseteq> u \<and>
                        t \<subseteq> v \<and>
                        disjnt u v"
oops
  GEN_TAC THEN REWRITE_TAC[normal_space] THEN EQ_TAC THENL
   [DISCH_TAC; METIS_TAC[CLOSURE_OF_CLOSED_IN; CLOSED_IN_SUBSET]] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL
   [`X closure_of s::A=>bool`; `X closure_of t::A=>bool`]) THEN
  ASM_SIMP_TAC[CLOSED_IN_CLOSURE_OF] THEN
  ASM_MESON_TAC[CLOSURE_OF_SUBSET; SUBSET_TRANS]);;

lemma normal_space_disjoint_closures:
   "        normal_space X \<longleftrightarrow>
        \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
              \<Longrightarrow> \<exists>u v. openin X u \<and> openin X v \<and>
                        s \<subseteq> u \<and> t \<subseteq> v \<and>
                        disjnt (X closure_of u) (X closure_of v)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[normal_space] THEN EQ_TAC THENL
   [DISCH_TAC;
    REPEAT(MATCH_MP_TAC MONO_FORALL THEN GEN_TAC) THEN
    MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
    REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(SET_RULE
     `s \<subseteq> s' \<and> t \<subseteq> t' \<Longrightarrow> disjnt s' t' \<Longrightarrow> disjnt s t`) THEN
    ASM_SIMP_TAC[CLOSURE_OF_SUBSET; OPEN_IN_SUBSET]] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`]) THEN
  ANTS_TAC THENL [ASM_REWRITE_TAC[]; REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL
   [`s::A=>bool`; `topspace X - u::A=>bool`]) THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE] THEN
  ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `u':A=>bool` THEN
  DISCH_THEN(X_CHOOSE_THEN `v':A=>bool` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `v::A=>bool` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC(SET_RULE
   `!t'. t' \<inter> s = {} \<and> t \<subseteq> t' \<Longrightarrow> disjnt s t`) THEN
  EXISTS_TAC `v':A=>bool` THEN
  ASM_SIMP_TAC[OPEN_IN_INTER_CLOSURE_OF_EQ_EMPTY] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  TRANS_TAC SUBSET_TRANS `topspace X - u::A=>bool` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CLOSURE_OF_MINIMAL THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE] THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
  ASM SET_TAC[]);;

lemma normal_space_dual:
   "        normal_space X \<longleftrightarrow>
        \<forall>u v. openin X u \<and> openin X v \<and> u \<union> v = topspace X
              \<Longrightarrow> \<exists>s t. closedin X s \<and> closedin X t \<and>
                        s \<subseteq> u \<and> t \<subseteq> v \<and> s \<union> t = topspace X"
oops
  GEN_TAC THEN REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[RIGHT_EXISTS_AND_THM] THEN
  REWRITE_TAC[FORALL_OPEN_IN; EXISTS_CLOSED_IN] THEN
  REWRITE_TAC[RIGHT_AND_EXISTS_THM; GSYM CONJ_ASSOC] THEN
  ONCE_REWRITE_TAC[TAUT `p \<and> q \<and> r \<longleftrightarrow> \<not> (p \<and> q \<Longrightarrow> \<not> r)`] THEN
  SIMP_TAC[OPEN_IN_SUBSET; CLOSED_IN_SUBSET; SET_RULE
   `u \<subseteq> t \<and> v \<subseteq> t
    \<Longrightarrow> (t - u \<subseteq> t - v \<longleftrightarrow> v \<subseteq> u) \<and>
        (t - u \<union> t - v = t \<longleftrightarrow> disjnt u v)`] THEN
  REWRITE_TAC[normal_space] THEN MESON_TAC[]);;

lemma normal_t1_imp_Hausdorff_space:
   "        normal_space X \<and> t1_space X \<Longrightarrow> Hausdorff_space X"
oops
  REWRITE_TAC[T1_SPACE_CLOSED_IN_SING; normal_space; Hausdorff_space] THEN
  GEN_TAC THEN STRIP_TAC THEN MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN
  STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`{x::A}`; `{y::A}`]) THEN
  ASM_SIMP_TAC[SING_SUBSET; SET_RULE `disjnt {x} {y} \<longleftrightarrow> (x \<noteq> y)`]);;

lemma normal_t1_eq_Hausdorff_space:
   "        normal_space X \<Longrightarrow> (t1_space X \<longleftrightarrow> Hausdorff_space X)"
oops
  MESON_TAC[NORMAL_T1_IMP_HAUSDORFF_SPACE; HAUSDORFF_IMP_T1_SPACE]);;

lemma normal_t1_imp_regular_space:
   "        normal_space X \<and> t1_space X \<Longrightarrow> regular_space X"
oops
  REWRITE_TAC[T1_SPACE_CLOSED_IN_SING; normal_space; regular_space] THEN
  GEN_TAC THEN STRIP_TAC THEN MAP_EVERY X_GEN_TAC [`s::A=>bool`; `x::A`] THEN
  STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`{x::A}`; `s::A=>bool`]) THEN
  ASM_SIMP_TAC[SING_SUBSET] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM SET_TAC[]);;

lemma compact_Hausdorff_or_regular_imp_normal_space:
   "        compact_space X \<and> (Hausdorff_space X \<or> regular_space X)
        \<Longrightarrow> normal_space X"
oops
  REWRITE_TAC[HAUSDORFF_SPACE_COMPACT_SETS;
              REGULAR_SPACE_COMPACT_CLOSED_SETS] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[normal_space] THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_MESON_TAC[CLOSED_IN_COMPACT_SPACE]);;

lemma normal_space_mtopology:
   "normal_spacemtopology"
oops
  GEN_TAC THEN REWRITE_TAC[normal_space] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
  MP_TAC(ISPEC `m::A metric` OPEN_IN_MTOPOLOGY) THEN DISCH_THEN(fun th ->
   MP_TAC(SPEC `topspace mtopology - t::A=>bool` th) THEN
   MP_TAC(SPEC `topspace mtopology - s::A=>bool` th)) THEN
  ASM_SIMP_TAC[OPEN_IN_DIFF; CLOSED_IN_DIFF; OPEN_IN_TOPSPACE;
               CLOSED_IN_TOPSPACE; IMP_IMP] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> ONCE_DEPTH_CONV) [RIGHT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[IMP_IMP; SKOLEM_THM] THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY; SUBSET_DIFF] THEN
  SIMP_TAC[\<subseteq>; mball; IN_DIFF; IN_ELIM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN `d::A=>real` (LABEL_TAC "d"))
   (X_CHOOSE_THEN `e::A=>real` (LABEL_TAC "e"))) THEN
  MAP_EVERY EXISTS_TAC
   [`\<Union> {mball m (x::A,e x / 2) | x \<in> s}`;
    `\<Union> {mball m (x::A,d x / 2) | x \<in> t}`] THEN
  REWRITE_TAC[SET_RULE
   `disjnt (\<Union> s) (\<Union> t) \<longleftrightarrow>
    \<forall>u. u \<in> s \<Longrightarrow> \<forall>v. v \<in> t \<Longrightarrow> disjnt u v`] THEN
  SIMP_TAC[OPEN_IN_UNIONS; FORALL_IN_GSPEC; OPEN_IN_MBALL] THEN
  REWRITE_TAC[IN_UNIONS; EXISTS_IN_GSPEC] THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN REPEAT DISCH_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SET_RULE
   `disjnt s t \<longleftrightarrow> \<forall>x. (x \<notin> s \<and> x \<in> t)`]) THEN
  REPEAT(CONJ_TAC THENL
   [ASM_MESON_TAC[REAL_HALF; CENTRE_IN_MBALL; \<subseteq>]; ALL_TAC]) THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  X_GEN_TAC `y::A` THEN DISCH_TAC THEN
  SUBGOAL_THEN `(x::A) \<in> M \<and> (y::A) \<in> M` STRIP_ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  REMOVE_THEN "e" (MP_TAC \<circ> SPEC `x::A`) THEN
  ANTS_TAC THENL [ASM SET_TAC[]; DISCH_THEN(MP_TAC \<circ> CONJUNCT2)] THEN
  REMOVE_THEN "d" (MP_TAC \<circ> SPEC `y::A`) THEN
  ANTS_TAC THENL [ASM SET_TAC[]; DISCH_THEN(MP_TAC \<circ> CONJUNCT2)] THEN
  REWRITE_TAC[IMP_IMP] THEN DISCH_THEN(CONJUNCTS_THEN2
   (MP_TAC \<circ> SPEC `x::A`) (MP_TAC \<circ> SPEC `y::A`)) THEN
  ASM_SIMP_TAC[REAL_NOT_LT; disjnt; EXTENSION; NOT_IN_EMPTY; IN_INTER] THEN
  MAP_EVERY UNDISCH_TAC [`(x::A) \<in> M`; `(y::A) \<in> M`] THEN
  REWRITE_TAC[mball; IN_ELIM_THM] THEN CONV_TAC METRIC_ARITH);;

lemma metrizable_imp_normal_space:
   "metrizable_space X \<Longrightarrow> normal_space X"
oops
  REWRITE_TAC[FORALL_METRIZABLE_SPACE; NORMAL_SPACE_MTOPOLOGY]);;

lemma normal_space_discrete_topology:
   "\<And>u::A=>bool. normal_space(discrete_topology u)"
oops
  SIMP_TAC[METRIZABLE_SPACE_DISCRETE_TOPOLOGY;
           METRIZABLE_IMP_NORMAL_SPACE]);;

lemma normal_space_fsigmas:
   "        normal_space X \<longleftrightarrow>
        \<forall>s t. fsigma_in X s \<and> fsigma_in X t \<and> separatedin X s t
              \<Longrightarrow> \<exists>u v. openin X u \<and>
                        openin X v \<and>
                        s \<subseteq> u \<and>
                        t \<subseteq> v \<and>
                        disjnt u v"
oops
  GEN_TAC THEN REWRITE_TAC[normal_space] THEN EQ_TAC THENL
   [ALL_TAC; METIS_TAC[CLOSED_IMP_FSIGMA_IN; SEPARATED_IN_CLOSED_SETS]] THEN
  DISCH_TAC THEN MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN
  REWRITE_TAC[separatedin] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `t::A=>bool`] FSIGMA_IN_ASCENDING) THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`] FSIGMA_IN_ASCENDING) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `c::num=>A->bool` THEN STRIP_TAC THEN
  X_GEN_TAC `d::num=>A->bool` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP MONO_FORALL \<circ> GEN `n::num` \<circ> SPECL
   [`(d::num=>A->bool) n`; `X closure_of s::A=>bool`]) THEN
  ANTS_TAC THENL
   [ASM_REWRITE_TAC[CLOSED_IN_CLOSURE_OF] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP MONO_FORALL \<circ> GEN `n::num` \<circ> SPECL
   [`(c::num=>A->bool) n`; `X closure_of t::A=>bool`]) THEN
  ANTS_TAC THENL
   [ASM_REWRITE_TAC[CLOSED_IN_CLOSURE_OF] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM; FORALL_AND_THM] THEN
  MAP_EVERY X_GEN_TAC [`u::num=>A->bool`; `u':num=>A->bool`] THEN
  STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [`v::num=>A->bool`; `v':num=>A->bool`] THEN
  STRIP_TAC THEN MAP_EVERY EXISTS_TAC
   [`\<Union> {(u::num=>A->bool) n - \<Union> {X closure_of (v m) | m \<le> n} |
             n \<in> UNIV}`;
    `\<Union> {(v::num=>A->bool) n - \<Union> {X closure_of (u m) | m \<le> n} |
             n \<in> UNIV}`] THEN
  GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC OPEN_IN_UNIONS THEN
    REWRITE_TAC[FORALL_IN_GSPEC] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC OPEN_IN_DIFF THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC CLOSED_IN_UNIONS THEN
    ASM_REWRITE_TAC[FORALL_IN_GSPEC; CLOSED_IN_CLOSURE_OF] THEN
    ONCE_REWRITE_TAC[SIMPLE_IMAGE_GEN] THEN MATCH_MP_TAC FINITE_IMAGE THEN
    REWRITE_TAC[FINITE_NUMSEG_LE];
    ALL_TAC] THEN
  GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
   [REWRITE_TAC[\<subseteq>; UNIONS_GSPEC; IN_ELIM_THM; IN_UNIV] THEN
    CONJ_TAC THEN X_GEN_TAC `x::A` THEN
    DISCH_THEN(fun th -> ASSUME_TAC th THEN MP_TAC th) THEN FIRST_X_ASSUM
     (fun th -> GEN_REWRITE_TAC (LAND_CONV \<circ> RAND_CONV) [SYM th]) THEN
    REWRITE_TAC[UNIONS_GSPEC; IN_ELIM_THM; IN_DIFF; IN_UNIV] THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `n::num` THEN DISCH_TAC THEN
    (CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
    DISCH_THEN(X_CHOOSE_THEN `m::num` (MP_TAC \<circ> CONJUNCT2)) THENL
     [MP_TAC(ISPECL
       [`X::A topology`; `(v':num=>A->bool) m`; `(v::num=>A->bool) m`]
       OPEN_IN_INTER_CLOSURE_OF_EQ_EMPTY) THEN
      MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`] CLOSURE_OF_SUBSET);
      MP_TAC(ISPECL
       [`X::A topology`; `(u':num=>A->bool) m`; `(u::num=>A->bool) m`]
       OPEN_IN_INTER_CLOSURE_OF_EQ_EMPTY) THEN
      MP_TAC(ISPECL [`X::A topology`; `t::A=>bool`] CLOSURE_OF_SUBSET)] THEN
    ASM_SIMP_TAC[FSIGMA_IN_SUBSET] THEN ASM SET_TAC[];
    REWRITE_TAC[disjnt; INTER_UNIONS; EMPTY_UNIONS; FORALL_IN_GSPEC] THEN
    REWRITE_TAC[IN_UNIV] THEN MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN
    DISJ_CASES_TAC(SPECL [`m::num`; `n::num`] LE_CASES) THENL
     [ALL_TAC; ONCE_REWRITE_TAC[INTER_COMM]] THEN
    MATCH_MP_TAC(SET_RULE
       `u \<subseteq> u' \<Longrightarrow> (u - v') \<inter> (v - u') = {}`) THEN
    MATCH_MP_TAC(SET_RULE
     `(\<exists>n. P n \<and> s \<subseteq> t n) \<Longrightarrow> s \<subseteq> \<Union> {t n | P n}`)
    THENL [EXISTS_TAC `m::num`; EXISTS_TAC `n::num`] THEN
    ASM_SIMP_TAC[CLOSURE_OF_SUBSET; OPEN_IN_SUBSET]]);;

lemma normal_space_fsigma_subtopology:
   "
        normal_space X \<and> fsigma_in X s
        \<Longrightarrow> normal_space(subtopology X s)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[NORMAL_SPACE_FSIGMAS] THEN STRIP_TAC THEN
  ASM_SIMP_TAC[FSIGMA_IN_FSIGMA_SUBTOPOLOGY; SEPARATED_IN_SUBTOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`t::A=>bool`; `u::A=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`t::A=>bool`; `u::A=>bool`]) THEN
  ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; RIGHT_EXISTS_AND_THM] THEN
  REWRITE_TAC[EXISTS_IN_GSPEC] THEN REWRITE_TAC[RIGHT_AND_EXISTS_THM] THEN
  REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[SUBSET_INTER] THEN ASM SET_TAC[]);;

lemma normal_space_closed_subtopology:
   "
        normal_space X \<and> closedin X s
        \<Longrightarrow> normal_space (subtopology X s)"
oops
  MESON_TAC[NORMAL_SPACE_FSIGMA_SUBTOPOLOGY; CLOSED_IMP_FSIGMA_IN]);;

lemma normal_space_continuous_closed_map_image:
   "\<And>X X' f::A=>B.
        continuous_map X X' f \<and> closed_map X X' f \<and>
        f ` (topspace X) = topspace X' \<and>
        normal_space X
        \<Longrightarrow> normal_space X'"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[normal_space; closed_map] THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [`s::B=>bool`; `t::B=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL
   [`{x \<in> topspace X. f x \<in> s}`;
    `{x \<in> topspace X. f x \<in> t}`]) THEN
  ASM_REWRITE_TAC[CONJ_ASSOC] THEN ANTS_TAC THENL
   [CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN CONJ_TAC THEN
    MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN ASM_MESON_TAC[];
    REWRITE_TAC[GSYM CONJ_ASSOC; RIGHT_EXISTS_AND_THM] THEN
    REWRITE_TAC[EXISTS_OPEN_IN] THEN REWRITE_TAC[RIGHT_AND_EXISTS_THM] THEN
    REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
    MAP_EVERY EXISTS_TAC [`f ` u`; `f ` v`] THEN
    ASM_SIMP_TAC[] THEN REPEAT STRIP_TAC THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
    ASM SET_TAC[]]);;

lemma hereditarily_normal_space_continuous_closed_map_image:
   "\<And>X X' f::A=>B.
        continuous_map X X' f \<and>
        closed_map X X' f \<and>
        f ` (topspace X) = topspace X' \<and>
        hereditarily normal_space X
        \<Longrightarrow> hereditarily normal_space X'"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[hereditarily] THEN
  X_GEN_TAC `t::B=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ>
   SPEC `{x \<in> topspace X. f x \<in> t}` \<circ>
   GEN_REWRITE_RULE id [hereditarily]) THEN
  REWRITE_TAC[SUBSET_RESTRICT] THEN MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ]
   (REWRITE_RULE[CONJ_ASSOC] NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE)) THEN
  EXISTS_TAC `f::A=>B` THEN
  ASM_SIMP_TAC[CLOSED_MAP_RESTRICTION] THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY;
               GSYM CONJ_ASSOC; CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_MAP_IMP_SUBSET_TOPSPACE) THEN
  ASM SET_TAC[]);;

lemma homeomorphic_hereditarily_normal_space:
   "\<And>(X::A topology) (X':B topology).
      X homeomorphic_space X'
      \<Longrightarrow> (hereditarily normal_space X \<longleftrightarrow> hereditarily normal_space X')"
oops
  REWRITE_TAC[homeomorphic_space; HOMEOMORPHIC_MAPS_MAP] THEN
  MESON_TAC[HEREDITARILY_NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE;
            HOMEOMORPHIC_IMP_SURJECTIVE_MAP;
            HOMEOMORPHIC_IMP_CONTINUOUS_MAP;
            HOMEOMORPHIC_IMP_CLOSED_MAP]);;

lemma hereditarily_normal_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> hereditarily normal_space X
        \<Longrightarrow> hereditarily normal_space X'"
oops
  MATCH_MP_TAC HEREDITARY_IMP_RETRACTIVE_PROPERTY THEN
  REWRITE_TAC[HEREDITARILY_SUBTOPOLOGY;
              HOMEOMORPHIC_HEREDITARILY_NORMAL_SPACE]);;

lemma urysohn_lemma:
   "\<And>(X::A topology) s t a b.
        a \<le> b \<and> normal_space X \<and>
        closedin X s \<and> closedin X t \<and> disjnt s t
        \<Longrightarrow> \<exists>f. continuous_map
                    (X,subtopology euclideanreal (real_interval[a,b])) f \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> f x = a) \<and>
                (\<forall>x. x \<in> t \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   `\<exists>f. continuous_map
         (X,subtopology euclideanreal (real_interval[0,1])) (f::A=>real) \<and>
         (\<forall>x. x \<in> s \<Longrightarrow> f x = 0) \<and>
         (\<forall>x. x \<in> t \<Longrightarrow> f x = 1)`
  MP_TAC THENL
   [UNDISCH_THEN `a::real \<le> b` (K ALL_TAC);
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
    EXISTS_TAC `\<lambda>x. a + (b - a) * (f::A=>real) x` THEN
    ASM_SIMP_TAC[] THEN CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; CONTINUOUS_MAP_REAL_LMUL;
                 CONTINUOUS_MAP_REAL_CONST] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [\<subseteq>]) THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL; REAL_LE_ADDR] THEN
    REWRITE_TAC[REAL_ARITH
      `a + (b - a) * y \<le> b \<longleftrightarrow> 0 \<le> (b - a) * (1 - y)`] THEN
    ASM_SIMP_TAC[REAL_LE_MUL; REAL_SUB_LE]] THEN
  FIRST_ASSUM(MP_TAC \<circ> SPECL [`s::A=>bool`; `topspace X - t::A=>bool`] \<circ>
    REWRITE_RULE[NORMAL_SPACE_ALT]) THEN
  ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE] THEN
  ASM_SIMP_TAC[SET_RULE `s \<subseteq> u - t \<longleftrightarrow> s \<subseteq> u \<and> disjnt s t`;
               CLOSED_IN_SUBSET] THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   `\<exists>g::real=>A->bool.
        g 0 = u \<and> g 1 = topspace X - t \<and>
        \<forall>x y. x \<in> {k / 2 ^ n | k \<le> 2 ^ n} \<and>
              y \<in> {k / 2 ^ n | k \<le> 2 ^ n} \<and>
              x < y
              \<Longrightarrow> openin X (g x) \<and> openin X (g y) \<and>
                  X closure_of (g x) \<subseteq> (g y)`
  STRIP_ASSUME_TAC THENL
   [MATCH_MP_TAC RECURSION_ON_DYADIC_FRACTIONS THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE] THEN
    ASM_SIMP_TAC[SET_RULE `s \<subseteq> u - t \<longleftrightarrow> s \<subseteq> u \<and> disjnt s t`;
                 CLOSED_IN_SUBSET] THEN
    CONJ_TAC THENL
     [ASM_MESON_TAC[CLOSURE_OF_SUBSET; OPEN_IN_SUBSET; SUBSET_TRANS];
      ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`w::A=>bool`; `z::A=>bool`] THEN STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> SPECL [`X closure_of w::A=>bool`; `z::A=>bool`] \<circ>
      REWRITE_RULE[NORMAL_SPACE_ALT]) THEN
    ASM_SIMP_TAC[CLOSED_IN_CLOSURE_OF] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  ABBREV_TAC `dint = {k / 2 ^ n | k \<le> 2 ^ n}` THEN
  SUBGOAL_THEN `dint \<subseteq> real_interval[0,1]` ASSUME_TAC THENL
   [EXPAND_TAC "dint" THEN SIMP_TAC[\<subseteq>; IN_ELIM_THM; IN_REAL_INTERVAL] THEN
    REPEAT STRIP_TAC THEN
    ASM_SIMP_TAC[REAL_LE_LDIV_EQ; REAL_LE_RDIV_EQ; REAL_LT_POW2] THEN
    REWRITE_TAC[REAL_MUL_LZERO; REAL_POS; REAL_MUL_LID] THEN
    ASM_REWRITE_TAC[REAL_OF_NUM_LE; REAL_OF_NUM_POW];
    ALL_TAC] THEN
  ABBREV_TAC
   `f = \<lambda>x::A. inf(1 insert {r. r \<in> dint \<and> x \<in> g r})` THEN
  EXISTS_TAC `f::A=>real` THEN REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
  SUBGOAL_THEN
   `\<forall>x. x \<in> topspace X \<Longrightarrow> 0 \<le> (f::A=>real) x \<and> f x \<le> 1`
  ASSUME_TAC THENL
   [GEN_TAC THEN DISCH_TAC THEN EXPAND_TAC "f" THEN REWRITE_TAC[] THEN
    MATCH_MP_TAC REAL_INF_BOUNDS THEN
    REWRITE_TAC[FORALL_IN_INSERT; NOT_INSERT_EMPTY] THEN
    CONV_TAC REAL_RAT_REDUCE_CONV THEN
    UNDISCH_TAC `dint \<subseteq> real_interval[0,1]` THEN
    SIMP_TAC[IN_REAL_INTERVAL; IN_ELIM_THM; \<subseteq>];
    ASM_REWRITE_TAC[]] THEN
  SUBGOAL_THEN `0 \<in> dint \<and> 1 \<in> dint` STRIP_ASSUME_TAC THENL
   [EXPAND_TAC "dint" THEN REWRITE_TAC[IN_ELIM_THM] THEN
    CONJ_TAC THENL [EXISTS_TAC `0`; EXISTS_TAC `1`] THEN
    EXISTS_TAC `0` THEN CONV_TAC NUM_REDUCE_CONV THEN
    CONV_TAC REAL_RAT_REDUCE_CONV;
    ALL_TAC] THEN
  SUBGOAL_THEN `\<forall>r. r \<in> dint \<Longrightarrow> openin X ((g::real=>A->bool) r)`
  ASSUME_TAC THENL
   [X_GEN_TAC `r::real` THEN DISCH_TAC THEN
    SUBGOAL_THEN `0 < r \<or> r < 1` MP_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    SUBGOAL_THEN `r \<in> real_interval[0,1]` MP_TAC THENL
     [ASM SET_TAC[]; REWRITE_TAC[IN_REAL_INTERVAL] THEN REAL_ARITH_TAC];
    ALL_TAC] THEN
  REPEAT CONJ_TAC THENL
   [ALL_TAC;
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    SUBGOAL_THEN `(x::A) \<in> topspace X` ASSUME_TAC THENL
     [ASM_MESON_TAC[\<subseteq>; CLOSED_IN_SUBSET];
      ASM_SIMP_TAC[GSYM REAL_LE_ANTISYM]] THEN
    EXPAND_TAC "f" THEN MATCH_MP_TAC INF_LE_ELEMENT THEN CONJ_TAC THENL
     [EXISTS_TAC `0` THEN REWRITE_TAC[FORALL_IN_INSERT; REAL_POS] THEN
      REWRITE_TAC[FORALL_IN_GSPEC] THEN
      UNDISCH_TAC `dint \<subseteq> real_interval[0,1]` THEN
      SIMP_TAC[IN_REAL_INTERVAL; IN_ELIM_THM; \<subseteq>];
      REWRITE_TAC[IN_INSERT; IN_ELIM_THM] THEN ASM SET_TAC[]];
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    SUBGOAL_THEN `(x::A) \<in> topspace X` ASSUME_TAC THENL
     [ASM_MESON_TAC[\<subseteq>; CLOSED_IN_SUBSET];
      ASM_SIMP_TAC[GSYM REAL_LE_ANTISYM]] THEN
    EXPAND_TAC "f" THEN MATCH_MP_TAC REAL_LE_INF THEN
    REWRITE_TAC[NOT_INSERT_EMPTY; FORALL_IN_INSERT; REAL_LE_REFL] THEN
    X_GEN_TAC `r::real` THEN REWRITE_TAC[IN_ELIM_THM] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
    REWRITE_TAC[REAL_NOT_LE] THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`r::real`; `1`]) THEN
    ASM_REWRITE_TAC[] THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(SET_RULE
     `x \<in> t \<and> g \<subseteq> g' \<Longrightarrow> g' \<subseteq> u - t \<Longrightarrow> (x \<notin> g)`) THEN
    ASM_MESON_TAC[OPEN_IN_SUBSET; CLOSURE_OF_SUBSET]] THEN
  MP_TAC(GEN `z::A`
   (SPEC `1 insert {r. r \<in> dint \<and> z \<in> (g::real=>A->bool) r}` INF)) THEN
  FIRST_ASSUM(fun th ->
   REWRITE_TAC[REWRITE_RULE[] (GEN_REWRITE_RULE id [FUN_EQ_THM] th)]) THEN
  REWRITE_TAC[NOT_INSERT_EMPTY; FORALL_IN_INSERT] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP MONO_FORALL) THEN ANTS_TAC THENL
   [GEN_TAC THEN EXISTS_TAC `0::real` THEN
    REWRITE_TAC[IN_ELIM_THM; REAL_POS] THEN
    UNDISCH_TAC `dint \<subseteq> real_interval[0,1]` THEN
    SIMP_TAC[IN_REAL_INTERVAL; IN_ELIM_THM; \<subseteq>];
    REWRITE_TAC[FORALL_AND_THM; IN_ELIM_THM]] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC (LABEL_TAC "*")) THEN
  SUBGOAL_THEN
   `\<forall>z x. x \<in> dint \<and> (z \<notin> (g::real=>A->bool) x) \<Longrightarrow> x \<le> (f::A=>real) z`
  ASSUME_TAC THENL
   [MAP_EVERY X_GEN_TAC [`z::A`; `r::real`] THEN STRIP_TAC THEN
    REMOVE_THEN "*" MATCH_MP_TAC THEN CONJ_TAC THENL
     [UNDISCH_TAC `dint \<subseteq> real_interval[0,1]` THEN
      ASM_SIMP_TAC[IN_REAL_INTERVAL; IN_ELIM_THM; \<subseteq>];
      X_GEN_TAC `s::real` THEN STRIP_TAC] THEN
    ONCE_REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`s::real`; `r::real`]) THEN
    ASM_REWRITE_TAC[] THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MP_TAC(ISPECL [`X::A topology`; `(g::real=>A->bool) s`]
      CLOSURE_OF_SUBSET) THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET] THEN ASM SET_TAC[];
    REMOVE_THEN "*" (K ALL_TAC)] THEN
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_TO_METRIC; IN_MBALL; REAL_EUCLIDEAN_METRIC] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  REWRITE_TAC[IN_UNIV] THEN
  SUBGOAL_THEN
   `(\<forall>y d. 0 < y \<and> y \<le> 1 \<and> 0 < d
           \<Longrightarrow> \<exists>r. r \<in> dint \<and> r < y \<and> abs(r - y) < d) \<and>
    (\<forall>y d. 0 \<le> y \<and> y < 1 \<and> 0 < d
           \<Longrightarrow> \<exists>r. r \<in> dint \<and> y < r \<and> abs(r - y) < d)`
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THENL
     [MP_TAC(ISPECL [`2`; `y::real`; `d::real`]
        PADIC_RATIONAL_APPROXIMATION_STRADDLE_POS) THEN ANTS_TAC
      THENL [ASM_REAL_ARITH_TAC; REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
      MAP_EVERY X_GEN_TAC [`n::num`; `q::num`; `r::num`] THEN STRIP_TAC THEN
      EXISTS_TAC `q / 2 ^ n` THEN CONJ_TAC THENL
       [EXPAND_TAC "dint"; ASM_REAL_ARITH_TAC] THEN
      REWRITE_TAC[IN_ELIM_THM] THEN
      MAP_EVERY EXISTS_TAC [`q::num`; `n::num`] THEN ASM_REWRITE_TAC[] THEN
      SUBGOAL_THEN `q / 2 ^ n \<le> 1` MP_TAC THENL
       [ASM_REAL_ARITH_TAC; SIMP_TAC[REAL_LE_LDIV_EQ; REAL_LT_POW2]] THEN
      REWRITE_TAC[REAL_MUL_LID; REAL_OF_NUM_POW; REAL_OF_NUM_LE];
      MP_TAC(ISPECL [`2`; `y::real`; `d::real`]
        PADIC_RATIONAL_APPROXIMATION_STRADDLE_POS_LE) THEN ANTS_TAC
      THENL [ASM_REAL_ARITH_TAC; REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
      MAP_EVERY X_GEN_TAC [`n::num`; `q::num`; `r::num`] THEN STRIP_TAC THEN
      EXISTS_TAC `min 1 (r / 2 ^ n)` THEN CONJ_TAC THENL
       [REWRITE_TAC[real_min]; ASM_REAL_ARITH_TAC] THEN
      COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
      EXPAND_TAC "dint" THEN REWRITE_TAC[IN_ELIM_THM] THEN
      MAP_EVERY EXISTS_TAC [`r::num`; `n::num`] THEN ASM_REWRITE_TAC[] THEN
      SUBGOAL_THEN `r / 2 ^ n \<le> 1` MP_TAC THENL
       [ASM_REAL_ARITH_TAC; SIMP_TAC[REAL_LE_LDIV_EQ; REAL_LT_POW2]] THEN
      REWRITE_TAC[REAL_MUL_LID; REAL_OF_NUM_POW; REAL_OF_NUM_LE]];
    ALL_TAC] THEN
  ASM_CASES_TAC `(f::A=>real) x = 0` THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`(f::A=>real) x`; `e / 2`] \<circ> CONJUNCT2) THEN
    ASM_SIMP_TAC[REAL_LT_01; REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_THEN `r::real` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(g::real=>A->bool) r` THEN ASM_SIMP_TAC[] THEN CONJ_TAC THENL
     [MATCH_MP_TAC(TAUT `(\<not> p \<Longrightarrow> False) \<Longrightarrow> p`) THEN DISCH_TAC THEN
      SUBGOAL_THEN `r \<le> (f::A=>real) x` MP_TAC THENL
       [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]; ASM_REAL_ARITH_TAC];
      X_GEN_TAC `y::A` THEN DISCH_TAC THEN
      SUBGOAL_THEN `(f::A=>real) y \<le> r` MP_TAC THENL
       [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
      SUBGOAL_THEN `0 \<le> (f::A=>real) y \<and> f y \<le> 1` MP_TAC THENL
       [FIRST_X_ASSUM MATCH_MP_TAC; ASM_REAL_ARITH_TAC] THEN
      ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]];
    ALL_TAC] THEN
  ASM_CASES_TAC `(f::A=>real) x = 1` THENL
   [FIRST_ASSUM(MP_TAC \<circ> SPECL [`(f::A=>real) x`; `e / 2`] \<circ> CONJUNCT1) THEN
    ANTS_TAC THENL [ASM SIMP_TAC[] THEN ASM_REAL_ARITH_TAC; ALL_TAC] THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `r::real` THEN
    STRIP_TAC THEN
    EXISTS_TAC `topspace X - X closure_of (g::real=>A->bool) r` THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE; CLOSED_IN_CLOSURE_OF] THEN
    ASM_REWRITE_TAC[IN_DIFF] THEN CONJ_TAC THENL
     [DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`r::real`; `1 - r`] \<circ> CONJUNCT2) THEN
      ANTS_TAC THENL
       [ASM_REWRITE_TAC[REAL_SUB_LT] THEN
        ASM_MESON_TAC[\<subseteq>; IN_REAL_INTERVAL];
        DISCH_THEN(X_CHOOSE_THEN `r':real` STRIP_ASSUME_TAC)] THEN
      SUBGOAL_THEN `(f::A=>real) x \<le> r'` MP_TAC THENL
       [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM SET_TAC[];
        ASM_REAL_ARITH_TAC];
      X_GEN_TAC `y::A` THEN STRIP_TAC THEN
      SUBGOAL_THEN `r \<le> (f::A=>real) y` MP_TAC THENL
       [FIRST_X_ASSUM MATCH_MP_TAC THEN
        MP_TAC(ISPECL [`X::A topology`; `(g::real=>A->bool) r`]
                CLOSURE_OF_SUBSET) THEN
        ASM_SIMP_TAC[OPEN_IN_SUBSET] THEN ASM SET_TAC[];
        SUBGOAL_THEN `(f::A=>real) y \<le> 1` MP_TAC THENL
         [ASM_MESON_TAC[\<subseteq>; IN_REAL_INTERVAL]; ASM_REAL_ARITH_TAC]]];
    ALL_TAC] THEN
  FIRST_ASSUM(CONJUNCTS_THEN(MP_TAC \<circ> SPECL [`(f::A=>real) x`; `e / 2`])) THEN
  SUBGOAL_THEN `0 \<le> (f::A=>real) x \<and> f x \<le> 1` STRIP_ASSUME_TAC THENL
   [ASM_MESON_TAC[\<subseteq>; IN_REAL_INTERVAL]; ALL_TAC] THEN
  ANTS_TAC THENL [ASM_REAL_ARITH_TAC; REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `r':real` THEN STRIP_TAC THEN
  ANTS_TAC THENL [ASM_REAL_ARITH_TAC; REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `r::real` THEN STRIP_TAC THEN
  EXISTS_TAC `(g::real=>A->bool) r' - X closure_of g r` THEN
  ASM_SIMP_TAC[IN_DIFF; OPEN_IN_DIFF; CLOSED_IN_CLOSURE_OF] THEN
  REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC(TAUT `(\<not> p \<Longrightarrow> False) \<Longrightarrow> p`) THEN DISCH_TAC THEN
    SUBGOAL_THEN `r' \<le> (f::A=>real) x` MP_TAC THENL
     [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]; ASM_REAL_ARITH_TAC];
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ>
      SPECL [`r::real`; `f(x::A) - r::real`] \<circ> CONJUNCT2) THEN
    ANTS_TAC THENL
     [ASM_REWRITE_TAC[REAL_SUB_LT] THEN CONJ_TAC THENL
       [ASM_MESON_TAC[\<subseteq>; IN_REAL_INTERVAL]; ASM_REAL_ARITH_TAC];
      DISCH_THEN(X_CHOOSE_THEN `r'':real` STRIP_ASSUME_TAC)] THEN
    SUBGOAL_THEN `(f::A=>real) x \<le> r''` MP_TAC THENL
     [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM SET_TAC[];
      ASM_REAL_ARITH_TAC];
    X_GEN_TAC `y::A` THEN STRIP_TAC THEN
    SUBGOAL_THEN `(y::A) \<in> topspace X` ASSUME_TAC THENL
     [ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]; ALL_TAC] THEN
    SUBGOAL_THEN `0 \<le> (f::A=>real) y \<and> f y \<le> 1` STRIP_ASSUME_TAC THENL
     [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[]; ALL_TAC] THEN
    SUBGOAL_THEN `r \<le> (f::A=>real) y \<and> f y \<le> r'` MP_TAC THENL
     [ALL_TAC; ASM_REAL_ARITH_TAC] THEN
    CONJ_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
    ASM_REWRITE_TAC[] THEN
    MP_TAC(ISPECL [`X::A topology`; `(g::real=>A->bool) r`]
              CLOSURE_OF_SUBSET) THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET] THEN ASM SET_TAC[]]);;

lemma urysohn_lemma_alt:
   "\<And>(X::A topology) s t a b.
        normal_space X \<and> closedin X s \<and> closedin X t \<and> disjnt s t
        \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> f x = a) \<and>
                (\<forall>x. x \<in> t \<Longrightarrow> f x = b)"
oops
  GEN_TAC THEN ONCE_REWRITE_TAC[MESON[]
   `(\<forall>s t a b. P s t a b) \<longleftrightarrow> (\<forall>a b s t. P s t a b)`] THEN
  MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
   [REPEAT GEN_TAC THEN
    GEN_REWRITE_TAC LAND_CONV [SWAP_FORALL_THM] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN MESON_TAC[DISJOINT_SYM];
    REWRITE_TAC[RIGHT_IMP_FORALL_THM; IMP_IMP] THEN REPEAT GEN_TAC THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP URYSOHN_LEMMA) THEN
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN MESON_TAC[]]);;

lemma normal_space_eq_urysohn_gen_alt:
   "     (a \<noteq> b)
     \<Longrightarrow> (normal_space X \<longleftrightarrow>
          \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
                \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                        (\<forall>x. x \<in> s \<Longrightarrow> f x = a) \<and>
                        (\<forall>x. x \<in> t \<Longrightarrow> f x = b))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC[URYSOHN_LEMMA_ALT] THEN
  REWRITE_TAC[normal_space] THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `s::A=>bool` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `t::A=>bool` THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [`{x::A | x \<in> topspace X \<and>
            f x \<in> mball real_euclidean_metric (a,abs(a - b) / 2)}`;
    `{x::A | x \<in> topspace X \<and>
            f x \<in> mball real_euclidean_metric (b,abs(a - b) / 2)}`] THEN
  ONCE_REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
    EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[OPEN_IN_MBALL; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC];
    ONCE_REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
     [ASM_SIMP_TAC[\<subseteq>; IN_ELIM_THM; CENTRE_IN_MBALL_EQ] THEN
      ASM_REWRITE_TAC[REAL_ARITH `0 < abs(a - b) / 2 \<longleftrightarrow> (a \<noteq> b)`] THEN
      REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
      ASM_SIMP_TAC[GSYM \<subseteq>; CLOSED_IN_SUBSET];
      SIMP_TAC[EXTENSION; disjnt; IN_INTER; NOT_IN_EMPTY; IN_ELIM_THM;
               mball; REAL_EUCLIDEAN_METRIC] THEN
      REAL_ARITH_TAC]]);;

lemma normal_space_eq_urysohn_gen:
   "     a < b
     \<Longrightarrow> (normal_space X \<longleftrightarrow>
          \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
                \<Longrightarrow> \<exists>f. continuous_map
                         (X,
                          subtopology euclideanreal (real_interval[a,b])) f \<and>
                        (\<forall>x. x \<in> s \<Longrightarrow> f x = a) \<and>
                        (\<forall>x. x \<in> t \<Longrightarrow> f x = b))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  ASM_SIMP_TAC[URYSOHN_LEMMA; REAL_LT_IMP_LE] THEN
  ASM_SIMP_TAC[NORMAL_SPACE_EQ_URYSOHN_GEN_ALT; REAL_LT_IMP_NE] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REPEAT(MATCH_MP_TAC MONO_FORALL THEN GEN_TAC) THEN MESON_TAC[]);;

lemma normal_space_eq_urysohn_alt:
   "     normal_space X \<longleftrightarrow>
     \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
           \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                   (\<forall>x. x \<in> s \<Longrightarrow> f x = 0) \<and>
                   (\<forall>x. x \<in> t \<Longrightarrow> f x = 1)"
oops
  GEN_TAC THEN MATCH_MP_TAC NORMAL_SPACE_EQ_URYSOHN_GEN_ALT THEN
  CONV_TAC REAL_RAT_REDUCE_CONV);;

lemma normal_space_eq_urysohn:
   "     normal_space X \<longleftrightarrow>
     \<forall>s t. closedin X s \<and> closedin X t \<and> disjnt s t
           \<Longrightarrow> \<exists>f. continuous_map
                    (X,subtopology euclideanreal (real_interval[0,1])) f \<and>
                   (\<forall>x. x \<in> s \<Longrightarrow> f x = 0) \<and>
                   (\<forall>x. x \<in> t \<Longrightarrow> f x = 1)"
oops
  GEN_TAC THEN MATCH_MP_TAC NORMAL_SPACE_EQ_URYSOHN_GEN THEN
  REWRITE_TAC[REAL_LT_01]);;

lemma tietze_extension_closed_real_interval:
   "\<And>X f::A=>real s a b.
        normal_space X \<and> closedin X s \<and> a \<le> b \<and>
        continuous_map (subtopology X s,euclideanreal) f \<and>
        (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> real_interval[a,b])
        \<Longrightarrow> \<exists>g. continuous_map X euclideanreal g \<and>
                (\<forall>x. x \<in> topspace X \<Longrightarrow> g x \<in> real_interval[a,b]) \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
  REWRITE_TAC[IN_REAL_INTERVAL] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `\<exists>c. 0 < c \<and> \<forall>x. x \<in> s \<Longrightarrow> abs((f::A=>real) x) \<le> c`
  STRIP_ASSUME_TAC THENL
   [EXISTS_TAC `max (abs a) (abs b) + 1` THEN
    ASM_SIMP_TAC[REAL_ARITH
     `a \<le> x \<and> x \<le> b \<Longrightarrow> abs x \<le> max (abs a) (abs b) + 1`] THEN
    REAL_ARITH_TAC;
    ALL_TAC] THEN
  SUBGOAL_THEN
   `\<exists>g::num=>A->real.
        (\<forall>n. continuous_map X euclideanreal (g n) \<and>
             \<forall>x. x \<in> s \<Longrightarrow> abs(f x - g n x) \<le> c * (2 / 3) ^ n) \<and>
        (\<forall>n x. x \<in> topspace X
               \<Longrightarrow> abs(g(Suc n) x - g n x) \<le> c * (2 / 3) ^ n / 3)`
  MP_TAC THENL
   [MATCH_MP_TAC DEPENDENT_CHOICE THEN CONJ_TAC THENL
     [EXISTS_TAC `(\<lambda>x. 0):A=>real` THEN
      REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
      ASM_REWRITE_TAC[real_pow; REAL_MUL_RID; REAL_SUB_RZERO];
      MAP_EVERY X_GEN_TAC [`n::num`; `h::A=>real`] THEN STRIP_TAC] THEN
    MP_TAC(ISPECL
     [`X::A topology`;
      `{x. x \<in> s \<and> ((f::A=>real) x - h x) \<in>
                      {y. y \<le> --(c / 3 * (2 / 3) ^ n)}}`;
      `{x. x \<in> s \<and> ((f::A=>real) x - h x) \<in>
                      {y. y >= c / 3 * (2 / 3) ^ n}}`;
      `--(c / 3 * (2 / 3) ^ n)`; `c / 3 * (2 / 3) ^ n`]
     URYSOHN_LEMMA) THEN
    REWRITE_TAC[REAL_ARITH `--(c / 3 * x) \<le> c / 3 * x \<longleftrightarrow> 0 \<le> c * x`] THEN
    SUBGOAL_THEN `0 < c * (2 / 3) ^ n` ASSUME_TAC THENL
     [MATCH_MP_TAC REAL_LT_MUL THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC REAL_POW_LT THEN CONV_TAC REAL_RAT_REDUCE_CONV;
      ASM_SIMP_TAC[REAL_LT_IMP_LE]] THEN
    ANTS_TAC THENL
     [REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
       [SUBGOAL_THEN `s::A=>bool = topspace(subtopology X s)` SUBST1_TAC THENL
         [ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; CLOSED_IN_SUBSET;
                       SET_RULE `s = u \<inter> s \<longleftrightarrow> s \<subseteq> u`];
          CONJ_TAC THEN MATCH_MP_TAC CLOSED_IN_TRANS_FULL THEN
          EXISTS_TAC `s::A=>bool` THEN ASM_REWRITE_TAC[] THEN
          MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
          EXISTS_TAC `euclideanreal` THEN
          ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_SUB; GSYM REAL_CLOSED_IN;
                       CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
          REWRITE_TAC[REAL_CLOSED_HALFSPACE_LE; REAL_CLOSED_HALFSPACE_GE]];
        SIMP_TAC[disjnt; EXTENSION; IN_INTER; NOT_IN_EMPTY; IN_ELIM_THM] THEN
        ASM_REAL_ARITH_TAC];
      REWRITE_TAC[IN_ELIM_THM; LEFT_IMP_EXISTS_THM] THEN
      REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
      REWRITE_TAC[IN_REAL_INTERVAL; GSYM REAL_ABS_BOUNDS; IN_ELIM_THM] THEN
      X_GEN_TAC `g::A=>real` THEN STRIP_TAC THEN
      EXISTS_TAC `\<lambda>x. h x + (g::A=>real) x` THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; REAL_ADD_SUB] THEN
      ASM_REWRITE_TAC[REAL_ARITH `x * y / 3 = x / 3 * y`] THEN
      X_GEN_TAC `x::A` THEN DISCH_TAC THEN REWRITE_TAC[real_pow] THEN
      REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::A`)) THEN
      FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN
      ASM_SIMP_TAC[\<subseteq>] THEN ASM_REAL_ARITH_TAC];
    REWRITE_TAC[LEFT_IMP_EXISTS_THM; FORALL_AND_THM]] THEN
  X_GEN_TAC `g::num=>A->real` THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [`X::A topology`; `real_euclidean_metric`; `g::num=>A->real`]
   CONTINUOUS_MAP_UNIFORMLY_CAUCHY_LIMIT) THEN
  ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY; MTOPOLOGY_REAL_EUCLIDEAN_METRIC;
                  EVENTUALLY_TRUE; MCOMPLETE_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN ANTS_TAC THENL
   [X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    MP_TAC(ISPECL [`2 / 3`; `e / c::real`] ARCH_EVENTUALLY_POW_INV) THEN
    CONV_TAC REAL_RAT_REDUCE_CONV THEN ASM_SIMP_TAC[REAL_LT_DIV] THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN MATCH_MP_TAC MONO_EXISTS THEN
    X_GEN_TAC `N::num` THEN DISCH_TAC THEN MATCH_MP_TAC WLOG_LT THEN
    ASM_REWRITE_TAC[REAL_SUB_REFL; REAL_ABS_NUM] THEN
    CONJ_TAC THENL [ASM_MESON_TAC[REAL_ABS_SUB]; ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN STRIP_TAC THEN
    X_GEN_TAC `x::A` THEN STRIP_TAC THEN
    TRANS_TAC REAL_LET_TRANS
     `abs(sum(m..n - 1) (\<lambda>n. g (Suc n) (x::A) - g n x))` THEN
    CONJ_TAC THENL
     [REWRITE_TAC[SUM_DIFFS_ALT; ADD1] THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (ARITH_RULE
       `m < n \<Longrightarrow> m \<le> n - 1 \<and> n - 1 + 1 = n`)) THEN
      SIMP_TAC[REAL_LE_REFL];
      TRANS_TAC REAL_LET_TRANS
       `sum (m..n-1) (\<lambda>j. c * (2 / 3) ^ j / 3)` THEN
      ASM_SIMP_TAC[SUM_ABS_LE; FINITE_NUMSEG] THEN
      REWRITE_TAC[real_div; SUM_LMUL; SUM_RMUL; SUM_GP] THEN
      CONV_TAC REAL_RAT_REDUCE_CONV THEN
      COND_CASES_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
      REWRITE_TAC[REAL_ARITH `c * (x * 3) * 1 / 3 = x * c`] THEN
      ASM_SIMP_TAC[GSYM REAL_LT_RDIV_EQ] THEN
      MATCH_MP_TAC(REAL_ARITH `abs x < y \<and> 0 \<le> z \<Longrightarrow> x - z < y`) THEN
      ASM_SIMP_TAC[] THEN MATCH_MP_TAC REAL_POW_LE THEN
      CONV_TAC REAL_RAT_REDUCE_CONV];
    DISCH_THEN(X_CHOOSE_THEN `h::A=>real` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `\<lambda>x. max a (min ((h::A=>real) x) b)` THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_MAX; CONTINUOUS_MAP_REAL_MIN;
                 CONTINUOUS_MAP_REAL_CONST] THEN
    CONJ_TAC THEN X_GEN_TAC `x::A` THEN DISCH_TAC THENL
     [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
    MATCH_MP_TAC(REAL_ARITH
     `a \<le> x \<and> x \<le> b \<and> y = x \<Longrightarrow> max a (min y b) = x`) THEN
    ASM_SIMP_TAC[] THEN
    MATCH_MP_TAC(ISPEC `sequentially` LIMIT_METRIC_UNIQUE) THEN
    MAP_EVERY EXISTS_TAC
     [`real_euclidean_metric`; `\<lambda>n. (g::num=>A->real) n x`] THEN
    REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY; LIMIT_METRIC] THEN
    REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN
    REWRITE_TAC[\<subseteq>] THEN DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN CONJ_TAC THEN
    X_GEN_TAC `e::real` THEN DISCH_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e::real`) THEN
      ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] EVENTUALLY_MONO) THEN
      ASM_SIMP_TAC[];
      MP_TAC(ISPECL [`2 / 3`; `e / c::real`] ARCH_EVENTUALLY_POW_INV) THEN
      CONV_TAC REAL_RAT_REDUCE_CONV THEN ASM_SIMP_TAC[REAL_LT_DIV] THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] EVENTUALLY_MONO) THEN
      ASM_SIMP_TAC[REAL_LT_RDIV_EQ] THEN X_GEN_TAC `n::num` THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] REAL_LET_TRANS) THEN
      REWRITE_TAC[REAL_ARITH
       `abs x * c = c * (if 0 \<le> x then x else-x)`] THEN
      ASM_SIMP_TAC[REAL_POW_LE; REAL_ARITH `0 \<le> 2 / 3`]]]);;

lemma tietze_extension_realinterval:
   "\<And>X f::A=>real s t.
        normal_space X \<and> closedin X s \<and>
        is_interval t \<and> (t \<noteq> {}) \<and>
        continuous_map (subtopology X s,euclideanreal) f \<and>
        (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> t)
        \<Longrightarrow> \<exists>g. continuous_map X euclideanreal g \<and>
                (\<forall>x. x \<in> topspace X \<Longrightarrow> g x \<in> t) \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
  GEN_TAC THEN GEN_REWRITE_TAC id [SWAP_FORALL_THM] THEN
  GEN_TAC THEN GEN_REWRITE_TAC id [SWAP_FORALL_THM] THEN
  MATCH_MP_TAC(MESON[]
   `((\<forall>t. real_bounded t \<Longrightarrow> P t) \<Longrightarrow> (\<forall>t. P t)) \<and>
    (\<forall>t. real_bounded t \<Longrightarrow> P t)
    \<Longrightarrow> \<forall>t. P t`) THEN
  CONJ_TAC THENL
   [DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`t::real=>bool`; `f::A=>real`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `image (\<lambda>x. x / (1 + abs x)) t`) THEN
    ASM_REWRITE_TAC[IS_REALINTERVAL_SHRINK; REAL_BOUNDED_SHRINK] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `(\<lambda>x. x / (1 + abs x)) \<circ> (f::A=>real)`) THEN
    ASM_REWRITE_TAC[IMAGE_EQ_EMPTY] THEN ANTS_TAC THENL
     [CONJ_TAC THENL [ALL_TAC; REWRITE_TAC[o_DEF] THEN ASM SET_TAC[]] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        CONTINUOUS_MAP_COMPOSE)) THEN
      REWRITE_TAC[REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY]
        CONTINUOUS_MAP_REAL_SHRINK];

      DISCH_THEN(X_CHOOSE_THEN `g::A=>real` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC `(\<lambda>x. x / (1 - abs x)) \<circ> (g::A=>real)` THEN
      ASM_SIMP_TAC[o_THM; REAL_GROW_SHRINK] THEN CONJ_TAC THENL
       [MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
        EXISTS_TAC `subtopology euclideanreal (real_interval(-1,1))` THEN
        REWRITE_TAC[CONTINUOUS_MAP_REAL_GROW] THEN
        ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
        FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
         `(\<forall>x. x \<in> t \<Longrightarrow> g x \<in> h ` u) \<Longrightarrow> (\<forall>x. x \<in> u \<Longrightarrow> h x \<in> v)
          \<Longrightarrow> g ` t \<subseteq> v`)) THEN
        REWRITE_TAC[IN_REAL_INTERVAL; REAL_BOUNDS_LT; REAL_SHRINK_RANGE];
        FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
         `(\<forall>x. x \<in> u \<Longrightarrow> g x \<in> h ` t)
          \<Longrightarrow> (\<forall>x. x \<in> t \<Longrightarrow> f(h x) = x)
              \<Longrightarrow> (\<forall>x. x \<in> u \<Longrightarrow> f(g x) \<in> t)`)) THEN
        REWRITE_TAC[REAL_GROW_SHRINK]]];
    X_GEN_TAC `t::real=>bool` THEN DISCH_TAC THEN
    X_GEN_TAC `f::A=>real` THEN STRIP_TAC] THEN
  MP_TAC(SPEC `euclideanreal closure_of t` REAL_COMPACT_IS_REALINTERVAL) THEN
  ASM_SIMP_TAC[IS_REALINTERVAL_CLOSURE_OF] THEN
  REWRITE_TAC[REAL_COMPACT_EQ_BOUNDED_CLOSED; REAL_CLOSED_IN] THEN
  REWRITE_TAC[CLOSED_IN_CLOSURE_OF; GSYM MBOUNDED_REAL_EUCLIDEAN_METRIC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SYM MBOUNDED_REAL_EUCLIDEAN_METRIC]) THEN
  ASM_SIMP_TAC[MBOUNDED_CLOSURE_OF; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  MAP_EVERY X_GEN_TAC [`a::real`; `b::real`] THEN
  ASM_CASES_TAC `real_interval[a,b] = {}` THEN
  ASM_SIMP_TAC[CLOSURE_OF_EQ_EMPTY; TOPSPACE_EUCLIDEANREAL; SUBSET_UNIV] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[REAL_INTERVAL_NE_EMPTY]) THEN DISCH_TAC THEN
  MP_TAC(ISPECL[`X::A topology`; `f::A=>real`; `s::A=>bool`; `a::real`; `b::real`]
        TIETZE_EXTENSION_CLOSED_REAL_INTERVAL) THEN
  ASM_REWRITE_TAC[] THEN ANTS_TAC THENL
   [ASM_MESON_TAC[CLOSURE_OF_SUBSET; \<subseteq>; IN_UNIV; TOPSPACE_EUCLIDEANREAL];
    DISCH_THEN(X_CHOOSE_THEN `g::A=>real` STRIP_ASSUME_TAC)] THEN
  MP_TAC(ISPECL
   [`X::A topology`;
    `{x \<in> topspace X.
          (g::A=>real) x \<in> euclideanreal closure_of t - t}`;
    `s::A=>bool`; `0`; `1`] URYSOHN_LEMMA) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; REAL_POS] THEN
  ANTS_TAC THENL
   [CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
    EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN THEN
    REWRITE_TAC[HAUSDORFF_SPACE_EUCLIDEANREAL] THEN
    MATCH_MP_TAC FINITE_IMP_COMPACT_IN THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; SUBSET_UNIV] THEN
    MATCH_MP_TAC FINITE_SUBSET THEN EXISTS_TAC `{a::real,b}` THEN
    REWRITE_TAC[FINITE_INSERT; FINITE_EMPTY] THEN
    MATCH_MP_TAC(SET_RULE `s - u \<subseteq> t \<Longrightarrow> s - t \<subseteq> u`) THEN
    REWRITE_TAC[GSYM REAL_OPEN_CLOSED_INTERVAL] THEN
    ASM_SIMP_TAC[GSYM REAL_OPEN_SUBSET_CLOSURE_OF_REALINTERVAL_ALT;
                 REAL_OPEN_REAL_INTERVAL; REAL_INTERVAL_OPEN_SUBSET_CLOSED];
    REWRITE_TAC[LEFT_IMP_EXISTS_THM; \<subseteq>; FORALL_IN_IMAGE] THEN
    X_GEN_TAC `h::A=>real` THEN
    REWRITE_TAC[IN_REAL_INTERVAL; IN_ELIM_THM] THEN
    REWRITE_TAC[IN_DIFF] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC `z::real`) THEN
    EXISTS_TAC `\<lambda>x. z + (h::A=>real) x * (g x - z)` THEN
    ASM_SIMP_TAC[REAL_ARITH `z + 1 * (x - z) = x`] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; CONTINUOUS_MAP_REAL_SUB;
      CONTINUOUS_MAP_REAL_MUL; CONTINUOUS_MAP_REAL_CONST; ETA_AX] THEN
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    ASM_CASES_TAC `(g::A=>real) x \<in> t` THEN
    ASM_SIMP_TAC[REAL_MUL_LZERO; REAL_ADD_RID] THEN
    SUBGOAL_THEN
     `z \<le> z + h x * (g x - z) \<and> z + h x * ((g::A=>real) x - z) \<le> g x \<or>
      g x \<le> z + h x * (g x - z) \<and> z + h x * (g x - z) \<le> z`
    MP_TAC THENL [ALL_TAC; ASM_MESON_TAC[is_interval]] THEN
    MATCH_MP_TAC(REAL_ARITH
     `abs(x - a) \<le> abs(b - a) \<and> abs(x - b) \<le> abs(b - a)
      \<Longrightarrow> a \<le> x \<and> x \<le> b \<or> b \<le> x \<and> x \<le> a`) THEN
    REWRITE_TAC[REAL_ARITH `(z + h * (g - z)) - g = --(1 - h) * (g - z)`] THEN
    REWRITE_TAC[REAL_ADD_SUB; REAL_ABS_MUL; REAL_ABS_NEG] THEN
    CONJ_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
    MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[REAL_ABS_POS] THEN
    ASM_SIMP_TAC[REAL_ARITH
     `0 \<le> x \<and> x \<le> 1 \<Longrightarrow> abs x \<le> 1 \<and> abs(1 - x) \<le> 1`]]);;

lemma normal_space_eq_tietze:
   "        normal_space X \<longleftrightarrow>
        \<forall>f s. closedin X s \<and>
              continuous_map (subtopology X s,euclideanreal) f
              \<Longrightarrow> \<exists>g. continuous_map X euclideanreal g \<and>
                      \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  GEN_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN
    MP_TAC(ISPECL [`X::A topology`; `f::A=>real`; `s::A=>bool`; `UNIV`]
        TIETZE_EXTENSION_REALINTERVAL) THEN
    ASM_REWRITE_TAC[IS_REALINTERVAL_UNIV; IN_UNIV; UNIV_NOT_EMPTY];
    DISCH_TAC THEN REWRITE_TAC[NORMAL_SPACE_EQ_URYSOHN_ALT] THEN
    MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL
     [`(\<lambda>x. if x \<in> s then 0 else 1):A=>real`; `s \<union> t::A=>bool`]) THEN
    RULE_ASSUM_TAC(REWRITE_RULE[SET_RULE
     `disjnt s t \<longleftrightarrow> \<forall>x. x \<in> t \<Longrightarrow> (x \<notin> s)`]) THEN
    ASM_SIMP_TAC[CLOSED_IN_UNION; FORALL_IN_UNION] THEN
    DISCH_THEN MATCH_MP_TAC THEN
    REWRITE_TAC[CONTINUOUS_MAP_CLOSED_IN; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    X_GEN_TAC `c::real=>bool` THEN STRIP_TAC THEN
    MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
    CONJ_TAC THENL [ALL_TAC; SET_TAC[]] THEN
    ONCE_REWRITE_TAC[COND_RAND] THEN ONCE_REWRITE_TAC[COND_RATOR] THEN
    REWRITE_TAC[IN_INTER; GSYM CONJ_ASSOC] THEN
    ONCE_REWRITE_TAC[COND_RAND] THEN SIMP_TAC[IN_UNION] THEN
    ASM_SIMP_TAC[COND_EXPAND; TAUT
     `(q \<Longrightarrow> \<not> p) \<Longrightarrow> ((\<not> p \<or> z) \<and> (p \<or> q \<and> w) \<longleftrightarrow> p \<and> z \<or> q \<and> w)`] THEN
    ASM_SIMP_TAC[CLOSED_IN_SUBSET; SET_RULE
     `s \<subseteq> u \<and> t \<subseteq> u
      \<Longrightarrow> {x. x \<in> u \<and> (x \<in> s \<and> P \<or> x \<in> t \<and> Q)} =
          {x. x \<in> s \<and> P} \<union> {x. x \<in> t \<and> Q}`] THEN
    MAP_EVERY ASM_CASES_TAC [`(0::real) \<in> c`; `(1::real) \<in> c`] THEN
    ASM_REWRITE_TAC[EMPTY_GSPEC; CLOSED_IN_EMPTY; UNION_EMPTY; IN_GSPEC] THEN
    ASM_SIMP_TAC[CLOSED_IN_UNION]]);;

lemma normal_space_perfect_map_image:
   "\<And>X X' f.
    normal_space X \<and> perfect_map X X' f \<Longrightarrow> normal_space X'"
oops
  REWRITE_TAC[perfect_map; proper_map] THEN
  MESON_TAC[NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE]);;

lemma Hausdorff_normal_space_closed_continuous_map_image:
   "\<And>X X' f.
        normal_space X \<and>
        closed_map X X' f \<and>
        continuous_map X X' f \<and>
        f ` (topspace X) = topspace X' \<and>
        t1_space X'
        \<Longrightarrow> Hausdorff_space X'"
oops
  MESON_TAC[NORMAL_T1_IMP_HAUSDORFF_SPACE;
            NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE]);;

lemma normal_Hausdorff_space_closed_continuous_map_image:
   "\<And>X X' f.
        normal_space X \<and>
        Hausdorff_space X \<and>
        closed_map X X' f \<and>
        continuous_map X X' f \<and>
        f ` (topspace X) = topspace X'
        \<Longrightarrow> normal_space X' \<and> Hausdorff_space X'"
oops
  MESON_TAC[NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE;
            NORMAL_T1_IMP_HAUSDORFF_SPACE;
            T1_SPACE_CLOSED_MAP_IMAGE; HAUSDORFF_IMP_T1_SPACE]);;

lemma regular_lindelof_imp_normal_space:
   "        regular_space X \<and> lindelof_space X \<Longrightarrow> normal_space X"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[normal_space] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
  ASM_CASES_TAC `s::A=>bool = {}` THENL
   [MAP_EVERY EXISTS_TAC [`{}:A=>bool`; `topspace X::A=>bool`] THEN
    ASM_SIMP_TAC[OPEN_IN_TOPSPACE; OPEN_IN_EMPTY; CLOSED_IN_SUBSET] THEN
    SET_TAC[];
    ALL_TAC] THEN
  ASM_CASES_TAC `t::A=>bool = {}` THENL
   [MAP_EVERY EXISTS_TAC [`topspace X::A=>bool`; `{}:A=>bool`] THEN
    ASM_SIMP_TAC[OPEN_IN_TOPSPACE; OPEN_IN_EMPTY; CLOSED_IN_SUBSET] THEN
    SET_TAC[];
    ALL_TAC] THEN
  SUBGOAL_THEN
   `\<exists>h::num=>A->bool.
        (\<forall>n. openin X (h n)) \<and>
        (\<forall>n. disjnt t (X closure_of (h n))) \<and>
        s \<subseteq> \<Union> (image h UNIV)`
  STRIP_ASSUME_TAC THENL
   [SUBGOAL_THEN
     `\<forall>x. x \<in> s
          \<Longrightarrow> \<exists>u. openin X u \<and> (x::A) \<in> u \<and>
                  disjnt t (X closure_of u)`
    MP_TAC THENL
     [X_GEN_TAC `x::A` THEN DISCH_TAC THEN
      FIRST_ASSUM(MATCH_MP_TAC \<circ> REWRITE_RULE[REGULAR_SPACE]) THEN
      ASM_REWRITE_TAC[IN_DIFF] THEN CONJ_TAC THENL
       [ASM_MESON_TAC[CLOSED_IN_SUBSET; \<subseteq>]; ASM SET_TAC[]];
      GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM]] THEN
    REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `h::A=>A->bool` THEN DISCH_TAC THEN
    SUBGOAL_THEN `lindelof_space(subtopology X (s::A=>bool))` MP_TAC THENL
     [ASM_SIMP_TAC[LINDELOF_SPACE_CLOSED_IN_SUBTOPOLOGY];
      ASM_SIMP_TAC[LINDELOF_SPACE_SUBTOPOLOGY_SUBSET; CLOSED_IN_SUBSET]] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `image (h::A=>A->bool) s`) THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN `U:(A=>bool)->bool`
     (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_CASES_TAC `U:(A=>bool)->bool = {}` THEN
    ASM_REWRITE_TAC[UNIONS_0; SUBSET_EMPTY] THEN STRIP_TAC THEN
    MP_TAC(ISPEC `U:(A=>bool)->bool` COUNTABLE_AS_IMAGE) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
    GEN_TAC THEN DISCH_THEN SUBST_ALL_TAC THEN ASM SET_TAC[];
    ALL_TAC] THEN
  SUBGOAL_THEN
   `\<exists>k::num=>A->bool.
        (\<forall>n. openin X (k n)) \<and>
        (\<forall>n. disjnt s (X closure_of (k n))) \<and>
        t \<subseteq> \<Union> (image k UNIV)`
  STRIP_ASSUME_TAC THENL
   [SUBGOAL_THEN
     `\<forall>x. x \<in> t
          \<Longrightarrow> \<exists>u. openin X u \<and> (x::A) \<in> u \<and>
                  disjnt s (X closure_of u)`
    MP_TAC THENL
     [X_GEN_TAC `x::A` THEN DISCH_TAC THEN
      FIRST_ASSUM(MATCH_MP_TAC \<circ> REWRITE_RULE[REGULAR_SPACE]) THEN
      ASM_REWRITE_TAC[IN_DIFF] THEN CONJ_TAC THENL
       [ASM_MESON_TAC[CLOSED_IN_SUBSET; \<subseteq>]; ASM SET_TAC[]];
      GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM]] THEN
    REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `k::A=>A->bool` THEN DISCH_TAC THEN
    SUBGOAL_THEN `lindelof_space(subtopology X (t::A=>bool))` MP_TAC THENL
     [ASM_SIMP_TAC[LINDELOF_SPACE_CLOSED_IN_SUBTOPOLOGY];
      ASM_SIMP_TAC[LINDELOF_SPACE_SUBTOPOLOGY_SUBSET; CLOSED_IN_SUBSET]] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `image (k::A=>A->bool) t`) THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN `U:(A=>bool)->bool`
     (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_CASES_TAC `U:(A=>bool)->bool = {}` THEN
    ASM_REWRITE_TAC[UNIONS_0; SUBSET_EMPTY] THEN STRIP_TAC THEN
    MP_TAC(ISPEC `U:(A=>bool)->bool` COUNTABLE_AS_IMAGE) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
    GEN_TAC THEN DISCH_THEN SUBST_ALL_TAC THEN ASM SET_TAC[];
    ALL_TAC] THEN
  MAP_EVERY EXISTS_TAC
   [`\<Union> (image (\<lambda>i. h i - \<Union> {X closure_of (k j) | j < i})
                   UNIV):A=>bool`;
    `\<Union> (image (\<lambda>i. k i - \<Union> {X closure_of (h j) | j \<le> i})
                   UNIV):A=>bool`] THEN
  REWRITE_TAC[] THEN GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC OPEN_IN_UNIONS THEN
    REWRITE_TAC[FORALL_IN_IMAGE; IN_UNIV] THEN
    X_GEN_TAC `n::num` THEN MATCH_MP_TAC OPEN_IN_DIFF THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CLOSED_IN_UNIONS THEN
    ONCE_REWRITE_TAC[SIMPLE_IMAGE_GEN] THEN
    SIMP_TAC[FINITE_IMAGE; FINITE_NUMSEG_LT; FINITE_NUMSEG_LE] THEN
    ASM_REWRITE_TAC[FORALL_IN_IMAGE; CLOSED_IN_CLOSURE_OF];
    ALL_TAC] THEN
  GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
   [REWRITE_TAC[UNIONS_IMAGE; UNIONS_GSPEC] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  REWRITE_TAC[SET_RULE
   `disjnt (\<Union> u) (\<Union> v) \<longleftrightarrow>
    \<forall>s. s \<in> u \<Longrightarrow> \<forall>t. t \<in> v \<Longrightarrow> disjnt s t`] THEN
  REWRITE_TAC[FORALL_IN_IMAGE; IN_UNIV] THEN
  MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN
  DISJ_CASES_TAC(ARITH_RULE `n::num < m \<or> m \<le> n`) THENL
   [ALL_TAC; ONCE_REWRITE_TAC[DISJOINT_SYM]] THEN
  MATCH_MP_TAC(SET_RULE
   `(\<exists>i. i \<in> f \<and> k \<subseteq> i)
    \<Longrightarrow> disjnt (h - \<Union> f) (k - u)`) THEN
  REWRITE_TAC[EXISTS_IN_GSPEC] THENL
   [EXISTS_TAC `n::num`; EXISTS_TAC `m::num`] THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CLOSURE_OF_SUBSET THEN
  ASM_SIMP_TAC[OPEN_IN_SUBSET]);;


subsection\<open>Hereditarily normal spaces\<close>


let HEREDITARILY_NORMAL_SPACE,HEREDITARILY_NORMAL_SEPARATION =
 (CONJ_PAIR \<circ> prove)
 (`(\<forall>X::A topology.
        hereditarily normal_space X \<longleftrightarrow>
        \<forall>u. openin X u \<Longrightarrow> normal_space(subtopology X u)) \<and>
   (\<forall>X::A topology.
        hereditarily normal_space X \<longleftrightarrow>
        \<forall>s t. separatedin X s t
              \<Longrightarrow> \<exists>u v. openin X u \<and> openin X v \<and>
                        s \<subseteq> u \<and> t \<subseteq> v \<and> disjnt u v)"
oops
  REWRITE_TAC[AND_FORALL_THM] THEN GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(p \<Longrightarrow> q) \<and> (r \<Longrightarrow> p) \<and> (q \<Longrightarrow> r) \<Longrightarrow> (p \<longleftrightarrow> q) \<and> (p \<longleftrightarrow> r)`) THEN
  REPEAT CONJ_TAC THENL
   [SIMP_TAC[HEREDITARILY];
    DISCH_TAC THEN REWRITE_TAC[hereditarily] THEN
    X_GEN_TAC `u::A=>bool` THEN DISCH_TAC THEN
    REWRITE_TAC[normal_space] THEN
    MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
    SUBGOAL_THEN `separatedin (subtopology X u) (s::A=>bool) t`
    MP_TAC THENL
     [ASM_SIMP_TAC[SEPARATED_IN_CLOSED_SETS];
      REWRITE_TAC[SEPARATED_IN_SUBTOPOLOGY]] THEN
    STRIP_TAC THEN REWRITE_TAC[RIGHT_EXISTS_AND_THM] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`]) THEN
    ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; EXISTS_IN_GSPEC] THEN
    REWRITE_TAC[RIGHT_AND_EXISTS_THM] THEN
    REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN ASM SET_TAC[];
    DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC
     `topspace X -
      (X closure_of s) \<inter> (X closure_of t):A=>bool`) THEN
    SIMP_TAC[OPEN_IN_DIFF; CLOSED_IN_INTER; OPEN_IN_TOPSPACE;
             CLOSED_IN_CLOSURE_OF; NORMAL_SPACE_CLOSURES] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`]) THEN ANTS_TAC THENL
     [REWRITE_TAC[CLOSURE_OF_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[separatedin]) THEN
      REPLICATE_TAC 2 (CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
      MATCH_MP_TAC(SET_RULE
       `X closure_of (u \<inter> s') \<subseteq> X closure_of s' \<and>
        X closure_of (v \<inter> t') \<subseteq> X closure_of t' \<and>
        s \<inter> t \<inter> X closure_of s' \<inter> X closure_of t' = {}
        \<Longrightarrow>
        disjnt (s \<inter> X closure_of (u \<inter> s'))
                 (t \<inter> X closure_of (v \<inter> t'))`) THEN
      SIMP_TAC[CLOSURE_OF_MONO; INTER_SUBSET] THEN ASM SET_TAC[];
      REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
      REPEAT(MATCH_MP_TAC MONO_AND THEN CONJ_TAC) THEN REWRITE_TAC[] THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_TRANS_FULL) THEN
     SIMP_TAC[OPEN_IN_DIFF; CLOSED_IN_INTER; OPEN_IN_TOPSPACE;
             CLOSED_IN_CLOSURE_OF]]]);;

lemma metrizable_imp_hereditarily_normal_space:
   "metrizable_space X \<Longrightarrow> hereditarily normal_space X"
oops
  SIMP_TAC[hereditarily; METRIZABLE_IMP_NORMAL_SPACE;
           METRIZABLE_SPACE_SUBTOPOLOGY]);;

lemma metrizable_space_separation:
   "\<And>X s t::A=>bool.
        metrizable_space X \<and> separatedin X s t
        \<Longrightarrow> \<exists>u v. openin X u \<and> openin X v \<and>
                  s \<subseteq> u \<and> t \<subseteq> v \<and> disjnt u v"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[GSYM HEREDITARILY_NORMAL_SEPARATION] THEN
  REWRITE_TAC[METRIZABLE_IMP_HEREDITARILY_NORMAL_SPACE]);;

lemma hereditarily_normal_separation_pairwise:
   "        hereditarily normal_space X \<longleftrightarrow>
        \<forall>u. finite u \<and> (\<forall>s. s \<in> u \<Longrightarrow> s \<subseteq> topspace X) \<and>
            pairwise (separatedin X) u
            \<Longrightarrow> \<exists>f. (\<forall>s. s \<in> u \<Longrightarrow> openin X (f s) \<and> s \<subseteq> f s) \<and>
                    pairwise (\<lambda>s t. disjnt (f s) (f t)) u"
oops
  GEN_TAC THEN REWRITE_TAC[HEREDITARILY_NORMAL_SEPARATION] THEN EQ_TAC THENL
   [DISCH_TAC THEN X_GEN_TAC `u:(A=>bool)->bool` THEN STRIP_TAC THEN
    SUBGOAL_THEN
     `\<forall>s. s \<in> u
          \<Longrightarrow> \<exists>v w. openin X v \<and> openin X w \<and> s \<subseteq> v \<and>
                    (\<forall>t::A=>bool. t \<in> u \<and> (t \<noteq> s) \<Longrightarrow> t \<subseteq> w) \<and>
                    disjnt v w`
    MP_TAC THENL
     [X_GEN_TAC `s::A=>bool` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL
       [`s::A=>bool`; `\<Union>(u DELETE (s::A=>bool))`]) THEN
      ASM_SIMP_TAC[SEPARATED_IN_UNIONS; FINITE_DELETE] THEN
      REWRITE_TAC[UNIONS_SUBSET; IN_DELETE] THEN
      DISCH_THEN MATCH_MP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [pairwise]) THEN
      ASM_MESON_TAC[];
      GEN_REWRITE_TAC (LAND_CONV \<circ> TOP_DEPTH_CONV) [RIGHT_IMP_EXISTS_THM] THEN
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC
     [`f:(A=>bool)->(A=>bool)`; `g:(A=>bool)->(A=>bool)`] THEN
    STRIP_TAC THEN
    EXISTS_TAC `\<lambda>s. (f:(A=>bool)->(A=>bool)) s \<inter>
                    \<Inter> {g t | t \<in> u - {s}}` THEN
    REWRITE_TAC[GSYM INTERS_INSERT; SUBSET_INTERS] THEN
    REWRITE_TAC[SIMPLE_IMAGE; pairwise] THEN
    ASM_SIMP_TAC[OPEN_IN_INTERS; NOT_INSERT_EMPTY; FINITE_INSERT; FINITE_IMAGE;
                 IN_DELETE; FORALL_IN_INSERT; FORALL_IN_IMAGE; IN_DELETE;
                 FINITE_DELETE] THEN
    REWRITE_TAC[INTERS_INSERT; INTERS_IMAGE] THEN ASM SET_TAC[];
    DISCH_TAC THEN MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN
    DISCH_TAC THEN ASM_CASES_TAC `t::A=>bool = s` THENL
     [FIRST_X_ASSUM SUBST_ALL_TAC THEN
      FIRST_X_ASSUM(SUBST1_TAC \<circ> GEN_REWRITE_RULE id [SEPARATED_IN_REFL]) THEN
      REPEAT(EXISTS_TAC `{}:A=>bool`) THEN
      ASM_REWRITE_TAC[OPEN_IN_EMPTY] THEN SET_TAC[];
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{(s::A=>bool),t}`) THEN
      REWRITE_TAC[PAIRWISE_INSERT; FINITE_INSERT; FORALL_IN_INSERT] THEN
      REWRITE_TAC[FINITE_EMPTY; NOT_IN_EMPTY; PAIRWISE_EMPTY; IN_SING] THEN
      ANTS_TAC THENL [ASM_MESON_TAC[separatedin]; ALL_TAC] THEN
      REWRITE_TAC[IMP_CONJ; FORALL_UNWIND_THM2] THEN ASM_MESON_TAC[]]]);;

lemma hereditarily_normal_space_perfect_map_image:
   "\<And>X X' f.
    hereditarily normal_space X \<and> perfect_map X X' f
    \<Longrightarrow> hereditarily normal_space X'"
oops
  REWRITE_TAC[perfect_map; proper_map] THEN
  MESON_TAC[HEREDITARILY_NORMAL_SPACE_CONTINUOUS_CLOSED_MAP_IMAGE]);;

lemma regular_second_countable_imp_hereditarily_normal_space:
   "        regular_space X \<and> second_countable X
        \<Longrightarrow> hereditarily normal_space X"
oops
  REWRITE_TAC[hereditarily] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REGULAR_LINDELOF_IMP_NORMAL_SPACE THEN
  ASM_SIMP_TAC[REGULAR_SPACE_SUBTOPOLOGY] THEN
  MATCH_MP_TAC SECOND_COUNTABLE_IMP_LINDELOF_SPACE THEN
  ASM_SIMP_TAC[SECOND_COUNTABLE_SUBTOPOLOGY]);;


subsection\<open>Completely regular spaces\<close>


let completely_regular_space = new_definition
 `completely_regular_space (X::A topology) \<longleftrightarrow>
    \<forall>s x. closedin X s \<and> x \<in> topspace X - s
          \<Longrightarrow> \<exists>f. continuous_map
                   (X,subtopology euclideanreal (real_interval[0,1])) f \<and>
                  f x = 0 \<and> \<forall>x. x \<in> s \<Longrightarrow> f x = 1`;;

lemma homeomorphic_completely_regular_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (completely_regular_space X \<longleftrightarrow> completely_regular_space X')"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic_space] THEN
  REWRITE_TAC[HOMEOMORPHIC_MAPS_MAP; LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`f::A=>B`; `g::B=>A`] THEN STRIP_TAC THEN
  REWRITE_TAC[completely_regular_space; IN_DIFF] THEN
  EQ_TAC THEN DISCH_TAC THENL
   [MAP_EVERY X_GEN_TAC [`d::B=>bool`; `y::B`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`image (g::B=>A) d`; `(g::B=>A) y`]);
    MAP_EVERY X_GEN_TAC [`c::A=>bool`; `x::A`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`f ` c`; `f x`])] THEN
  (ANTS_TAC THENL
   [CONJ_TAC THENL
     [ASM_MESON_TAC[HOMEOMORPHIC_MAP_CLOSEDNESS_EQ];
      FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN
      RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP]) THEN
      ASM SET_TAC[]];
    ALL_TAC])
  THENL
   [DISCH_THEN(X_CHOOSE_THEN `h::A=>real` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(h::A=>real) \<circ> (g::B=>A)`;
    DISCH_THEN(X_CHOOSE_THEN `h::B=>real` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(h::B=>real) \<circ> f`] THEN
  ASM_REWRITE_TAC[o_THM] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP]) THEN
  (CONJ_TAC THENL [ASM_MESON_TAC[CONTINUOUS_MAP_COMPOSE]; ASM SET_TAC[]]));;

lemma completely_regular_space_alt:
   "        completely_regular_space X \<longleftrightarrow>
        \<forall>s x. closedin X s \<and> x \<in> topspace X - s
              \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                      f x = 0 \<and> (\<forall>x. x \<in> s \<Longrightarrow> f x = 1)"
oops
  GEN_TAC THEN REWRITE_TAC[completely_regular_space] THEN EQ_TAC THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `s::A=>bool` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THENL
   [MESON_TAC[]; ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN `f::A=>real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `\<lambda>x. max 0 (min ((f::A=>real) x) 1)` THEN
  ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL; GSYM CONJ_ASSOC] THEN
  CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_MAX THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_MIN THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST]);;

lemma completely_regular_space_gen_alt:
   "\<And>(X::A topology) a b.
        (a \<noteq> b)
        \<Longrightarrow> (completely_regular_space X \<longleftrightarrow>
             \<forall>s x. closedin X s \<and> x \<in> topspace X - s
                   \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                           f x = a \<and> \<forall>x. x \<in> s \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[COMPLETELY_REGULAR_SPACE_ALT] THEN
  EQ_TAC THEN  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `s::A=>bool` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `f::A=>real` THEN STRIP_TAC THENL
   [EXISTS_TAC `\<lambda>x. a + (b - a) * (f::A=>real) x`;
    EXISTS_TAC `\<lambda>x. inverse(b - a) * ((f::A=>real) x - a)`] THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; CONTINUOUS_MAP_REAL_LMUL; ETA_AX;
               CONTINUOUS_MAP_REAL_SUB;
               CONTINUOUS_MAP_REAL_CONST] THEN
  REPEAT STRIP_TAC THEN UNDISCH_TAC `\<not> (a::real = b)` THEN
  CONV_TAC REAL_FIELD);;

lemma completely_regular_space_gen:
   "\<And>(X::A topology) a b.
        a < b
        \<Longrightarrow> (completely_regular_space X \<longleftrightarrow>
             \<forall>s x. closedin X s \<and> x \<in> topspace X - s
                   \<Longrightarrow> \<exists>f. continuous_map
                              (X,subtopology euclideanreal
                                     (real_interval[a,b])) f \<and>
                           f x = a \<and> \<forall>x. x \<in> s \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC[COMPLETELY_REGULAR_SPACE_GEN_ALT; REAL_LT_IMP_NE] THEN
  EQ_TAC THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `s::A=>bool` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THENL
   [ALL_TAC; MESON_TAC[]] THEN
  DISCH_THEN(X_CHOOSE_THEN `f::A=>real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `\<lambda>x. max a (min ((f::A=>real) x) b)` THEN
  ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL; GSYM CONJ_ASSOC] THEN
  CONJ_TAC THENL [ALL_TAC; ASM_REAL_ARITH_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_MAX THEN
  REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_MIN THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST]);;

lemma normal_imp_completely_regular_space_gen:
   "        normal_space X \<and>
        (t1_space X \<or> Hausdorff_space X \<or> regular_space X)
        \<Longrightarrow> completely_regular_space X"
oops
  GEN_TAC THEN REWRITE_TAC[NORMAL_SPACE_EQ_URYSOHN_ALT] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[COMPLETELY_REGULAR_SPACE_ALT; IN_DIFF] THEN
  MATCH_MP_TAC(TAUT
   `(q \<Longrightarrow> p) \<and> (p \<Longrightarrow> s) \<and> (r \<Longrightarrow> s) \<Longrightarrow> (p \<or> q \<or> r \<Longrightarrow> s)`) THEN
  REWRITE_TAC[HAUSDORFF_IMP_T1_SPACE] THEN CONJ_TAC THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `x::A`] THEN STRIP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`{x::A}`; `s::A=>bool`]) THEN
    ASM_SIMP_TAC[SET_RULE `disjnt {x} s \<longleftrightarrow> (x \<notin> s)`] THEN
    REWRITE_TAC[IN_SING; FORALL_UNWIND_THM2] THEN
    DISCH_THEN MATCH_MP_TAC THEN ASM_MESON_TAC[T1_SPACE_CLOSED_IN_SING];
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM
      NEIGHBOURHOOD_BASE_OF_CLOSED_IN]) THEN
    REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`topspace X - s::A=>bool`; `x::A`]) THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE; IN_DIFF;
                 LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `c::A=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`c::A=>bool`; `s::A=>bool`]) THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    MATCH_MP_TAC MONO_EXISTS THEN ASM SET_TAC[]]);;

lemma normal_imp_completely_regular_space:
   "        normal_space X \<and> (Hausdorff_space X \<or> regular_space X)
        \<Longrightarrow> completely_regular_space X"
oops
  MESON_TAC[NORMAL_IMP_COMPLETELY_REGULAR_SPACE_GEN]);;

lemma completely_regular_space_mtopology:
   "completely_regular_space mtopology"
oops
  SIMP_TAC[NORMAL_IMP_COMPLETELY_REGULAR_SPACE; NORMAL_SPACE_MTOPOLOGY;
           HAUSDORFF_SPACE_MTOPOLOGY]);;

lemma metrizable_imp_completely_regular_space:
   "metrizable_space X \<Longrightarrow> completely_regular_space X"
oops
  REWRITE_TAC[FORALL_METRIZABLE_SPACE; COMPLETELY_REGULAR_SPACE_MTOPOLOGY]);;

lemma completely_regular_space_discrete_topology:
   "\<And>u::A=>bool. completely_regular_space(discrete_topology u)"
oops
  SIMP_TAC[METRIZABLE_SPACE_DISCRETE_TOPOLOGY;
           METRIZABLE_IMP_COMPLETELY_REGULAR_SPACE]);;

lemma completely_regular_space_subtopology:
   "
        completely_regular_space X
        \<Longrightarrow> completely_regular_space (subtopology X s)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[completely_regular_space; IN_DIFF] THEN
  STRIP_TAC THEN
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; CLOSED_IN_SUBTOPOLOGY_ALT] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; FORALL_IN_GSPEC] THEN
  X_GEN_TAC `t::A=>bool` THEN DISCH_TAC THEN
  X_GEN_TAC `x::A` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`t::A=>bool`; `x::A`]) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY]);;

lemma completely_regular_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> completely_regular_space X
        \<Longrightarrow> completely_regular_space X'"
oops
  MATCH_MP_TAC HEREDITARY_IMP_RETRACTIVE_PROPERTY THEN
  REWRITE_TAC[COMPLETELY_REGULAR_SPACE_SUBTOPOLOGY;
              HOMEOMORPHIC_COMPLETELY_REGULAR_SPACE]);;

lemma completely_regular_imp_regular_space:
   "completely_regular_space X \<Longrightarrow> regular_space X"
oops
  GEN_TAC THEN REWRITE_TAC[completely_regular_space; regular_space] THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `c::A=>bool` THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN REWRITE_TAC[IN_DIFF] THEN
  DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [`{x::A | x \<in> topspace X \<and> f x \<in> {x. x < 1 / 2}}`;
    `{x::A | x \<in> topspace X \<and> f x \<in> {x. x > 1 / 2}}`] THEN
  ONCE_REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
    EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[GSYM REAL_OPEN_IN] THEN
    REWRITE_TAC[REAL_OPEN_HALFSPACE_LT; REAL_OPEN_HALFSPACE_GT];
    ONCE_REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
     [ASM_SIMP_TAC[\<subseteq>; IN_ELIM_THM] THEN
      CONV_TAC REAL_RAT_REDUCE_CONV THEN
      ASM_MESON_TAC[CLOSED_IN_SUBSET; \<subseteq>];
      SIMP_TAC[EXTENSION; disjnt; IN_INTER; NOT_IN_EMPTY; IN_ELIM_THM] THEN
      REAL_ARITH_TAC]]);;

lemma locally_compact_regular_imp_completely_regular_space:
   "        locally_compact_space X \<and> (Hausdorff_space X \<or> regular_space X)
        \<Longrightarrow> completely_regular_space X"
oops
  REWRITE_TAC[LOCALLY_COMPACT_HAUSDORFF_OR_REGULAR] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[completely_regular_space; IN_DIFF] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `x::A`] THEN STRIP_TAC THEN
  MP_TAC(ISPEC `X::A topology`
   LOCALLY_COMPACT_REGULAR_SPACE_NEIGHBOURHOOD_BASE) THEN
  ASM_REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`topspace X - s::A=>bool`; `x::A`]) THEN
  ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE; IN_DIFF;
               LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `m::A=>bool`] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM
   NEIGHBOURHOOD_BASE_OF_CLOSED_IN]) THEN
  REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`u::A=>bool`; `x::A`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `k::A=>bool`] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`subtopology X (m::A=>bool)`;
                 `k::A=>bool`; `m - u::A=>bool`; `0::real`; `1::real`]
        URYSOHN_LEMMA) THEN
  REWRITE_TAC[REAL_POS; IN_DIFF] THEN ANTS_TAC THENL
   [REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC COMPACT_HAUSDORFF_OR_REGULAR_IMP_NORMAL_SPACE THEN
      ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY; REGULAR_SPACE_SUBTOPOLOGY];
      MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN ASM SET_TAC[];
      REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY] THEN
      EXISTS_TAC `topspace X - u::A=>bool` THEN
      ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE] THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
      ASM SET_TAC[];
      ASM SET_TAC[]];
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; TOPSPACE_SUBTOPOLOGY;
                 SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
    DISCH_THEN(X_CHOOSE_THEN `g::A=>real` STRIP_ASSUME_TAC)] THEN
  EXISTS_TAC `\<lambda>x. if x \<in> m then (g::A=>real) x else 1` THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
   [ALL_TAC; REPEAT STRIP_TAC THEN COND_CASES_TAC THEN ASM SET_TAC[]] THEN
  CONJ_TAC THENL
   [ALL_TAC; ASM_MESON_TAC[ENDS_IN_UNIT_REAL_INTERVAL]] THEN
  REWRITE_TAC[CONTINUOUS_MAP_CLOSED_IN; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
  X_GEN_TAC `c::real=>bool` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   `{x \<in> topspace X. (if x \<in> m then g x else 1) \<in> c} =
    {x. x \<in> m \<and> (g::A=>real) x \<in> c} \<union>
    (if 1 \<in> c then topspace X - u else {})`
  SUBST1_TAC THENL
   [REWRITE_TAC[EXTENSION; IN_UNION; IN_ELIM_THM; IN_DIFF] THEN
    X_GEN_TAC `y::A` THEN ASM_CASES_TAC `(y::A) \<in> m` THEN
    ASM_REWRITE_TAC[] THENL [ALL_TAC; ASM SET_TAC[]] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_DIFF; NOT_IN_EMPTY] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
    ASM SET_TAC[];
    MATCH_MP_TAC CLOSED_IN_UNION THEN CONJ_TAC THENL
     [MATCH_MP_TAC CLOSED_IN_TRANS_FULL THEN EXISTS_TAC `m::A=>bool` THEN
      ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE_GEN THEN
      EXISTS_TAC `euclideanreal` THEN
      ASM_SIMP_TAC[CLOSED_IN_SUBSET_TOPSPACE; SUBSET_REFL];
      COND_CASES_TAC THEN REWRITE_TAC[CLOSED_IN_EMPTY] THEN
      ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE]]]);;

lemma completely_regular_eq_regular_space:
   "        locally_compact_space X
        \<Longrightarrow> (completely_regular_space X \<longleftrightarrow> regular_space X)"
oops
  MESON_TAC[COMPLETELY_REGULAR_IMP_REGULAR_SPACE;
            LOCALLY_COMPACT_REGULAR_IMP_COMPLETELY_REGULAR_SPACE]);;

lemma completely_regular_space_prod_topology:
   "\<And>(top1::A topology) (top2::B topology).
        completely_regular_space (prod_topology top1 top2) \<longleftrightarrow>
        topspace (prod_topology top1 top2) = {} \<or>
        completely_regular_space top1 \<and> completely_regular_space top2"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MATCH_MP_TAC TOPOLOGICAL_PROPERTY_OF_PROD_COMPONENT THEN
    REWRITE_TAC[HOMEOMORPHIC_COMPLETELY_REGULAR_SPACE] THEN
    SIMP_TAC[COMPLETELY_REGULAR_SPACE_SUBTOPOLOGY];
    ALL_TAC] THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THENL
   [ASM_REWRITE_TAC[completely_regular_space; IN_DIFF; NOT_IN_EMPTY];
    ASM_REWRITE_TAC[]] THEN
  REWRITE_TAC[COMPLETELY_REGULAR_SPACE_ALT] THEN
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_CLOSED_IN] THEN SIMP_TAC[IN_DIFF; IMP_CONJ] THEN
  GEN_REWRITE_TAC (BINOP_CONV \<circ> TOP_DEPTH_CONV) [RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[IMP_IMP; GSYM CONJ_ASSOC] THEN STRIP_TAC THEN
  REWRITE_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
  MAP_EVERY X_GEN_TAC [`w::A#B=>bool`; `x::A`; `y::B`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [OPEN_IN_PROD_TOPOLOGY_ALT]) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`x::A`; `y::B`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::B=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`v::B=>bool`; `y::B`]) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`u::A=>bool`; `x::A`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM; IN_REAL_INTERVAL] THEN
  X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
  X_GEN_TAC `g::B=>real` THEN STRIP_TAC THEN
  EXISTS_TAC `\<lambda>(x,y). 1 - (1 - (f::A=>real) x) * (1 - (g::B=>real) y)` THEN
  ASM_REWRITE_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
  CONV_TAC REAL_RAT_REDUCE_CONV THEN CONJ_TAC THENL
   [REWRITE_TAC[LAMBDA_PAIR] THEN
    REPEAT((MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB ORELSE
            MATCH_MP_TAC CONTINUOUS_MAP_REAL_MUL) THEN CONJ_TAC) THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_OF_FST; CONTINUOUS_MAP_OF_SND];
    REWRITE_TAC[REAL_RING
     `1 - (1 - x) * (1 - y) = 1 \<longleftrightarrow> x = 1 \<or> y = 1`] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[\<subseteq>; FORALL_PAIR_THM; IN_CROSS]) THEN
    ASM SET_TAC[]]);;

lemma completely_regular_space_product_topology:
   "\<And>(tops::K=>A topology) k.
        completely_regular_space (product_topology k tops) \<longleftrightarrow>
        topspace (product_topology k tops) = {} \<or>
        \<forall>i. i \<in> k \<Longrightarrow> completely_regular_space (tops i)"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MATCH_MP_TAC TOPOLOGICAL_PROPERTY_OF_PRODUCT_COMPONENT THEN
    REWRITE_TAC[HOMEOMORPHIC_COMPLETELY_REGULAR_SPACE] THEN
    SIMP_TAC[COMPLETELY_REGULAR_SPACE_SUBTOPOLOGY];
    ALL_TAC] THEN
  ASM_CASES_TAC `topspace (product_topology k (tops::K=>A topology)) = {}` THENL
   [ASM_REWRITE_TAC[completely_regular_space; NOT_IN_EMPTY; IN_DIFF];
    ASM_REWRITE_TAC[]] THEN
  REWRITE_TAC[COMPLETELY_REGULAR_SPACE_ALT] THEN
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_CLOSED_IN] THEN SIMP_TAC[IN_DIFF; IMP_CONJ] THEN
  GEN_REWRITE_TAC (BINOP_CONV \<circ> TOP_DEPTH_CONV) [RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[IMP_IMP; GSYM CONJ_ASSOC] THEN STRIP_TAC THEN
  REWRITE_TAC[FORALL_PAIR_THM; IN_CROSS] THEN
  MAP_EVERY X_GEN_TAC [`w:(K=>A)->bool`; `x::K=>A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id
   [OPEN_IN_PRODUCT_TOPOLOGY_ALT]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `x::K=>A`) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `u::K=>A->bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN `i::K` \<circ> SPECL
   [`i::K`; `(u::K=>A->bool) i`; `(x::K=>A) i`]) THEN
  REWRITE_TAC[MESON[\<subseteq>; OPEN_IN_SUBSET]
   `(P \<and> openin X u \<and> x \<in> topspace X \<and> x \<in> u \<Longrightarrow> Q) \<longleftrightarrow>
    P \<Longrightarrow> openin X u \<and> x \<in> u \<Longrightarrow> Q`] THEN
  MP_TAC(ASSUME `(x::K=>A) \<in> PiE k u`) THEN
  REWRITE_TAC[PiE; IN_ELIM_THM] THEN
  STRIP_TAC THEN ASM_SIMP_TAC[] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
  X_GEN_TAC `f::K=>A->real` THEN DISCH_TAC THEN
  EXISTS_TAC
   `\<lambda>z. 1 - product {i. i \<in> k \<and> \<not> (u i :A=>bool = topspace(tops i))}
                     (\<lambda>i. 1 - (f::K=>A->real) i (z i))` THEN
  REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; IN_ELIM_THM] THEN
  REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_PRODUCT THEN
    ASM_REWRITE_TAC[IN_ELIM_THM] THEN X_GEN_TAC `i::K` THEN STRIP_TAC THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC `(tops::K=>A topology) i` THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION];
    REWRITE_TAC[REAL_ARITH `1 - x = 0 \<longleftrightarrow> x = 1`] THEN
    MATCH_MP_TAC PRODUCT_EQ_1 THEN
    ASM_SIMP_TAC[IN_ELIM_THM; REAL_ARITH `1 - x = 1 \<longleftrightarrow> x = 0`];
    X_GEN_TAC `y::K=>A` THEN REWRITE_TAC[o_THM] THEN STRIP_TAC THEN
    REWRITE_TAC[REAL_ARITH `1 - x = 1 \<longleftrightarrow> x = 0`] THEN
    ASM_SIMP_TAC[PRODUCT_EQ_0; REAL_ARITH `1 - x = 0 \<longleftrightarrow> x = 1`] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::K=>A` \<circ> GEN_REWRITE_RULE id [\<subseteq>]) THEN
    ASM_REWRITE_TAC[PiE; IN_ELIM_THM] THEN ASM_MESON_TAC[]]);;


subsection\<open>Locally path-connected spaces\<close>


let weakly_locally_path_connected_at = new_definition
 `weakly_locally_path_connected_at x X \<longleftrightarrow>
    neighbourhood_base_at x (path_connectedin X) X`;;

let locally_path_connected_at = new_definition
 `locally_path_connected_at x X \<longleftrightarrow>
    neighbourhood_base_at x
      (\<lambda>u. openin X u \<and> path_connectedin X u ) X`;;

let locally_path_connected_space = new_definition
 `locally_path_connected_space X \<longleftrightarrow>
        neighbourhood_base_of (path_connectedin X) X`;;

let LOCALLY_PATH_CONNECTED_SPACE_ALT,
    LOCALLY_PATH_CONNECTED_SPACE_EQ_OPEN_PATH_COMPONENT_OF =
 (CONJ_PAIR \<circ> prove)
 (`(\<forall>X::A topology.
        locally_path_connected_space X \<longleftrightarrow>
        neighbourhood_base_of
          (\<lambda>u. openin X u \<and> path_connectedin X u) X) \<and>
   (\<forall>X::A topology.
        locally_path_connected_space X \<longleftrightarrow>
        \<forall>u x. openin X u \<and> x \<in> u
              \<Longrightarrow> openin X (path_component_of (subtopology X u) x))"
oops
  SIMP_TAC[OPEN_NEIGHBOURHOOD_BASE_OF] THEN
  REWRITE_TAC[AND_FORALL_THM; locally_path_connected_space] THEN
  REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  X_GEN_TAC `X::A topology` THEN
  MATCH_MP_TAC(TAUT
   `(q \<Longrightarrow> p) \<and> (p \<Longrightarrow> r) \<and> (r \<Longrightarrow> q) \<Longrightarrow> (p \<longleftrightarrow> q) \<and> (p \<longleftrightarrow> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[SUBSET_REFL];
    DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `y::A`] THEN STRIP_TAC THEN
    ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_ASSUM(SUBST1_TAC \<circ> last \<circ> CONJUNCTS \<circ>
     GEN_REWRITE_RULE id [PATH_COMPONENT_OF_EQUIV] \<circ>
     GEN_REWRITE_RULE id [\<in>]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`u::A=>bool`; `x::A`]) THEN ANTS_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[\<subseteq>]
        PATH_COMPONENT_OF_SUBSET_TOPSPACE)) THEN
      ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER];
      REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [`v::A=>bool`; `w::A=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `v::A=>bool` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC `w::A=>bool` THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
    ASM_REWRITE_TAC[PATH_CONNECTED_IN_SUBTOPOLOGY] THEN ASM SET_TAC[];
    DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `x::A`] THEN STRIP_TAC THEN
    EXISTS_TAC `path_component_of (subtopology X u) (x::A)` THEN
    ASM_SIMP_TAC[] THEN REPEAT CONJ_TAC THENL
     [W(MP_TAC \<circ> PART_MATCH rand PATH_CONNECTED_IN_PATH_COMPONENT_OF \<circ>
        rand \<circ> snd) THEN
      SIMP_TAC[PATH_CONNECTED_IN_SUBTOPOLOGY];
      REWRITE_TAC[\<in>] THEN REWRITE_TAC[PATH_COMPONENT_OF_REFL] THEN
      REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
      ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>];
      W(MP_TAC \<circ> PART_MATCH lhand PATH_COMPONENT_OF_SUBSET_TOPSPACE \<circ>
        lhand \<circ> snd) THEN
      SIMP_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER]]]);;

lemma locally_path_connected_space:
   "        locally_path_connected_space X \<longleftrightarrow>
        \<forall>v x. openin X v \<and> x \<in> v
              \<Longrightarrow> \<exists>u. openin X u \<and>
                      path_connectedin X u \<and>
                      x \<in> u \<and> u \<subseteq> v"
oops
  SIMP_TAC[LOCALLY_PATH_CONNECTED_SPACE_ALT; OPEN_NEIGHBOURHOOD_BASE_OF] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC]);;

lemma locally_path_connected_space_open_path_components:
   "        locally_path_connected_space X \<longleftrightarrow>
        \<forall>u c. openin X u \<and> c \<in> path_components_of(subtopology X u)
              \<Longrightarrow> openin X c"
oops
  REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE_EQ_OPEN_PATH_COMPONENT_OF] THEN
  REWRITE_TAC[path_components_of; IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]);;

lemma openin_path_component_of_locally_path_connected_space:
   "locally_path_connected_space X
             \<Longrightarrow> openin X (path_component_of X x)"
oops
  METIS_TAC[LOCALLY_PATH_CONNECTED_SPACE_EQ_OPEN_PATH_COMPONENT_OF;
            SUBTOPOLOGY_TOPSPACE; OPEN_IN_TOPSPACE;
            OPEN_IN_EMPTY; PATH_COMPONENT_OF_EQ_EMPTY]);;

lemma openin_path_components_of_locally_path_connected_space:
   "
        locally_path_connected_space X \<and> c \<in> path_components_of X
        \<Longrightarrow> openin X c"
oops
  REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE_OPEN_PATH_COMPONENTS] THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  EXISTS_TAC `topspace X::A=>bool` THEN
  ASM_REWRITE_TAC[OPEN_IN_TOPSPACE; SUBTOPOLOGY_TOPSPACE]);;

lemma closedin_path_components_of_locally_path_connected_space:
   "
        locally_path_connected_space X \<and> c \<in> path_components_of X
        \<Longrightarrow> closedin X c"
oops
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC[closedin; PATH_COMPONENTS_OF_SUBSET] THEN
  ASM_SIMP_TAC[COMPLEMENT_PATH_COMPONENTS_OF_UNIONS] THEN
  MATCH_MP_TAC OPEN_IN_UNIONS THEN REWRITE_TAC[IN_DELETE] THEN
  ASM_SIMP_TAC[OPEN_IN_PATH_COMPONENTS_OF_LOCALLY_PATH_CONNECTED_SPACE]);;

lemma closedin_path_component_of_locally_path_connected_space:
   "locally_path_connected_space X
             \<Longrightarrow> closedin X (path_component_of X x)"
oops
  REPEAT STRIP_TAC THEN ASM_CASES_TAC `(x::A) \<in> topspace X` THEN
  ASM_SIMP_TAC[PATH_COMPONENT_IN_PATH_COMPONENTS_OF;
               CLOSED_IN_PATH_COMPONENTS_OF_LOCALLY_PATH_CONNECTED_SPACE] THEN
  ASM_MESON_TAC[CLOSED_IN_EMPTY; PATH_COMPONENT_OF_EQ_EMPTY]);;

lemma weakly_locally_path_connected_at:
   "        weakly_locally_path_connected_at x X \<longleftrightarrow>
        \<forall>v. openin X v \<and> x \<in> v
            \<Longrightarrow> \<exists>u. openin X u \<and>
                    x \<in> u \<and> u \<subseteq> v \<and>
                    \<forall>y. y \<in> u
                        \<Longrightarrow> \<exists>c. path_connectedin X c \<and>
                                c \<subseteq> v \<and> x \<in> c \<and> y \<in> c"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[neighbourhood_base_at; weakly_locally_path_connected_at] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC `v::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `v::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `u::A=>bool` THENL [ASM_MESON_TAC[\<subseteq>]; STRIP_TAC] THEN
  EXISTS_TAC `path_component_of (subtopology X v) (x::A)` THEN
  ASM_REWRITE_TAC[] THEN REPEAT CONJ_TAC THENL
   [MESON_TAC[PATH_CONNECTED_IN_PATH_COMPONENT_OF;
              PATH_CONNECTED_IN_SUBTOPOLOGY];
    REWRITE_TAC[\<subseteq>] THEN X_GEN_TAC `y::A` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::A`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `c::A=>bool` MP_TAC) THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(SET_RULE `s \<subseteq> t \<Longrightarrow> x \<in> s \<Longrightarrow> x \<in> t`) THEN
    MATCH_MP_TAC PATH_COMPONENT_OF_MAXIMAL THEN
    ASM_REWRITE_TAC[PATH_CONNECTED_IN_SUBTOPOLOGY];
    MESON_TAC[PATH_COMPONENT_OF_SUBSET_TOPSPACE; TOPSPACE_SUBTOPOLOGY;
              SUBSET_INTER]]);;

lemma locally_path_connected_space_im_kleinen:
   "        locally_path_connected_space X \<longleftrightarrow>
        \<forall>v x. openin X v \<and> x \<in> v
            \<Longrightarrow> \<exists>u. openin X u \<and>
                    x \<in> u \<and> u \<subseteq> v \<and>
                    \<forall>y. y \<in> u
                        \<Longrightarrow> \<exists>c. path_connectedin X c \<and>
                                c \<subseteq> v \<and> x \<in> c \<and> y \<in> c"
oops
  REWRITE_TAC[locally_path_connected_space; neighbourhood_base_of] THEN
  GEN_TAC THEN REWRITE_TAC[GSYM weakly_locally_path_connected_at] THEN
  REWRITE_TAC[WEAKLY_LOCALLY_PATH_CONNECTED_AT] THEN
  REWRITE_TAC[RIGHT_IMP_FORALL_THM; IMP_IMP] THEN
  EQ_TAC THEN REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_MESON_TAC[REWRITE_RULE[\<subseteq>] OPEN_IN_SUBSET]);;

lemma locally_path_connected_space_open_subset:
   "
        locally_path_connected_space X \<and> openin X s
        \<Longrightarrow> locally_path_connected_space (subtopology X s)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[locally_path_connected_space] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP NEIGHBOURHOOD_BASE_OF_OPEN_SUBSET) THEN
  GEN_REWRITE_TAC LAND_CONV [NEIGHBOURHOOD_BASE_OF_WITH_SUBSET] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] NEIGHBOURHOOD_BASE_OF_MONO) THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY; PATH_CONNECTED_IN_SUBTOPOLOGY;
           SUBSET_INTER]);;

lemma locally_path_connected_space_quotient_map_image:
   "\<And>X X' f::A=>B.
        quotient_map X X' f \<and> locally_path_connected_space X
        \<Longrightarrow> locally_path_connected_space X'"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quotient_map] THEN
  REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE_OPEN_PATH_COMPONENTS] THEN
  STRIP_TAC THEN MAP_EVERY X_GEN_TAC [`v::B=>bool`; `c::B=>bool`] THEN
  STRIP_TAC THEN
  FIRST_ASSUM(fun th -> W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand) th \<circ> snd)) THEN
  ANTS_TAC THENL
   [FIRST_ASSUM(MP_TAC \<circ> MATCH_MP PATH_COMPONENTS_OF_SUBSET) THEN
    ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN ASM SET_TAC[];
    DISCH_THEN(SUBST1_TAC \<circ> SYM)] THEN
  GEN_REWRITE_TAC id [OPEN_IN_SUBOPEN] THEN X_GEN_TAC `x::A` THEN
  REWRITE_TAC[IN_ELIM_THM] THEN STRIP_TAC THEN
  EXISTS_TAC
   `path_component_of
      (subtopology X {z. z \<in> topspace X \<and> f z \<in> v}) x` THEN
  REPEAT CONJ_TAC THENL
   [FIRST_X_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC `{z. z \<in> topspace X \<and> f z \<in> v}` THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET; path_components_of] THEN
    REWRITE_TAC[SIMPLE_IMAGE; ETA_AX] THEN MATCH_MP_TAC FUN_IN_IMAGE;
    GEN_REWRITE_TAC id [\<in>] THEN REWRITE_TAC[PATH_COMPONENT_OF_REFL];
    MATCH_MP_TAC(SET_RULE
     `\<forall>v. s \<subseteq> u \<inter> {x. x \<in> u \<and> f x \<in> v} \<and> f ` s \<subseteq> c
          \<Longrightarrow> s \<subseteq> {x. x \<in> u \<and> f x \<in> c}`) THEN
    EXISTS_TAC `v::B=>bool` THEN
    REWRITE_TAC[PATH_COMPONENT_OF_SUBSET_TOPSPACE;
                GSYM TOPSPACE_SUBTOPOLOGY] THEN
    MATCH_MP_TAC PATH_COMPONENTS_OF_MAXIMAL THEN
    EXISTS_TAC `subtopology X' (v::B=>bool)` THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN EXISTS_TAC
       `subtopology X {z. z \<in> topspace X \<and> f z \<in> v}` THEN
      REWRITE_TAC[PATH_CONNECTED_IN_PATH_COMPONENT_OF] THEN
      REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
      SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
      MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
      MATCH_MP_TAC QUOTIENT_IMP_CONTINUOUS_MAP THEN
      ASM_REWRITE_TAC[quotient_map];
      REWRITE_TAC[SET_RULE
       `\<not> disjnt t (f ` s) \<longleftrightarrow> \<exists>x. x \<in> s \<and> f x \<in> t`] THEN
      EXISTS_TAC `x::A` THEN ASM_REWRITE_TAC[] THEN
      GEN_REWRITE_TAC id [\<in>] THEN REWRITE_TAC[PATH_COMPONENT_OF_REFL]]] THEN
  ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP PATH_COMPONENTS_OF_SUBSET) THEN
  ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN ASM SET_TAC[]);;

lemma homeomorphic_locally_path_connected_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (locally_path_connected_space X \<longleftrightarrow>
             locally_path_connected_space X')"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic_space] THEN
  REWRITE_TAC[HOMEOMORPHIC_MAPS_MAP; homeomorphic_map] THEN
  MESON_TAC[LOCALLY_PATH_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE]);;

lemma locally_path_connected_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> locally_path_connected_space X
        \<Longrightarrow> locally_path_connected_space X'"
oops
  MESON_TAC[LOCALLY_PATH_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE;
            RETRACTION_IMP_QUOTIENT_MAP]);;

lemma locally_path_connected_space_euclideanreal:
 (`locally_path_connected_space euclideanreal"
oops
  REWRITE_TAC[locally_path_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
  MAP_EVERY X_GEN_TAC [`w::real=>bool`; `x::real`] THEN
  REWRITE_TAC[GSYM REAL_OPEN_IN] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  GEN_REWRITE_TAC LAND_CONV [real_open] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `x::real`) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN `e::real` STRIP_ASSUME_TAC) THEN
  REPEAT(EXISTS_TAC `real_interval(x - e,x + e)`) THEN
  REWRITE_TAC[SUBSET_REFL; REAL_OPEN_REAL_INTERVAL;
              PATH_CONNECTED_IN_EUCLIDEANREAL_INTERVAL] THEN
  REWRITE_TAC[\<subseteq>; IN_REAL_INTERVAL] THEN CONJ_TAC THENL
   [ALL_TAC; REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC] THEN
  ASM_REAL_ARITH_TAC);;

lemma locally_path_connected_is_realinterval:
   "is_interval s
       \<Longrightarrow> locally_path_connected_space(subtopology euclideanreal s)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[locally_path_connected_space] THEN
  REWRITE_TAC[NEIGHBOURHOOD_BASE_OF; TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; IMP_CONJ] THEN
  REWRITE_TAC[RIGHT_FORALL_IMP_THM; RIGHT_EXISTS_AND_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; EXISTS_IN_GSPEC; IN_INTER; INTER_SUBSET] THEN
  X_GEN_TAC `u::real=>bool` THEN DISCH_TAC THEN
  X_GEN_TAC `a::real` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE LAND_CONV
   [GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC]) THEN
  REWRITE_TAC[OPEN_IN_MTOPOLOGY; MBALL_REAL_INTERVAL] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `a::real` \<circ> CONJUNCT2) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `r::real` THEN STRIP_TAC THEN
  EXISTS_TAC `real_interval(a - r,a + r)` THEN
  REWRITE_TAC[GSYM REAL_OPEN_IN; REAL_OPEN_REAL_INTERVAL] THEN
  EXISTS_TAC `s \<inter> real_interval(a - r,a + r)` THEN
  ASM_REWRITE_TAC[IN_REAL_INTERVAL; PATH_CONNECTED_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[INTER_SUBSET; SUBSET_INTER] THEN
  ASM_REWRITE_TAC[REAL_ARITH `a - r::real < a \<and> a < a + r \<longleftrightarrow> 0 < r`] THEN
  CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  REWRITE_TAC[PATH_CONNECTED_IN_EUCLIDEANREAL] THEN
  MATCH_MP_TAC IS_REALINTERVAL_INTER THEN
  ASM_REWRITE_TAC[IS_REALINTERVAL_INTERVAL]);;

lemma locally_path_connected_real_interval:
 (`(\<forall>a b. locally_path_connected_space
           (subtopology euclideanreal(real_interval[a,b]))) \<and>
   (\<forall>a b. locally_path_connected_space
           (subtopology euclideanreal(real_interval(a,b))))"
oops
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LOCALLY_PATH_CONNECTED_IS_REALINTERVAL THEN
  REWRITE_TAC[IS_REALINTERVAL_INTERVAL]);;

lemma locally_path_connected_space_discrete_topology:
   "\<And>u::A=>bool. locally_path_connected_space (discrete_topology u)"
oops
  GEN_TAC THEN REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE] THEN
  SIMP_TAC[OPEN_IN_DISCRETE_TOPOLOGY; PATH_CONNECTED_IN_DISCRETE_TOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `x::A`] THEN STRIP_TAC THEN
  EXISTS_TAC `{x::A}` THEN ASM SET_TAC[]);;

lemma path_component_eq_connected_component_of:
   "locally_path_connected_space X
             \<Longrightarrow> (path_component_of X x = connected_component_of X x)"
oops
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THENL
   [ALL_TAC;
    ASM_MESON_TAC[PATH_COMPONENT_OF_EQ_EMPTY;
                  CONNECTED_COMPONENT_OF_EQ_EMPTY]] THEN
  MP_TAC(ISPECL
   [`X::A topology`; `x::A`] CONNECTED_IN_CONNECTED_COMPONENT_OF) THEN
  REWRITE_TAC[connectedin; CONNECTED_SPACE_CLOPEN_IN] THEN
  REWRITE_TAC[TAUT `p \<Longrightarrow> q \<or> r \<longleftrightarrow> p \<and> \<not> q \<Longrightarrow> r`] THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET;
           CONNECTED_COMPONENT_OF_SUBSET_TOPSPACE] THEN
  DISCH_THEN MATCH_MP_TAC THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC OPEN_IN_SUBSET_TOPSPACE;
    MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE;
    ASM_REWRITE_TAC[PATH_COMPONENT_OF_EQ_EMPTY]] THEN
  REWRITE_TAC[PATH_COMPONENT_SUBSET_CONNECTED_COMPONENT_OF] THEN
  ASM_SIMP_TAC[OPEN_IN_PATH_COMPONENT_OF_LOCALLY_PATH_CONNECTED_SPACE;
               CLOSED_IN_PATH_COMPONENT_OF_LOCALLY_PATH_CONNECTED_SPACE]);;

lemma path_components_eq_connected_components_of:
   "        locally_path_connected_space X
        \<Longrightarrow> (path_components_of X = connected_components_of X)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[path_components_of; connected_components_of] THEN
  MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x = g x) \<Longrightarrow> {f x | x \<in> s} = {g x | x \<in> s}`) THEN
  ASM_SIMP_TAC[PATH_COMPONENT_EQ_CONNECTED_COMPONENT_OF]);;

lemma path_connected_eq_connected_space:
   "locally_path_connected_space X
         \<Longrightarrow> (path_connected_space X \<longleftrightarrow> connected_space X)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT;
              CONNECTED_SPACE_IFF_CONNECTED_COMPONENT] THEN
  ASM_SIMP_TAC[PATH_COMPONENT_EQ_CONNECTED_COMPONENT_OF]);;

lemma locally_path_connected_space_prod_topology:
   "      locally_path_connected_space (prod_topology top1 top2) \<longleftrightarrow>
      topspace (prod_topology top1 top2) = {} \<or>
      locally_path_connected_space top1 \<and> locally_path_connected_space top2"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THENL
   [ASM_REWRITE_TAC[locally_path_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>; NOT_IN_EMPTY];
    ALL_TAC] THEN
  ASM_REWRITE_TAC[] THEN RULE_ASSUM_TAC(REWRITE_RULE
   [TOPSPACE_PROD_TOPOLOGY; CROSS_EQ_EMPTY; DE_MORGAN_THM]) THEN
  ASM_REWRITE_TAC[] THEN EQ_TAC THENL
   [DISCH_THEN(fun th -> CONJ_TAC THEN MP_TAC th) THEN
    MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ] (REWRITE_RULE[CONJ_ASSOC]
      LOCALLY_PATH_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE))
    THENL [EXISTS_TAC `fst::A#B=>A`; EXISTS_TAC `snd::A#B=>B`] THEN
    ASM_REWRITE_TAC[QUOTIENT_MAP_FST; QUOTIENT_MAP_SND];
    FIRST_X_ASSUM(CONJUNCTS_THEN MP_TAC) THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `z::B` THEN DISCH_TAC THEN X_GEN_TAC `w::A` THEN DISCH_TAC THEN
    REWRITE_TAC[locally_path_connected_space; FORALL_PAIR_THM; IN_CROSS;
      NEIGHBOURHOOD_BASE_OF; TOPSPACE_PROD_TOPOLOGY] THEN STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`uv::A#B=>bool`; `x::A`; `y::B`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    GEN_REWRITE_TAC LAND_CONV [OPEN_IN_PROD_TOPOLOGY_ALT] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`x::A`; `y::B`]) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`w1::A=>bool`; `w2::B=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`w2::B=>bool`; `y::B`]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`w1::A=>bool`; `x::A`]) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u1::A=>bool`; `k1::A=>bool`] THEN STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`u2::B=>bool`; `k2::B=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `(u1::A=>bool) \<times> (u2::B=>bool)` THEN
    EXISTS_TAC `(k1::A=>bool) \<times> (k2::B=>bool)` THEN
    ASM_SIMP_TAC[OPEN_IN_CROSS; PATH_CONNECTED_IN_CROSS;
                IN_CROSS; SUBSET_CROSS] THEN
    TRANS_TAC SUBSET_TRANS `(w1 \<times> w2):A#B=>bool` THEN
    ASM_REWRITE_TAC[] THEN ASM_REWRITE_TAC[SUBSET_CROSS]]);;

lemma locally_path_connected_space_product_topology:
   "\<And>(tops::K=>A topology) k.
        locally_path_connected_space(product_topology k tops) \<longleftrightarrow>
        topspace(product_topology k tops) = {} \<or>
        finite {i. i \<in> k \<and> \<not> path_connected_space(tops i)} \<and>
        \<forall>i. i \<in> k \<Longrightarrow> locally_path_connected_space(tops i)"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(product_topology k (tops::K=>A topology)) = {}` THENL
   [ASM_REWRITE_TAC[locally_path_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>; NOT_IN_EMPTY];
    ALL_TAC] THEN
  ASM_REWRITE_TAC[locally_path_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
  EQ_TAC THENL
   [DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC `z::K=>A`) THEN CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> SPECL
       [`topspace(product_topology k (tops::K=>A topology))`; `z::K=>A`]) THEN
      ASM_REWRITE_TAC[OPEN_IN_TOPSPACE; LEFT_IMP_EXISTS_THM] THEN
      MAP_EVERY X_GEN_TAC [`u:(K=>A)->bool`; `c:(K=>A)->bool`] THEN
      STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC `z::K=>A` \<circ>
        REWRITE_RULE[OPEN_IN_PRODUCT_TOPOLOGY_ALT]) THEN
      ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC `v::K=>A->bool` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        FINITE_SUBSET)) THEN
      REWRITE_TAC[\<subseteq>; IN_ELIM_THM] THEN X_GEN_TAC `i::K` THEN
      ASM_CASES_TAC `(i::K) \<in> k` THEN ASM_REWRITE_TAC[CONTRAPOS_THM] THEN
      DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC \<circ> ISPECL [`\<lambda>x::K=>A. x i`; `(tops::K=>A topology) i`] \<circ>
        MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
            PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION;
                   GSYM PATH_CONNECTED_IN_TOPSPACE] THEN
      MATCH_MP_TAC EQ_IMP THEN AP_TERM_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC \<circ>
       MATCH_MP (SET_RULE `v = u \<Longrightarrow> v \<subseteq> s \<and> s \<subseteq> u \<Longrightarrow> s = u`)) THEN
      CONJ_TAC THENL
       [TRANS_TAC SUBSET_TRANS `image (\<lambda>x::K=>A. x i) u` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET] THEN TRANS_TAC SUBSET_TRANS
         `image (\<lambda>x::K=>A. x i) (PiE k v)` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET] THEN
        REWRITE_TAC[IMAGE_PROJECTION_CARTESIAN_PRODUCT] THEN
        COND_CASES_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
        ASM SET_TAC[];
        TRANS_TAC SUBSET_TRANS
          `image (\<lambda>x::K=>A. x i) (topspace(product_topology k tops))` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET; PATH_CONNECTED_IN_SUBSET_TOPSPACE] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_PRODUCT_TOPOLOGY]) THEN
        ASM_REWRITE_TAC[IMAGE_PROJECTION_CARTESIAN_PRODUCT;
                        TOPSPACE_PRODUCT_TOPOLOGY] THEN
        REWRITE_TAC[o_THM; SUBSET_REFL]];
      X_GEN_TAC `i::K` THEN DISCH_TAC THEN
      REWRITE_TAC[GSYM locally_path_connected_space; ETA_AX;
                  GSYM NEIGHBOURHOOD_BASE_OF] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[GSYM locally_path_connected_space; ETA_AX;
                                  GSYM NEIGHBOURHOOD_BASE_OF]) THEN
      FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ_ALT]
        (REWRITE_RULE[CONJ_ASSOC]
                LOCALLY_PATH_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE)))  THEN
      EXISTS_TAC `\<lambda>x::K=>A. x i` THEN
      ASM_SIMP_TAC[OPEN_MAP_PRODUCT_PROJECTION; TOPSPACE_PRODUCT_TOPOLOGY;
                   QUOTIENT_MAP_PRODUCT_PROJECTION;
                   IMAGE_PROJECTION_CARTESIAN_PRODUCT] THEN
      ASM_REWRITE_TAC[GSYM TOPSPACE_PRODUCT_TOPOLOGY; o_THM]];
    STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`ww:(K=>A)->bool`; `z::K=>A`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    GEN_REWRITE_TAC LAND_CONV [OPEN_IN_PRODUCT_TOPOLOGY_ALT] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `z::K=>A`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `w::K=>A->bool` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN
     `\<forall>i. i \<in> k
          \<Longrightarrow> \<exists>u c. openin (tops i) u \<and>
                    path_connectedin (tops i) c \<and>
                    ((z::K=>A) i) \<in> u \<and>
                    u \<subseteq> c \<and>
                    c \<subseteq> w i \<and>
                    (w i = topspace(tops i) \<and> path_connected_space(tops i)
                     \<Longrightarrow> u = topspace(tops i) \<and> c = topspace(tops i))`
    MP_TAC THENL
     [X_GEN_TAC `i::K` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`i::K`; `(w::K=>A->bool) i`] \<circ>
        GEN_REWRITE_RULE BINDER_CONV [RIGHT_IMP_FORALL_THM]) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `(z::K=>A) i`) THEN
      ANTS_TAC THENL
       [FIRST_X_ASSUM(MP_TAC \<circ>
         GEN_REWRITE_RULE RAND_CONV [PiE]) THEN
        ASM_SIMP_TAC[IN_ELIM_THM];
        ASM_CASES_TAC `path_connected_space((tops::K=>A topology) i)` THEN
        ASM_REWRITE_TAC[] THEN
        ASM_CASES_TAC `(w::K=>A->bool) i = topspace(tops i)` THEN
        ASM_REWRITE_TAC[] THEN DISCH_THEN(K ALL_TAC) THEN
        REPEAT(EXISTS_TAC `topspace((tops::K=>A topology) i)`) THEN
        ASM_REWRITE_TAC[PATH_CONNECTED_IN_TOPSPACE; SUBSET_REFL] THEN
        REWRITE_TAC[OPEN_IN_TOPSPACE] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM]) THEN
        ASM SET_TAC[]];
      GEN_REWRITE_TAC (LAND_CONV \<circ> TOP_DEPTH_CONV) [RIGHT_IMP_EXISTS_THM] THEN
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [`u::K=>A->bool`; `c::K=>A->bool`] THEN DISCH_TAC THEN
    MAP_EVERY EXISTS_TAC
     [`PiE k (u::K=>A->bool)`;
      `PiE k (c::K=>A->bool)`] THEN
    ASM_SIMP_TAC[PATH_CONNECTED_IN_CARTESIAN_PRODUCT] THEN
    ASM_SIMP_TAC[SUBSET_CARTESIAN_PRODUCT] THEN
    REWRITE_TAC[OPEN_IN_CARTESIAN_PRODUCT_GEN] THEN REPEAT CONJ_TAC THENL
     [DISJ2_TAC THEN ASM_SIMP_TAC[] THEN MATCH_MP_TAC FINITE_SUBSET THEN
      EXISTS_TAC `{i. i \<in> k \<and> \<not> path_connected_space (tops i)} \<union>
                  {i. i \<in> k \<and> \<not> ((w::K=>A->bool) i = topspace (tops i))}` THEN
      ASM_REWRITE_TAC[FINITE_UNION] THEN ASM SET_TAC[];
      UNDISCH_TAC `(z::K=>A) \<in> PiE k w` THEN
      REWRITE_TAC[PiE; IN_ELIM_THM] THEN ASM SET_TAC[];
      TRANS_TAC SUBSET_TRANS `PiE k (w::K=>A->bool)` THEN
      ASM_REWRITE_TAC[] THEN REWRITE_TAC[SUBSET_CARTESIAN_PRODUCT] THEN
      ASM SET_TAC[]]]);;

lemma locally_path_connected_space_sum_topology:
   "\<And>k (X::K=>A topology).
        locally_path_connected_space(sum_topology k X) \<longleftrightarrow>
        \<forall>i. i \<in> k \<Longrightarrow> locally_path_connected_space(X i)"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MATCH_MP_TAC TOPOLOGICAL_PROPERTY_OF_SUM_COMPONENT THEN
    REWRITE_TAC[HOMEOMORPHIC_LOCALLY_PATH_CONNECTED_SPACE] THEN
    SIMP_TAC[LOCALLY_PATH_CONNECTED_SPACE_OPEN_SUBSET];
    REWRITE_TAC[locally_path_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[FORALL_OPEN_IN_SUM_TOPOLOGY] THEN
    DISCH_TAC THEN X_GEN_TAC `w::K=>A->bool` THEN DISCH_TAC THEN
    REWRITE_TAC[FORALL_PAIR_THM; Sigma; IN_ELIM_PAIR_THM] THEN
    MAP_EVERY X_GEN_TAC [`i::K`; `x::A`] THEN STRIP_TAC THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `i::K`)) THEN
    ASM_REWRITE_TAC[] THEN REPEAT DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(w::K=>A->bool) i`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `image (\<lambda>x. (i::K),(x::A)) u` THEN
    EXISTS_TAC `image (\<lambda>x. (i::K),(x::A)) v` THEN
    ASM_SIMP_TAC[IMAGE_SUBSET] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_PAIR_THM] THEN
    ASM_REWRITE_TAC[GSYM \<subseteq>] THEN REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC(REWRITE_RULE[open_map; RIGHT_IMP_FORALL_THM; IMP_IMP]
        OPEN_MAP_COMPONENT_INJECTION) THEN
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC PATH_CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
      EXISTS_TAC `(X::K=>A topology) i` THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_COMPONENT_INJECTION];
      ASM SET_TAC[]]]);;


subsection\<open>Locally connected spaces\<close>


let weakly_locally_connected_at = new_definition
 `weakly_locally_connected_at x X \<longleftrightarrow>
    neighbourhood_base_at x (connectedin X) X`;;

let locally_connected_at = new_definition
 `locally_connected_at x X \<longleftrightarrow>
    neighbourhood_base_at x
      (\<lambda>u. openin X u \<and> connectedin X u ) X`;;

let locally_connected_space = new_definition
 `locally_connected_space X \<longleftrightarrow>
        neighbourhood_base_of (connectedin X) X`;;

let LOCALLY_CONNECTED_SPACE_ALT,
    LOCALLY_CONNECTED_SPACE_EQ_OPEN_CONNECTED_COMPONENT_OF =
 (CONJ_PAIR \<circ> prove)
 (`(\<forall>X::A topology.
        locally_connected_space X \<longleftrightarrow>
        neighbourhood_base_of
          (\<lambda>u. openin X u \<and> connectedin X u) X) \<and>
   (\<forall>X::A topology.
        locally_connected_space X \<longleftrightarrow>
        \<forall>u x. openin X u \<and> x \<in> u
              \<Longrightarrow> openin X (connected_component_of (subtopology X u) x))"
oops
  SIMP_TAC[OPEN_NEIGHBOURHOOD_BASE_OF] THEN
  REWRITE_TAC[AND_FORALL_THM; locally_connected_space] THEN
  REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  X_GEN_TAC `X::A topology` THEN
  MATCH_MP_TAC(TAUT
   `(q \<Longrightarrow> p) \<and> (p \<Longrightarrow> r) \<and> (r \<Longrightarrow> q) \<Longrightarrow> (p \<longleftrightarrow> q) \<and> (p \<longleftrightarrow> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[SUBSET_REFL];
    DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `y::A`] THEN STRIP_TAC THEN
    ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_ASSUM(SUBST1_TAC \<circ> last \<circ> CONJUNCTS \<circ>
     GEN_REWRITE_RULE id [CONNECTED_COMPONENT_OF_EQUIV] \<circ>
     GEN_REWRITE_RULE id [\<in>]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`u::A=>bool`; `x::A`]) THEN ANTS_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[\<subseteq>]
        CONNECTED_COMPONENT_OF_SUBSET_TOPSPACE)) THEN
      ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER];
      REWRITE_TAC[LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [`v::A=>bool`; `w::A=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `v::A=>bool` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC `w::A=>bool` THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONNECTED_COMPONENT_OF_MAXIMAL THEN
    ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN ASM SET_TAC[];
    DISCH_TAC THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `x::A`] THEN STRIP_TAC THEN
    EXISTS_TAC `connected_component_of (subtopology X u) (x::A)` THEN
    ASM_SIMP_TAC[] THEN REPEAT CONJ_TAC THENL
     [W(MP_TAC \<circ> PART_MATCH rand CONNECTED_IN_CONNECTED_COMPONENT_OF \<circ>
        rand \<circ> snd) THEN
      SIMP_TAC[CONNECTED_IN_SUBTOPOLOGY];
      REWRITE_TAC[\<in>] THEN REWRITE_TAC[CONNECTED_COMPONENT_OF_REFL] THEN
      REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
      ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>];
      W(MP_TAC \<circ> PART_MATCH lhand CONNECTED_COMPONENT_OF_SUBSET_TOPSPACE \<circ>
        lhand \<circ> snd) THEN
      SIMP_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER]]]);;

lemma locally_connected_space:
   "        locally_connected_space X \<longleftrightarrow>
        \<forall>v x. openin X v \<and> x \<in> v
              \<Longrightarrow> \<exists>u. openin X u \<and>
                      connectedin X u \<and>
                      x \<in> u \<and> u \<subseteq> v"
oops
  SIMP_TAC[LOCALLY_CONNECTED_SPACE_ALT; OPEN_NEIGHBOURHOOD_BASE_OF] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC]);;

lemma locally_path_connected_imp_locally_connected_space:
   "        locally_path_connected_space X \<Longrightarrow> locally_connected_space X"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[locally_path_connected_space; locally_connected_space] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] NEIGHBOURHOOD_BASE_OF_MONO) THEN
  SIMP_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN]);;

lemma locally_connected_space_open_connected_components:
   "        locally_connected_space X \<longleftrightarrow>
        \<forall>u c. openin X u \<and> c \<in> connected_components_of(subtopology X u)
              \<Longrightarrow> openin X c"
oops
  REWRITE_TAC[LOCALLY_CONNECTED_SPACE_EQ_OPEN_CONNECTED_COMPONENT_OF] THEN
  REWRITE_TAC[connected_components_of; IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]);;

lemma openin_connected_component_of_locally_connected_space:
   "locally_connected_space X
             \<Longrightarrow> openin X (connected_component_of X x)"
oops
  METIS_TAC[LOCALLY_CONNECTED_SPACE_EQ_OPEN_CONNECTED_COMPONENT_OF;
            SUBTOPOLOGY_TOPSPACE; OPEN_IN_TOPSPACE;
            OPEN_IN_EMPTY; CONNECTED_COMPONENT_OF_EQ_EMPTY]);;

lemma openin_connected_components_of_locally_connected_space:
   "
        locally_connected_space X \<and> c \<in> connected_components_of X
        \<Longrightarrow> openin X c"
oops
  REWRITE_TAC[LOCALLY_CONNECTED_SPACE_OPEN_CONNECTED_COMPONENTS] THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  EXISTS_TAC `topspace X::A=>bool` THEN
  ASM_REWRITE_TAC[OPEN_IN_TOPSPACE; SUBTOPOLOGY_TOPSPACE]);;

lemma weakly_locally_connected_at:
   "        weakly_locally_connected_at x X \<longleftrightarrow>
        \<forall>v. openin X v \<and> x \<in> v
            \<Longrightarrow> \<exists>u. openin X u \<and>
                    x \<in> u \<and> u \<subseteq> v \<and>
                    \<forall>y. y \<in> u
                        \<Longrightarrow> \<exists>c. connectedin X c \<and>
                                c \<subseteq> v \<and> x \<in> c \<and> y \<in> c"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[neighbourhood_base_at; weakly_locally_connected_at] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC `v::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `v::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `u::A=>bool` THENL [ASM_MESON_TAC[\<subseteq>]; STRIP_TAC] THEN
  EXISTS_TAC `connected_component_of (subtopology X v) (x::A)` THEN
  ASM_REWRITE_TAC[] THEN REPEAT CONJ_TAC THENL
   [MESON_TAC[CONNECTED_IN_CONNECTED_COMPONENT_OF;
              CONNECTED_IN_SUBTOPOLOGY];
    REWRITE_TAC[\<subseteq>] THEN X_GEN_TAC `y::A` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::A`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `c::A=>bool` MP_TAC) THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(SET_RULE `s \<subseteq> t \<Longrightarrow> x \<in> s \<Longrightarrow> x \<in> t`) THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_OF_MAXIMAL THEN
    ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY];
    MESON_TAC[CONNECTED_COMPONENT_OF_SUBSET_TOPSPACE; TOPSPACE_SUBTOPOLOGY;
              SUBSET_INTER]]);;

lemma locally_connected_space_im_kleinen:
   "        locally_connected_space X \<longleftrightarrow>
        \<forall>v x. openin X v \<and> x \<in> v
            \<Longrightarrow> \<exists>u. openin X u \<and>
                    x \<in> u \<and> u \<subseteq> v \<and>
                    \<forall>y. y \<in> u
                        \<Longrightarrow> \<exists>c. connectedin X c \<and>
                                c \<subseteq> v \<and> x \<in> c \<and> y \<in> c"
oops
  REWRITE_TAC[locally_connected_space; neighbourhood_base_of] THEN
  GEN_TAC THEN REWRITE_TAC[GSYM weakly_locally_connected_at] THEN
  REWRITE_TAC[WEAKLY_LOCALLY_CONNECTED_AT] THEN
  REWRITE_TAC[RIGHT_IMP_FORALL_THM; IMP_IMP] THEN
  EQ_TAC THEN REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_MESON_TAC[REWRITE_RULE[\<subseteq>] OPEN_IN_SUBSET]);;

lemma locally_connected_space_open_subset:
   "
        locally_connected_space X \<and> openin X s
        \<Longrightarrow> locally_connected_space (subtopology X s)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[locally_connected_space] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP NEIGHBOURHOOD_BASE_OF_OPEN_SUBSET) THEN
  GEN_REWRITE_TAC LAND_CONV [NEIGHBOURHOOD_BASE_OF_WITH_SUBSET] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] NEIGHBOURHOOD_BASE_OF_MONO) THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY; CONNECTED_IN_SUBTOPOLOGY;
           SUBSET_INTER]);;

lemma locally_connected_space_quotient_map_image:
   "\<And>X X' f::A=>B.
        quotient_map X X' f \<and> locally_connected_space X
        \<Longrightarrow> locally_connected_space X'"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quotient_map] THEN
  REWRITE_TAC[LOCALLY_CONNECTED_SPACE_OPEN_CONNECTED_COMPONENTS] THEN
  STRIP_TAC THEN MAP_EVERY X_GEN_TAC [`v::B=>bool`; `c::B=>bool`] THEN
  STRIP_TAC THEN
  FIRST_ASSUM(fun th -> W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand) th \<circ> snd)) THEN
  ANTS_TAC THENL
   [FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
    ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN ASM SET_TAC[];
    DISCH_THEN(SUBST1_TAC \<circ> SYM)] THEN
  GEN_REWRITE_TAC id [OPEN_IN_SUBOPEN] THEN X_GEN_TAC `x::A` THEN
  REWRITE_TAC[IN_ELIM_THM] THEN STRIP_TAC THEN
  EXISTS_TAC
   `connected_component_of
      (subtopology X {z. z \<in> topspace X \<and> f z \<in> v}) x` THEN
  REPEAT CONJ_TAC THENL
   [FIRST_X_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC `{z. z \<in> topspace X \<and> f z \<in> v}` THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET; connected_components_of] THEN
    REWRITE_TAC[SIMPLE_IMAGE; ETA_AX] THEN MATCH_MP_TAC FUN_IN_IMAGE;
    GEN_REWRITE_TAC id [\<in>] THEN REWRITE_TAC[CONNECTED_COMPONENT_OF_REFL];
    MATCH_MP_TAC(SET_RULE
     `\<forall>v. s \<subseteq> u \<inter> {x. x \<in> u \<and> f x \<in> v} \<and> f ` s \<subseteq> c
          \<Longrightarrow> s \<subseteq> {x. x \<in> u \<and> f x \<in> c}`) THEN
    EXISTS_TAC `v::B=>bool` THEN
    REWRITE_TAC[CONNECTED_COMPONENT_OF_SUBSET_TOPSPACE;
                GSYM TOPSPACE_SUBTOPOLOGY] THEN
    MATCH_MP_TAC CONNECTED_COMPONENTS_OF_MAXIMAL THEN
    EXISTS_TAC `subtopology X' (v::B=>bool)` THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN EXISTS_TAC
       `subtopology X {z. z \<in> topspace X \<and> f z \<in> v}` THEN
      REWRITE_TAC[CONNECTED_IN_CONNECTED_COMPONENT_OF] THEN
      REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
      SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
      MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
      MATCH_MP_TAC QUOTIENT_IMP_CONTINUOUS_MAP THEN
      ASM_REWRITE_TAC[quotient_map];
      REWRITE_TAC[SET_RULE
       `\<not> disjnt t (f ` s) \<longleftrightarrow> \<exists>x. x \<in> s \<and> f x \<in> t`] THEN
      EXISTS_TAC `x::A` THEN ASM_REWRITE_TAC[] THEN
      GEN_REWRITE_TAC id [\<in>] THEN
      REWRITE_TAC[CONNECTED_COMPONENT_OF_REFL]]] THEN
  ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
  ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN ASM SET_TAC[]);;

lemma locally_connected_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> locally_connected_space X
        \<Longrightarrow> locally_connected_space X'"
oops
  MESON_TAC[LOCALLY_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE;
            RETRACTION_IMP_QUOTIENT_MAP]);;

lemma homeomorphic_locally_connected_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (locally_connected_space X \<longleftrightarrow>
             locally_connected_space X')"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic_space] THEN
  REWRITE_TAC[HOMEOMORPHIC_MAPS_MAP; homeomorphic_map] THEN
  MESON_TAC[LOCALLY_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE]);;

lemma locally_connected_space_euclideanreal:
 (`locally_connected_space euclideanreal"
oops
  SIMP_TAC[LOCALLY_PATH_CONNECTED_IMP_LOCALLY_CONNECTED_SPACE;
           LOCALLY_PATH_CONNECTED_SPACE_EUCLIDEANREAL]);;

lemma locally_connected_is_realinterval:
   "is_interval s
       \<Longrightarrow> locally_connected_space(subtopology euclideanreal s)"
oops
  MESON_TAC[LOCALLY_PATH_CONNECTED_IMP_LOCALLY_CONNECTED_SPACE;
            LOCALLY_PATH_CONNECTED_IS_REALINTERVAL]);;

lemma locally_connected_real_interval:
 (`(\<forall>a b. locally_connected_space
           (subtopology euclideanreal(real_interval[a,b]))) \<and>
   (\<forall>a b. locally_connected_space
           (subtopology euclideanreal(real_interval(a,b))))"
oops
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LOCALLY_CONNECTED_IS_REALINTERVAL THEN
  REWRITE_TAC[IS_REALINTERVAL_INTERVAL]);;

lemma locally_connected_space_discrete_topology:
   "\<And>u::A=>bool. locally_connected_space (discrete_topology u)"
oops
  GEN_TAC THEN REWRITE_TAC[LOCALLY_CONNECTED_SPACE] THEN
  SIMP_TAC[OPEN_IN_DISCRETE_TOPOLOGY; CONNECTED_IN_DISCRETE_TOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `x::A`] THEN STRIP_TAC THEN
  EXISTS_TAC `{x::A}` THEN ASM SET_TAC[]);;

lemma locally_path_connected_imp_locally_connected_at:
   "locally_path_connected_at x X \<Longrightarrow> locally_connected_at x X"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[locally_path_connected_at; locally_connected_at] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] NEIGHBOURHOOD_BASE_AT_MONO) THEN
  SIMP_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN]);;

lemma weakly_locally_path_connected_imp_weakly_locally_connected_at:
   "weakly_locally_path_connected_at x X
             \<Longrightarrow> weakly_locally_connected_at x X"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[weakly_locally_path_connected_at;
              weakly_locally_connected_at] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] NEIGHBOURHOOD_BASE_AT_MONO) THEN
  SIMP_TAC[PATH_CONNECTED_IN_IMP_CONNECTED_IN]);;

lemma interior_of_locally_connected_subspace_component:
   "\<And>X s c::A=>bool.
        locally_connected_space X \<and>
        c \<in> connected_components_of (subtopology X s)
        \<Longrightarrow> X interior_of c = c \<inter> X interior_of s"
oops
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN STRIP_TAC THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_SIMP_TAC[SUBSET_INTER; INTERIOR_OF_MONO; INTERIOR_OF_SUBSET] THEN
  MP_TAC(ISPEC `subtopology X (X interior_of s::A=>bool)`
        UNIONS_CONNECTED_COMPONENTS_OF) THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; INTERIOR_OF_SUBSET_TOPSPACE] THEN
  DISCH_THEN(SUBST1_TAC \<circ> SYM) THEN
  REWRITE_TAC[UNIONS_SUBSET; INTER_UNIONS; FORALL_IN_GSPEC] THEN
  X_GEN_TAC `d::A=>bool` THEN DISCH_TAC THEN
  ASM_CASES_TAC `c \<inter> d::A=>bool = {}` THEN
  ASM_REWRITE_TAC[EMPTY_SUBSET] THEN
  MATCH_MP_TAC(SET_RULE `d \<subseteq> e \<Longrightarrow> c \<inter> d \<subseteq> e`) THEN
  MATCH_MP_TAC INTERIOR_OF_MAXIMAL THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONNECTED_COMPONENTS_OF_MAXIMAL THEN
    EXISTS_TAC `subtopology X (s::A=>bool)` THEN
    ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP
      CONNECTED_IN_CONNECTED_COMPONENTS_OF)) THEN
    ASM_SIMP_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN
    ASM_MESON_TAC[SUBSET_TRANS; INTERIOR_OF_SUBSET];
    FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id
     [LOCALLY_CONNECTED_SPACE_OPEN_CONNECTED_COMPONENTS]) THEN
    EXISTS_TAC `X interior_of (s::A=>bool)` THEN
    ASM_REWRITE_TAC[OPEN_IN_INTERIOR_OF]]);;

lemma frontier_of_locally_connected_subspace_component:
   "\<And>X s c::A=>bool.
        locally_connected_space X \<and>
        closedin X s \<and>
        c \<in> connected_components_of (subtopology X s)
        \<Longrightarrow> X frontier_of c = c \<inter> X frontier_of s"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[frontier_of] THEN
  REWRITE_TAC[SET_RULE `s \<inter> (t - u) = s \<inter> t - s \<inter> u`] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_CONNECTED_COMPONENTS_OF) THEN
  ASM_SIMP_TAC[CLOSED_IN_CLOSED_SUBTOPOLOGY] THEN STRIP_TAC THEN
  ASM_SIMP_TAC[CLOSURE_OF_CLOSED_IN] THEN
  ASM_SIMP_TAC[GSYM INTERIOR_OF_LOCALLY_CONNECTED_SUBSPACE_COMPONENT] THEN
  ASM SET_TAC[]);;

lemma locally_connected_space_prod_topology:
   "      locally_connected_space (prod_topology top1 top2) \<longleftrightarrow>
      topspace (prod_topology top1 top2) = {} \<or>
      locally_connected_space top1 \<and> locally_connected_space top2"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THENL
   [ASM_REWRITE_TAC[locally_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>; NOT_IN_EMPTY];
    ALL_TAC] THEN
  ASM_REWRITE_TAC[] THEN RULE_ASSUM_TAC(REWRITE_RULE
   [TOPSPACE_PROD_TOPOLOGY; CROSS_EQ_EMPTY; DE_MORGAN_THM]) THEN
  ASM_REWRITE_TAC[] THEN EQ_TAC THENL
   [DISCH_THEN(fun th -> CONJ_TAC THEN MP_TAC th) THEN
    MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ] (REWRITE_RULE[CONJ_ASSOC]
      LOCALLY_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE))
    THENL [EXISTS_TAC `fst::A#B=>A`; EXISTS_TAC `snd::A#B=>B`] THEN
    ASM_REWRITE_TAC[QUOTIENT_MAP_FST; QUOTIENT_MAP_SND];
    FIRST_X_ASSUM(CONJUNCTS_THEN MP_TAC) THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `z::B` THEN DISCH_TAC THEN X_GEN_TAC `w::A` THEN DISCH_TAC THEN
    REWRITE_TAC[locally_connected_space; FORALL_PAIR_THM; IN_CROSS;
      NEIGHBOURHOOD_BASE_OF; TOPSPACE_PROD_TOPOLOGY] THEN STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`uv::A#B=>bool`; `x::A`; `y::B`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    GEN_REWRITE_TAC LAND_CONV [OPEN_IN_PROD_TOPOLOGY_ALT] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`x::A`; `y::B`]) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`w1::A=>bool`; `w2::B=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`w2::B=>bool`; `y::B`]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`w1::A=>bool`; `x::A`]) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u1::A=>bool`; `k1::A=>bool`] THEN STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`u2::B=>bool`; `k2::B=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `(u1::A=>bool) \<times> (u2::B=>bool)` THEN
    EXISTS_TAC `(k1::A=>bool) \<times> (k2::B=>bool)` THEN
    ASM_SIMP_TAC[OPEN_IN_CROSS; CONNECTED_IN_CROSS;
                IN_CROSS; SUBSET_CROSS] THEN
    TRANS_TAC SUBSET_TRANS `(w1 \<times> w2):A#B=>bool` THEN
    ASM_REWRITE_TAC[] THEN ASM_REWRITE_TAC[SUBSET_CROSS]]);;

lemma locally_connected_space_product_topology:
   "\<And>(tops::K=>A topology) k.
        locally_connected_space(product_topology k tops) \<longleftrightarrow>
        topspace(product_topology k tops) = {} \<or>
        finite {i. i \<in> k \<and> \<not> connected_space(tops i)} \<and>
        \<forall>i. i \<in> k \<Longrightarrow> locally_connected_space(tops i)"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(product_topology k (tops::K=>A topology)) = {}` THENL
   [ASM_REWRITE_TAC[locally_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>; NOT_IN_EMPTY];
    ALL_TAC] THEN
  ASM_REWRITE_TAC[locally_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
  EQ_TAC THENL
   [DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC `z::K=>A`) THEN CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> SPECL
       [`topspace(product_topology k (tops::K=>A topology))`; `z::K=>A`]) THEN
      ASM_REWRITE_TAC[OPEN_IN_TOPSPACE; LEFT_IMP_EXISTS_THM] THEN
      MAP_EVERY X_GEN_TAC [`u:(K=>A)->bool`; `c:(K=>A)->bool`] THEN
      STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC `z::K=>A` \<circ>
        REWRITE_RULE[OPEN_IN_PRODUCT_TOPOLOGY_ALT]) THEN
      ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC `v::K=>A->bool` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        FINITE_SUBSET)) THEN
      REWRITE_TAC[\<subseteq>; IN_ELIM_THM] THEN X_GEN_TAC `i::K` THEN
      ASM_CASES_TAC `(i::K) \<in> k` THEN ASM_REWRITE_TAC[CONTRAPOS_THM] THEN
      DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC \<circ> ISPECL [`\<lambda>x::K=>A. x i`; `(tops::K=>A topology) i`] \<circ>
        MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
            CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION;
                   GSYM CONNECTED_IN_TOPSPACE] THEN
      MATCH_MP_TAC EQ_IMP THEN AP_TERM_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC \<circ>
       MATCH_MP (SET_RULE `v = u \<Longrightarrow> v \<subseteq> s \<and> s \<subseteq> u \<Longrightarrow> s = u`)) THEN
      CONJ_TAC THENL
       [TRANS_TAC SUBSET_TRANS `image (\<lambda>x::K=>A. x i) u` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET] THEN TRANS_TAC SUBSET_TRANS
         `image (\<lambda>x::K=>A. x i) (PiE k v)` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET] THEN
        REWRITE_TAC[IMAGE_PROJECTION_CARTESIAN_PRODUCT] THEN
        COND_CASES_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
        ASM SET_TAC[];
        TRANS_TAC SUBSET_TRANS
          `image (\<lambda>x::K=>A. x i) (topspace(product_topology k tops))` THEN
        ASM_SIMP_TAC[IMAGE_SUBSET; CONNECTED_IN_SUBSET_TOPSPACE] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_PRODUCT_TOPOLOGY]) THEN
        ASM_REWRITE_TAC[IMAGE_PROJECTION_CARTESIAN_PRODUCT;
                        TOPSPACE_PRODUCT_TOPOLOGY] THEN
        REWRITE_TAC[o_THM; SUBSET_REFL]];
      X_GEN_TAC `i::K` THEN DISCH_TAC THEN
      REWRITE_TAC[GSYM locally_connected_space; ETA_AX;
                  GSYM NEIGHBOURHOOD_BASE_OF] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[GSYM locally_connected_space; ETA_AX;
                                  GSYM NEIGHBOURHOOD_BASE_OF]) THEN
      FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ_ALT]
        (REWRITE_RULE[CONJ_ASSOC]
                LOCALLY_CONNECTED_SPACE_QUOTIENT_MAP_IMAGE)))  THEN
      EXISTS_TAC `\<lambda>x::K=>A. x i` THEN
      ASM_SIMP_TAC[OPEN_MAP_PRODUCT_PROJECTION; TOPSPACE_PRODUCT_TOPOLOGY;
                   QUOTIENT_MAP_PRODUCT_PROJECTION;
                   IMAGE_PROJECTION_CARTESIAN_PRODUCT] THEN
      ASM_REWRITE_TAC[GSYM TOPSPACE_PRODUCT_TOPOLOGY; o_THM]];
    STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`ww:(K=>A)->bool`; `z::K=>A`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    GEN_REWRITE_TAC LAND_CONV [OPEN_IN_PRODUCT_TOPOLOGY_ALT] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `z::K=>A`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `w::K=>A->bool` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN
     `\<forall>i. i \<in> k
          \<Longrightarrow> \<exists>u c. openin (tops i) u \<and>
                    connectedin (tops i) c \<and>
                    ((z::K=>A) i) \<in> u \<and>
                    u \<subseteq> c \<and>
                    c \<subseteq> w i \<and>
                    (w i = topspace(tops i) \<and> connected_space(tops i)
                     \<Longrightarrow> u = topspace(tops i) \<and> c = topspace(tops i))`
    MP_TAC THENL
     [X_GEN_TAC `i::K` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`i::K`; `(w::K=>A->bool) i`] \<circ>
        GEN_REWRITE_RULE BINDER_CONV [RIGHT_IMP_FORALL_THM]) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `(z::K=>A) i`) THEN
      ANTS_TAC THENL
       [FIRST_X_ASSUM(MP_TAC \<circ>
         GEN_REWRITE_RULE RAND_CONV [PiE]) THEN
        ASM_SIMP_TAC[IN_ELIM_THM];
        ASM_CASES_TAC `connected_space((tops::K=>A topology) i)` THEN
        ASM_REWRITE_TAC[] THEN
        ASM_CASES_TAC `(w::K=>A->bool) i = topspace(tops i)` THEN
        ASM_REWRITE_TAC[] THEN DISCH_THEN(K ALL_TAC) THEN
        REPEAT(EXISTS_TAC `topspace((tops::K=>A topology) i)`) THEN
        ASM_REWRITE_TAC[CONNECTED_IN_TOPSPACE; SUBSET_REFL] THEN
        REWRITE_TAC[OPEN_IN_TOPSPACE] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM]) THEN
        ASM SET_TAC[]];
      GEN_REWRITE_TAC (LAND_CONV \<circ> TOP_DEPTH_CONV) [RIGHT_IMP_EXISTS_THM] THEN
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [`u::K=>A->bool`; `c::K=>A->bool`] THEN DISCH_TAC THEN
    MAP_EVERY EXISTS_TAC
     [`PiE k (u::K=>A->bool)`;
      `PiE k (c::K=>A->bool)`] THEN
    ASM_SIMP_TAC[CONNECTED_IN_CARTESIAN_PRODUCT] THEN
    ASM_SIMP_TAC[SUBSET_CARTESIAN_PRODUCT] THEN
    REWRITE_TAC[OPEN_IN_CARTESIAN_PRODUCT_GEN] THEN REPEAT CONJ_TAC THENL
     [DISJ2_TAC THEN ASM_SIMP_TAC[] THEN MATCH_MP_TAC FINITE_SUBSET THEN
      EXISTS_TAC `{i. i \<in> k \<and> \<not> connected_space (tops i)} \<union>
                  {i. i \<in> k \<and> \<not> ((w::K=>A->bool) i = topspace (tops i))}` THEN
      ASM_REWRITE_TAC[FINITE_UNION] THEN ASM SET_TAC[];
      UNDISCH_TAC `(z::K=>A) \<in> PiE k w` THEN
      REWRITE_TAC[PiE; IN_ELIM_THM] THEN ASM SET_TAC[];
      TRANS_TAC SUBSET_TRANS `PiE k (w::K=>A->bool)` THEN
      ASM_REWRITE_TAC[] THEN REWRITE_TAC[SUBSET_CARTESIAN_PRODUCT] THEN
      ASM SET_TAC[]]]);;

lemma locally_connected_space_sum_topology:
   "\<And>k (X::K=>A topology).
        locally_connected_space(sum_topology k X) \<longleftrightarrow>
        \<forall>i. i \<in> k \<Longrightarrow> locally_connected_space(X i)"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MATCH_MP_TAC TOPOLOGICAL_PROPERTY_OF_SUM_COMPONENT THEN
    REWRITE_TAC[HOMEOMORPHIC_LOCALLY_CONNECTED_SPACE] THEN
    SIMP_TAC[LOCALLY_CONNECTED_SPACE_OPEN_SUBSET];
    REWRITE_TAC[locally_connected_space; NEIGHBOURHOOD_BASE_OF] THEN
    REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[FORALL_OPEN_IN_SUM_TOPOLOGY] THEN
    DISCH_TAC THEN X_GEN_TAC `w::K=>A->bool` THEN DISCH_TAC THEN
    REWRITE_TAC[FORALL_PAIR_THM; Sigma; IN_ELIM_PAIR_THM] THEN
    MAP_EVERY X_GEN_TAC [`i::K`; `x::A`] THEN STRIP_TAC THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `i::K`)) THEN
    ASM_REWRITE_TAC[] THEN REPEAT DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(w::K=>A->bool) i`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
    EXISTS_TAC `image (\<lambda>x. (i::K),(x::A)) u` THEN
    EXISTS_TAC `image (\<lambda>x. (i::K),(x::A)) v` THEN
    ASM_SIMP_TAC[IMAGE_SUBSET] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_PAIR_THM] THEN
    ASM_REWRITE_TAC[GSYM \<subseteq>] THEN REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC(REWRITE_RULE[open_map; RIGHT_IMP_FORALL_THM; IMP_IMP]
        OPEN_MAP_COMPONENT_INJECTION) THEN
      ASM_REWRITE_TAC[];
      MATCH_MP_TAC CONNECTED_IN_CONTINUOUS_MAP_IMAGE THEN
      EXISTS_TAC `(X::K=>A topology) i` THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_COMPONENT_INJECTION];
      ASM SET_TAC[]]]);;


subsection\<open>Quasi-components\<close>


let quasi_component_of = new_definition
 `quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<forall>t. closedin X t \<and> openin X t \<Longrightarrow> (x \<in> t \<longleftrightarrow> y \<in> t)`;;

let quasi_components_of = new_definition
 `quasi_components_of X =
    {quasi_component_of X x |x| x \<in> topspace X}`;;

lemma quasi_component_in_topspace:
   "        quasi_component_of X x y
        \<Longrightarrow> x \<in> topspace X \<and> y \<in> topspace X"
oops
  REWRITE_TAC[quasi_component_of] THEN MESON_TAC[]);;

lemma quasi_component_of_refl:
   "quasi_component_of X x x \<longleftrightarrow> x \<in> topspace X"
oops
  REWRITE_TAC[quasi_component_of] THEN MESON_TAC[]);;

lemma quasi_component_of_sym:
   "    quasi_component_of X x y \<longleftrightarrow> quasi_component_of X y x"
oops
  REWRITE_TAC[quasi_component_of] THEN MESON_TAC[]);;

lemma quasi_component_of_trans:
   "        quasi_component_of X x y \<and> quasi_component_of X y z
        \<Longrightarrow> quasi_component_of X x z"
oops
  REWRITE_TAC[quasi_component_of] THEN MESON_TAC[]);;

lemma quasi_component_of_subset_topspace:
   "(quasi_component_of X x) \<subseteq> topspace X"
oops
  REWRITE_TAC[\<subseteq>; \<in>] THEN MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE; \<in>]);;

lemma quasi_component_of_eq_empty:
   "quasi_component_of X x = {} \<longleftrightarrow> (x \<notin> topspace X)"
oops
  REWRITE_TAC[EXTENSION; NOT_IN_EMPTY] THEN
  MESON_TAC[\<in>; QUASI_COMPONENT_OF_REFL; QUASI_COMPONENT_IN_TOPSPACE]);;

lemma quasi_component_of:
   "        quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<forall>t. x \<in> t \<and> closedin X t \<and> openin X t \<Longrightarrow> y \<in> t"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quasi_component_of] THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THENL
   [ASM_MESON_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `s::A=>bool` THEN STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC[] THEN
  GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN REPEAT DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `topspace X - s::A=>bool`) THEN
  ASM_REWRITE_TAC[IN_DIFF] THEN
  ASM_MESON_TAC[OPEN_IN_CLOSED_IN_EQ; closedin]);;

lemma quasi_component_of_alt:
   "        quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<not> (\<exists>u v. openin X u \<and> openin X v \<and>
                u \<union> v = topspace X \<and>
                disjnt u v \<and> x \<in> u \<and> y \<in> v)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[QUASI_COMPONENT_OF] THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC `(y::A) \<in> topspace X` THEN ASM_REWRITE_TAC[] THEN
  ASM_REWRITE_TAC[SET_RULE
   `u \<union> v = s \<and> disjnt u v \<and> x \<in> u \<and> y \<in> v \<longleftrightarrow>
    u \<subseteq> s \<and> v = s - u \<and> x \<in> u \<and> y \<in> s \<and> (y \<notin> u)`] THEN
  ONCE_REWRITE_TAC[TAUT `p \<and> q \<and> r \<and> s \<and> t \<longleftrightarrow> s \<and> p \<and> q \<and> r \<and> t`] THEN
  REWRITE_TAC[UNWIND_THM2; closedin] THEN SET_TAC[]);;

lemma quasi_component_of_set:
   "        quasi_component_of X x =
        if x \<in> topspace X
        then \<Inter> {t. closedin X t \<and> openin X t \<and> x \<in> t}
        else {}"
oops
  REPEAT GEN_TAC THEN GEN_REWRITE_TAC id [EXTENSION] THEN X_GEN_TAC `y::A` THEN
  GEN_REWRITE_TAC LAND_CONV [\<in>] THEN REWRITE_TAC[QUASI_COMPONENT_OF] THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THEN
  ASM_REWRITE_TAC[IN_INTERS; NOT_IN_EMPTY; IN_ELIM_THM] THEN
  ASM_MESON_TAC[OPEN_IN_TOPSPACE; CLOSED_IN_TOPSPACE]);;

lemma quasi_component_of_separated:
   "        quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<not> (\<exists>u v. separatedin X u v \<and> u \<union> v = topspace X \<and>
                x \<in> u \<and> y \<in> v)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[QUASI_COMPONENT_OF_ALT] THEN
  MESON_TAC[SEPARATED_IN_OPEN_SETS; SEPARATED_IN_FULL]);;

lemma quasi_component_of_subtopology:
   "        quasi_component_of (subtopology X s) x y
        \<Longrightarrow> quasi_component_of X x y"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quasi_component_of] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN X_GEN_TAC `t::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `s \<inter> t::A=>bool`) THEN
  ASM_REWRITE_TAC[IN_INTER] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN] THEN
  ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED]);;

lemma quasi_component_of_mono:
   "        quasi_component_of (subtopology X s) x y \<and> s \<subseteq> t
        \<Longrightarrow> quasi_component_of (subtopology X t) x y"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[IMP_CONJ_ALT] THEN DISCH_THEN(SUBST1_TAC \<circ>
   MATCH_MP (SET_RULE `s \<subseteq> t \<Longrightarrow> s = t \<inter> s`)) THEN
  REWRITE_TAC[GSYM SUBTOPOLOGY_SUBTOPOLOGY] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF_SUBTOPOLOGY]);;

lemma quasi_component_of_equiv:
   "        quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        quasi_component_of X x = quasi_component_of X y"
oops
  REWRITE_TAC[FUN_EQ_THM] THEN
  MESON_TAC[QUASI_COMPONENT_OF_REFL; QUASI_COMPONENT_OF_TRANS;
            QUASI_COMPONENT_OF_SYM]);;

lemma quasi_component_of_disjoint:
   "        disjnt (quasi_component_of X x)
                 (quasi_component_of X y) \<longleftrightarrow>
        \<not> (quasi_component_of X x y)"
oops
  REWRITE_TAC[disjnt; EXTENSION; IN_INTER; NOT_IN_EMPTY] THEN
  REWRITE_TAC[\<in>] THEN
  MESON_TAC[QUASI_COMPONENT_OF_SYM; QUASI_COMPONENT_OF_TRANS]);;

lemma quasi_component_of_eq:
   "        quasi_component_of X x = quasi_component_of X y \<longleftrightarrow>
        (x \<notin> topspace X) \<and> (y \<notin> topspace X) \<or>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        quasi_component_of X x y"
oops
  MESON_TAC[QUASI_COMPONENT_OF_REFL; QUASI_COMPONENT_OF_EQUIV;
            QUASI_COMPONENT_OF_EQ_EMPTY]);;

lemma unions_quasi_components_of:
   "\<Union> (quasi_components_of X) = topspace X"
oops
  GEN_TAC THEN REWRITE_TAC[quasi_components_of] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[UNIONS_SUBSET; FORALL_IN_GSPEC;
              QUASI_COMPONENT_OF_SUBSET_TOPSPACE] THEN
  REWRITE_TAC[\<subseteq>; UNIONS_GSPEC; IN_ELIM_THM] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN EXISTS_TAC `x::A` THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[\<in>] THEN
  ASM_REWRITE_TAC[QUASI_COMPONENT_OF_REFL]);;

lemma pairwise_disjoint_quasi_components_of:
   "pairwise disjnt (quasi_components_of X)"
oops
  SIMP_TAC[pairwise; IMP_CONJ; quasi_components_of;
           RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC[QUASI_COMPONENT_OF_EQ; QUASI_COMPONENT_OF_DISJOINT]);;

lemma complement_quasi_components_of_unions:
   "
      c \<in> quasi_components_of X
      \<Longrightarrow> topspace X - c = \<Union> (quasi_components_of X - {c})"
oops
  REWRITE_TAC[SET_RULE `s - {a} = s - {a}`] THEN
  ASM_SIMP_TAC[GSYM DIFF_UNIONS_PAIRWISE_DISJOINT;
               PAIRWISE_DISJOINT_QUASI_COMPONENTS_OF; SING_SUBSET] THEN
  REWRITE_TAC[UNIONS_QUASI_COMPONENTS_OF; UNIONS_1]);;

lemma nonempty_quasi_components_of:
   " c \<in> quasi_components_of X \<Longrightarrow> (c \<noteq> {})"
oops
  SIMP_TAC[quasi_components_of; FORALL_IN_GSPEC;
           QUASI_COMPONENT_OF_EQ_EMPTY]);;

lemma quasi_components_of_subset:
   " c \<in> quasi_components_of X \<Longrightarrow> c \<subseteq> topspace X"
oops
  SIMP_TAC[quasi_components_of; FORALL_IN_GSPEC;
           QUASI_COMPONENT_OF_SUBSET_TOPSPACE]);;

lemma quasi_component_in_quasi_components_of:
   "        quasi_component_of X a \<in> quasi_components_of X \<longleftrightarrow>
        a \<in> topspace X"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
    SIMP_TAC[GSYM QUASI_COMPONENT_OF_EQ_EMPTY] THEN
    MESON_TAC[NONEMPTY_QUASI_COMPONENTS_OF];
    REWRITE_TAC[quasi_components_of] THEN SET_TAC[]]);;

lemma quasi_components_of_eq_empty:
   "quasi_components_of X = {} \<longleftrightarrow> topspace X = {}"
oops
  REWRITE_TAC[quasi_components_of] THEN SET_TAC[]);;

lemma quasi_components_of_empty_space:
   "topspace X = {} \<Longrightarrow> quasi_components_of X = {}"
oops
  REWRITE_TAC[QUASI_COMPONENTS_OF_EQ_EMPTY]);;

lemma closedin_quasi_component_of:
   "closedin X (quasi_component_of X x)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[QUASI_COMPONENT_OF_SET] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[CLOSED_IN_EMPTY] THEN
  MATCH_MP_TAC CLOSED_IN_INTERS THEN
  SIMP_TAC[IN_ELIM_THM; GSYM MEMBER_NOT_EMPTY] THEN
  EXISTS_TAC `topspace X::A=>bool` THEN
  ASM_REWRITE_TAC[OPEN_IN_TOPSPACE; CLOSED_IN_TOPSPACE]);;

lemma closedin_quasi_components_of:
   "
        c \<in> quasi_components_of X \<Longrightarrow> closedin X c"
oops
  REWRITE_TAC[quasi_components_of; FORALL_IN_GSPEC] THEN
  REWRITE_TAC[CLOSED_IN_QUASI_COMPONENT_OF]);;

lemma openin_finite_quasi_components:
   "
        finite(quasi_components_of X) \<and>
        c \<in> quasi_components_of X
        \<Longrightarrow> openin X c"
oops
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC[OPEN_IN_CLOSED_IN_EQ; QUASI_COMPONENTS_OF_SUBSET] THEN
  ASM_SIMP_TAC[COMPLEMENT_QUASI_COMPONENTS_OF_UNIONS] THEN
  MATCH_MP_TAC CLOSED_IN_UNIONS THEN
  ASM_SIMP_TAC[FINITE_DELETE; IN_DELETE; CLOSED_IN_QUASI_COMPONENTS_OF]);;

lemma quasi_component_of_eq_overlap:
   "      quasi_component_of X x = quasi_component_of X y \<longleftrightarrow>
      (x \<notin> topspace X) \<and> (y \<notin> topspace X) \<or>
      \<not> (quasi_component_of X x \<inter> quasi_component_of X y = {})"
oops
  REWRITE_TAC[GSYM disjnt; QUASI_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF_EQ] THEN
  MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE]);;

lemma quasi_component_of_nonoverlap:
   "     quasi_component_of X x \<inter> quasi_component_of X y = {} \<longleftrightarrow>
     (x \<notin> topspace X) \<or> (y \<notin> topspace X) \<or>
     \<not> (quasi_component_of X x = quasi_component_of X y)"
oops
  REWRITE_TAC[GSYM disjnt; QUASI_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF_EQ] THEN
  MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE]);;

lemma quasi_component_of_overlap:
   "    \<not> (quasi_component_of X x \<inter> quasi_component_of X y = {}) \<longleftrightarrow>
    x \<in> topspace X \<and> y \<in> topspace X \<and>
    quasi_component_of X x = quasi_component_of X y"
oops
  REWRITE_TAC[GSYM disjnt; QUASI_COMPONENT_OF_DISJOINT] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF_EQ] THEN
  MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE]);;

lemma quasi_components_of_disjoint:
   "\<And>X c c'.
        c \<in> quasi_components_of X \<and> c' \<in> quasi_components_of X
        \<Longrightarrow> (disjnt c c' \<longleftrightarrow> (c \<noteq> c'))"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; quasi_components_of] THEN
  SIMP_TAC[FORALL_IN_GSPEC; disjnt; QUASI_COMPONENT_OF_NONOVERLAP]);;

lemma quasi_components_of_overlap:
   "\<And>X c c'.
        c \<in> quasi_components_of X \<and> c' \<in> quasi_components_of X
        \<Longrightarrow> (\<not> (c \<inter> c' = {}) \<longleftrightarrow> c = c')"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; quasi_components_of] THEN
  SIMP_TAC[FORALL_IN_GSPEC; disjnt; QUASI_COMPONENT_OF_NONOVERLAP]);;

lemma pairwise_separated_quasi_components_of:
   "        pairwise (separatedin X) (quasi_components_of X)"
oops
  REWRITE_TAC[pairwise] THEN
  SIMP_TAC[CLOSED_IN_QUASI_COMPONENTS_OF; SEPARATED_IN_CLOSED_SETS] THEN
  REWRITE_TAC[GSYM pairwise; PAIRWISE_DISJOINT_QUASI_COMPONENTS_OF]);;

lemma card_le_quasi_components_of_topspace:
   "quasi_components_of X \<lesssim> topspace X"
oops
  GEN_TAC THEN MATCH_MP_TAC CARD_LE_RELATIONAL_FULL THEN
  EXISTS_TAC `(\<in>):A->(A=>bool)->bool` THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP QUASI_COMPONENTS_OF_SUBSET) THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP NONEMPTY_QUASI_COMPONENTS_OF) THEN
    SET_TAC[];
    MESON_TAC[REWRITE_RULE[GSYM MEMBER_NOT_EMPTY; IN_INTER]
                QUASI_COMPONENTS_OF_OVERLAP]]);;

lemma finite_quasi_components_of_finite:
   "        finite(topspace X) \<Longrightarrow> finite(quasi_components_of X)"
oops
  GEN_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CARD_LE_FINITE) THEN
  REWRITE_TAC[CARD_LE_QUASI_COMPONENTS_OF_TOPSPACE]);;

lemma connected_imp_quasi_component_of:
   "connected_component_of X x y \<Longrightarrow> quasi_component_of X x y"
oops
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(STRIP_ASSUME_TAC \<circ> MATCH_MP CONNECTED_COMPONENT_IN_TOPSPACE) THEN
  ASM_REWRITE_TAC[QUASI_COMPONENT_OF] THEN
  X_GEN_TAC `t::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [connected_component_of]) THEN
  DISCH_THEN(X_CHOOSE_THEN `c::A=>bool` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`; `t::A=>bool`]
        CONNECTED_IN_CLOPEN_CASES) THEN
  ASM_REWRITE_TAC[] THEN ASM SET_TAC[]);;

lemma connected_component_subset_quasi_component_of:
   "connected_component_of X x \<subseteq> quasi_component_of X x"
oops
  REWRITE_TAC[\<subseteq>; \<in>; CONNECTED_IMP_QUASI_COMPONENT_OF]);;

lemma quasi_component_as_connected_component_unions:
   "        quasi_component_of X x =
        \<Union> {connected_component_of X y |y| quasi_component_of X x y}"
oops
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[UNIONS_SUBSET; FORALL_IN_GSPEC] THEN CONJ_TAC THENL
   [GEN_REWRITE_TAC id [\<subseteq>] THEN X_GEN_TAC `y::A` THEN
    REWRITE_TAC[UNIONS_GSPEC; IN_ELIM_THM] THEN
    REWRITE_TAC[\<in>] THEN DISCH_TAC THEN EXISTS_TAC `y::A` THEN
    ASM_MESON_TAC[CONNECTED_COMPONENT_OF_REFL; QUASI_COMPONENT_IN_TOPSPACE];
    X_GEN_TAC `y::A` THEN SIMP_TAC[QUASI_COMPONENT_OF_EQUIV] THEN
    REWRITE_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF]]);;

lemma quasi_components_as_connected_components_unions:
   "
        c \<in> quasi_components_of X
        \<Longrightarrow> \<exists>t. t \<subseteq> connected_components_of X \<and> \<Union> t = c"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quasi_components_of; IN_ELIM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN `x::A` (CONJUNCTS_THEN2 ASSUME_TAC SUBST1_TAC)) THEN
  EXISTS_TAC
   `{connected_component_of X (y::A) |y| quasi_component_of X x y}` THEN
  REWRITE_TAC[GSYM QUASI_COMPONENT_AS_CONNECTED_COMPONENT_UNIONS] THEN
  REWRITE_TAC[\<subseteq>; connected_components_of; FORALL_IN_GSPEC] THEN
  X_GEN_TAC `y::A` THEN DISCH_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
  ASM_MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE]);;

lemma path_imp_quasi_component_of:
   "path_component_of X x y \<Longrightarrow> quasi_component_of X x y"
oops
  MESON_TAC[CONNECTED_IMP_QUASI_COMPONENT_OF;
            PATH_IMP_CONNECTED_COMPONENT_OF]);;

lemma path_component_subset_quasi_component_of:
   "path_component_of X x \<subseteq> quasi_component_of X x"
oops
  REWRITE_TAC[\<subseteq>; \<in>; PATH_IMP_QUASI_COMPONENT_OF]);;

lemma connected_space_iff_quasi_component:
   "        connected_space X \<longleftrightarrow>
        \<forall>x y. x \<in> topspace X \<and> y \<in> topspace X
              \<Longrightarrow> quasi_component_of X x y"
oops
  GEN_TAC THEN REWRITE_TAC[CONNECTED_SPACE_CLOPEN_IN] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF] THEN
  REWRITE_TAC[closedin] THEN SET_TAC[]);;

lemma connected_space_imp_quasi_component_of:
   "        connected_space X \<and> a \<in> topspace X \<and> b \<in> topspace X
        \<Longrightarrow> quasi_component_of X a b"
oops
  MESON_TAC[CONNECTED_SPACE_IFF_QUASI_COMPONENT]);;

lemma connected_space_quasi_component_set:
   "connected_space X \<longleftrightarrow>
         \<forall>x::A. x \<in> topspace X
               \<Longrightarrow> quasi_component_of X x = topspace X"
oops
  REWRITE_TAC[CONNECTED_SPACE_IFF_QUASI_COMPONENT;
              GSYM SUBSET_ANTISYM_EQ] THEN
  REWRITE_TAC[QUASI_COMPONENT_OF_SUBSET_TOPSPACE] THEN SET_TAC[]);;

lemma connected_space_iff_quasi_components_eq:
   "        connected_space X \<longleftrightarrow>
        !c c'. c \<in> quasi_components_of X \<and>
               c' \<in> quasi_components_of X
               \<Longrightarrow> c = c'"
oops
  REWRITE_TAC[quasi_components_of; IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_IN_GSPEC; CONNECTED_SPACE_IFF_QUASI_COMPONENT] THEN
  SIMP_TAC[QUASI_COMPONENT_OF_EQ] THEN MESON_TAC[]);;

lemma quasi_components_of_subset_sing:
   "
        quasi_components_of X \<subseteq> {s} \<longleftrightarrow>
        connected_space X \<and> (topspace X = {} \<or> topspace X = s)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[CONNECTED_SPACE_IFF_QUASI_COMPONENTS_EQ; SET_RULE
   `(\<forall>x y. x \<in> s \<and> y \<in> s \<Longrightarrow> x = y) \<longleftrightarrow> s = {} \<or> \<exists>a. s = {a}`] THEN
  ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[QUASI_COMPONENTS_OF_EMPTY_SPACE; EMPTY_SUBSET] THEN
  ASM_REWRITE_TAC[QUASI_COMPONENTS_OF_EQ_EMPTY; SET_RULE
   `s \<subseteq> {a} \<longleftrightarrow> s = {} \<or> s = {a}`] THEN
  MESON_TAC[UNIONS_QUASI_COMPONENTS_OF; UNIONS_1]);;

lemma connected_space_iff_quasi_components_subset_sing:
   "        connected_space X \<longleftrightarrow> \<exists>a. quasi_components_of X \<subseteq> {a}"
oops
  MESON_TAC[QUASI_COMPONENTS_OF_SUBSET_SING]);;

lemma quasi_components_of_eq_sing:
   "
        quasi_components_of X = {s} \<longleftrightarrow>
        connected_space X \<and> \<not> (topspace X = {}) \<and> s = topspace X"
oops
  REWRITE_TAC[QUASI_COMPONENTS_OF_SUBSET_SING;
              QUASI_COMPONENTS_OF_EQ_EMPTY;
              SET_RULE `s = {a} \<longleftrightarrow> s \<subseteq> {a} \<and> (s \<noteq> {})`] THEN
  MESON_TAC[]);;

lemma quasi_components_of_connected_space:
   "        connected_space X
        \<Longrightarrow> quasi_components_of X =
            if topspace X = {} then {} else {topspace X}"
oops
  ASM_MESON_TAC[QUASI_COMPONENTS_OF_EMPTY_SPACE;
                QUASI_COMPONENTS_OF_EQ_SING]);;

lemma separated_between_sings:
   "        separated_between X {x} {y} \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<not> (quasi_component_of X x y)"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THENL
   [ALL_TAC; ASM_MESON_TAC[SEPARATED_BETWEEN_IMP_SUBSET; SING_SUBSET]] THEN
  ASM_CASES_TAC `(y::A) \<in> topspace X` THENL
   [ALL_TAC; ASM_MESON_TAC[SEPARATED_BETWEEN_IMP_SUBSET; SING_SUBSET]] THEN
  ASM_REWRITE_TAC[separated_between; QUASI_COMPONENT_OF_ALT; SING_SUBSET]);;

lemma quasi_component_nonseparated:
   "        quasi_component_of X x y \<longleftrightarrow>
        x \<in> topspace X \<and> y \<in> topspace X \<and>
        \<not> (separated_between X {x} {y})"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[SEPARATED_BETWEEN_SINGS] THEN
  MESON_TAC[QUASI_COMPONENT_IN_TOPSPACE]);;

lemma separated_between_quasi_component_pointwise_left:
   "\<And>X c s::A=>bool.
        c \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X c s \<longleftrightarrow>
             \<exists>x. x \<in> c \<and> separated_between X {x} s)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_MESON_TAC[NONEMPTY_QUASI_COMPONENTS_OF; SING_SUBSET; MEMBER_NOT_EMPTY;
                  SEPARATED_BETWEEN_MONO; SUBSET_REFL];
    DISCH_THEN(X_CHOOSE_THEN `y::A` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC))] THEN
  REWRITE_TAC[SEPARATED_BETWEEN; SING_SUBSET] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `u::A=>bool` THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [quasi_components_of]) THEN
  REWRITE_TAC[IN_ELIM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN `x::A` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `(y::A) \<in> c` THEN ASM_REWRITE_TAC[] THEN
  GEN_REWRITE_TAC LAND_CONV [\<in>] THEN REWRITE_TAC[quasi_component_of] THEN
  DISCH_TAC THEN REWRITE_TAC[\<subseteq>] THEN X_GEN_TAC `z::A` THEN
  GEN_REWRITE_TAC LAND_CONV [\<in>] THEN REWRITE_TAC[quasi_component_of] THEN
  ASM_MESON_TAC[]);;

lemma separated_between_quasi_component_pointwise_right:
   "\<And>X s c::A=>bool.
        c \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X s c \<longleftrightarrow>
             \<exists>x. x \<in> c \<and> separated_between X s {x})"
oops
  ONCE_REWRITE_TAC[SEPARATED_BETWEEN_SYM] THEN
  REWRITE_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_POINTWISE_LEFT]);;

lemma separated_between_quasi_component_point:
   "        c \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X c {x} \<longleftrightarrow> x \<in> topspace X - c)"
oops
  REWRITE_TAC[IN_DIFF] THEN REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_MESON_TAC[SEPARATED_BETWEEN_IMP_DISJOINT; DISJOINT_SING;
                  SEPARATED_BETWEEN_IMP_SUBSET; SING_SUBSET];
    ASM_SIMP_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_POINTWISE_LEFT]] THEN
  REWRITE_TAC[SEPARATED_BETWEEN_SINGS; RIGHT_IMP_EXISTS_THM] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [quasi_components_of]) THEN
  REWRITE_TAC[IN_ELIM_THM] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `y::A` THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC SUBST1_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[\<in>] THEN ASM_REWRITE_TAC[quasi_component_of]);;

lemma separated_between_point_quasi_component:
   "\<And>X (x::A) c.
        c \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X {x} c \<longleftrightarrow> x \<in> topspace X - c)"
oops
  ONCE_REWRITE_TAC[SEPARATED_BETWEEN_SYM] THEN
  REWRITE_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_POINT]);;

lemma separated_between_quasi_component_compact:
   "\<And>X c k::A=>bool.
        c \<in> quasi_components_of X \<and> compactin X k
        \<Longrightarrow> (separated_between X c k \<longleftrightarrow> disjnt c k)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  REWRITE_TAC[SEPARATED_BETWEEN_IMP_DISJOINT] THEN
  DISCH_TAC THEN ASM_SIMP_TAC[SEPARATED_BETWEEN_POINTWISE_RIGHT] THEN
  ASM_SIMP_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_POINT] THEN
  FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
  FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP QUASI_COMPONENTS_OF_SUBSET) THEN
  ASM SET_TAC[]);;

lemma separated_between_compact_quasi_component:
   "\<And>X k c::A=>bool.
        compactin X k \<and> c \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X k c \<longleftrightarrow> disjnt k c)"
oops
  ONCE_REWRITE_TAC[SEPARATED_BETWEEN_SYM; DISJOINT_SYM] THEN
  SIMP_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_COMPACT]);;

lemma separated_between_quasi_components:
   "\<And>X c c':A=>bool.
        c \<in> quasi_components_of X \<and> c' \<in> quasi_components_of X
        \<Longrightarrow> (separated_between X c c' \<longleftrightarrow> disjnt c c')"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  REWRITE_TAC[SEPARATED_BETWEEN_IMP_DISJOINT] THEN DISCH_TAC THEN
  ASM_SIMP_TAC[SEPARATED_BETWEEN_QUASI_COMPONENT_POINTWISE_RIGHT;
               SEPARATED_BETWEEN_QUASI_COMPONENT_POINTWISE_LEFT] THEN
  UNDISCH_TAC `(c::A=>bool) \<in> quasi_components_of X` THEN
  REWRITE_TAC[quasi_components_of; IN_ELIM_THM] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `x::A` THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC SUBST_ALL_TAC) THEN
  CONJ_TAC THENL [ASM_MESON_TAC[QUASI_COMPONENT_OF_REFL; \<in>]; ALL_TAC] THEN
  UNDISCH_TAC `(c':A=>bool) \<in> quasi_components_of X` THEN
  REWRITE_TAC[quasi_components_of; IN_ELIM_THM] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `y::A` THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC SUBST_ALL_TAC) THEN
  CONJ_TAC THENL [ASM_MESON_TAC[QUASI_COMPONENT_OF_REFL; \<in>]; ALL_TAC] THEN
  ASM_REWRITE_TAC[SEPARATED_BETWEEN_SINGS] THEN
  ASM_REWRITE_TAC[GSYM QUASI_COMPONENT_OF_DISJOINT]);;

lemma quasi_eq_connected_component_of_eq:
   "quasi_component_of X x = connected_component_of X x \<longleftrightarrow>
             connectedin X (quasi_component_of X x)"
oops
  REPEAT STRIP_TAC THEN ASM_CASES_TAC `(x::A) \<in> topspace X` THENL
   [ALL_TAC;
    ASM_MESON_TAC[QUASI_COMPONENT_OF_EQ_EMPTY; CONNECTED_COMPONENT_OF_EQ_EMPTY;
                  CONNECTED_IN_EMPTY]] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[CONNECTED_IN_CONNECTED_COMPONENT_OF];
    DISCH_TAC] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_OF_MAXIMAL THEN
  ASM_REWRITE_TAC[\<in>] THEN
  ASM_REWRITE_TAC[QUASI_COMPONENT_OF_REFL]);;

lemma connected_quasi_component_of:
   "
        c \<in> quasi_components_of X
        \<Longrightarrow> (c \<in> connected_components_of X \<longleftrightarrow> connectedin X c)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  REWRITE_TAC[CONNECTED_IN_CONNECTED_COMPONENTS_OF] THEN
  DISCH_TAC THEN
  UNDISCH_TAC `(c::A=>bool) \<in> quasi_components_of X` THEN
  REWRITE_TAC[quasi_components_of; connected_components_of] THEN
  REWRITE_TAC[IN_ELIM_THM] THEN MATCH_MP_TAC MONO_EXISTS THEN
  ASM_MESON_TAC[QUASI_EQ_CONNECTED_COMPONENT_OF_EQ]);;

lemma quasi_component_of_clopen_cases:
   "\<And>X c t::A=>bool.
        c \<in> quasi_components_of X \<and> closedin X t \<and> openin X t
        \<Longrightarrow> c \<subseteq> t \<or> disjnt c t"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[IMP_CONJ; quasi_components_of; IN_ELIM_THM; LEFT_IMP_EXISTS_THM;
              SET_RULE `c = s \<longleftrightarrow> \<forall>x. x \<in> c \<longleftrightarrow> s x`] THEN
  REWRITE_TAC[quasi_component_of] THEN
  REWRITE_TAC[closedin] THEN SET_TAC[]);;

lemma quasi_components_of_set:
   "
        c \<in> quasi_components_of X
        \<Longrightarrow> \<Inter> {t. closedin X t \<and> openin X t \<and> c \<subseteq> t} = c"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC[SUBSET_INTERS; FORALL_IN_GSPEC] THEN
  GEN_REWRITE_TAC id [\<subseteq>] THEN X_GEN_TAC `x::A` THEN
  REWRITE_TAC[INTERS_GSPEC; IN_ELIM_THM] THEN
  ONCE_REWRITE_TAC[TAUT `p \<Longrightarrow> q \<longleftrightarrow> p \<Longrightarrow> \<not> q \<Longrightarrow> \<not> p`] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `topspace X::A=>bool`) THEN
  ASM_SIMP_TAC[QUASI_COMPONENTS_OF_SUBSET] THEN
  REWRITE_TAC[OPEN_IN_TOPSPACE; CLOSED_IN_TOPSPACE] THEN
  REWRITE_TAC[GSYM IN_DIFF; IMP_IMP] THEN
  ASM_SIMP_TAC[GSYM SEPARATED_BETWEEN_QUASI_COMPONENT_POINT] THEN
  REWRITE_TAC[SEPARATED_BETWEEN] THEN SET_TAC[]);;

lemma open_quasi_eq_connected_components_of:
   "
        openin X c
        \<Longrightarrow> (c \<in> quasi_components_of X \<longleftrightarrow>
             c \<in> connected_components_of X)"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `closedin X (c::A=>bool)` THENL
   [STRIP_TAC;
    ASM_MESON_TAC[CLOSED_IN_CONNECTED_COMPONENTS_OF;
                  CLOSED_IN_QUASI_COMPONENTS_OF]] THEN
  EQ_TAC THENL
   [SIMP_TAC[CONNECTED_QUASI_COMPONENT_OF] THEN
    SIMP_TAC[connectedin; QUASI_COMPONENTS_OF_SUBSET] THEN DISCH_TAC THEN
    REWRITE_TAC[CONNECTED_SPACE_CLOPEN_IN] THEN
    ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; CLOSED_IN_CLOSED_SUBTOPOLOGY] THEN
    X_GEN_TAC `t::A=>bool` THEN STRIP_TAC THEN MATCH_MP_TAC(SET_RULE
     `(\<forall>x. x \<in> s \<Longrightarrow> P) \<Longrightarrow> s = {} \<or> P`) THEN
    X_GEN_TAC `z::A` THEN DISCH_TAC THEN
    ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; QUASI_COMPONENTS_OF_SUBSET] THEN
    ASM_REWRITE_TAC[GSYM SUBSET_ANTISYM_EQ] THEN
    MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`; `t::A=>bool`]
        QUASI_COMPONENT_OF_CLOPEN_CASES) THEN
    ASM SET_TAC[];
    REWRITE_TAC[connected_components_of; quasi_components_of] THEN
    REWRITE_TAC[IN_ELIM_THM] THEN MATCH_MP_TAC MONO_EXISTS THEN
    X_GEN_TAC `x::A` THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC SUBSET_ANTISYM THEN
    REWRITE_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF] THEN
    ASM_SIMP_TAC[QUASI_COMPONENT_OF_SET] THEN
    MATCH_MP_TAC INTERS_SUBSET_STRONG THEN
    EXISTS_TAC `c::A=>bool` THEN REWRITE_TAC[IN_ELIM_THM] THEN
    ASM_REWRITE_TAC[SUBSET_REFL] THEN REWRITE_TAC[\<in>] THEN
    ASM_REWRITE_TAC[CONNECTED_COMPONENT_OF_REFL]]);;

lemma quasi_component_of_continuous_image:
   "\<And>X X' f x y.
        continuous_map X X' f \<and>
        quasi_component_of X x y
        \<Longrightarrow> quasi_component_of X' (f x) (f y)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[quasi_component_of] THEN
  STRIP_TAC THEN
  REPEAT(CONJ_TAC THENL [ASM_MESON_TAC[continuous_map]; ALL_TAC]) THEN
  X_GEN_TAC `t::B=>bool` THEN STRIP_TAC THEN FIRST_X_ASSUM
   (MP_TAC \<circ> SPEC `{x \<in> topspace X. f x \<in> t}`) THEN
  ASM_REWRITE_TAC[IN_ELIM_THM] THEN DISCH_THEN MATCH_MP_TAC THEN CONJ_TAC THENL
   [MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE;
    MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE] THEN
  ASM_MESON_TAC[]);;

lemma quasi_component_of_discrete_topology:
   "quasi_component_of (discrete_topology u) x =
           if x \<in> u then {x} else {}"
oops
  REPEAT GEN_TAC THEN GEN_REWRITE_TAC id [EXTENSION] THEN
  X_GEN_TAC `y::A` THEN GEN_REWRITE_TAC LAND_CONV [\<in>] THEN
  REWRITE_TAC[quasi_component_of; TOPSPACE_DISCRETE_TOPOLOGY] THEN
  REWRITE_TAC[OPEN_IN_DISCRETE_TOPOLOGY; CLOSED_IN_DISCRETE_TOPOLOGY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_SING; NOT_IN_EMPTY] THEN
  EQ_TAC THEN ASM_SIMP_TAC[] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{x::A}`) THEN
  ASM_REWRITE_TAC[IN_SING; SING_SUBSET]);;

lemma quasi_components_of_discrete_topology:
   "\<And>u::A=>bool.
        quasi_components_of (discrete_topology u) = {{x} | x \<in> u}"
oops
  GEN_TAC THEN REWRITE_TAC[quasi_components_of] THEN
  REWRITE_TAC[TOPSPACE_DISCRETE_TOPOLOGY;
              QUASI_COMPONENT_OF_DISCRETE_TOPOLOGY] THEN
  SET_TAC[]);;

lemma homeomorphic_map_quasi_component_of:
   "\<And>f X X' x.
        homeomorphic_map X X' f \<and> x \<in> topspace X
        \<Longrightarrow> quasi_component_of X' (f x) =
            f ` (quasi_component_of X x)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[HOMEOMORPHIC_MAP_MAPS; homeomorphic_maps] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN `g::B=>A` STRIP_ASSUME_TAC) ASSUME_TAC) THEN
  REWRITE_TAC[EXTENSION; IN_IMAGE] THEN REWRITE_TAC[\<in>] THEN
  MP_TAC(ISPEC `X':B topology` QUASI_COMPONENT_IN_TOPSPACE) THEN
  MP_TAC(ISPECL [`X::A topology`; `X':B topology`; `f::A=>B`]
        QUASI_COMPONENT_OF_CONTINUOUS_IMAGE) THEN
  MP_TAC(ISPECL [`X':B topology`; `X::A topology`; `g::B=>A`]
        QUASI_COMPONENT_OF_CONTINUOUS_IMAGE) THEN
  ASM_REWRITE_TAC[] THEN REPEAT
   (FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE)) THEN
  ASM SET_TAC[]);;

lemma homeomorphic_map_quasi_components_of:
   "\<And>f X X'.
      homeomorphic_map X X' f
      \<Longrightarrow> quasi_components_of X' =
          image (image f) (quasi_components_of X)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[quasi_components_of; SIMPLE_IMAGE] THEN
  FIRST_ASSUM(SUBST1_TAC \<circ> SYM \<circ> MATCH_MP HOMEOMORPHIC_IMP_SURJECTIVE_MAP) THEN
  REWRITE_TAC[GSYM IMAGE_o; o_DEF] THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x = g x) \<Longrightarrow> f ` s = g ` s`) THEN
  REWRITE_TAC[] THEN ASM_MESON_TAC[HOMEOMORPHIC_MAP_QUASI_COMPONENT_OF]);;

lemma openin_quasi_component_of_locally_connected_space:
   "        locally_connected_space X
        \<Longrightarrow> openin X (quasi_component_of X x)"
oops
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[QUASI_COMPONENT_AS_CONNECTED_COMPONENT_UNIONS] THEN
  MATCH_MP_TAC OPEN_IN_UNIONS THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
  ASM_SIMP_TAC[OPEN_IN_CONNECTED_COMPONENT_OF_LOCALLY_CONNECTED_SPACE]);;

lemma openin_quasi_components_of_locally_connected_space:
   "
        locally_connected_space X \<and> c \<in> quasi_components_of X
        \<Longrightarrow> openin X c"
oops
  REWRITE_TAC[quasi_components_of; IN_ELIM_THM] THEN
  MESON_TAC[OPEN_IN_QUASI_COMPONENT_OF_LOCALLY_CONNECTED_SPACE]);;

lemma quasi_eq_connected_components_of_alt:
   "        quasi_components_of X = connected_components_of X \<longleftrightarrow>
        \<forall>c. c \<in> quasi_components_of X \<Longrightarrow> connectedin X c"
oops
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC[CONNECTED_IN_CONNECTED_COMPONENTS_OF] THEN
  DISCH_TAC THEN REWRITE_TAC[EXTENSION] THEN X_GEN_TAC `c::A=>bool` THEN
  REWRITE_TAC[quasi_components_of; connected_components_of] THEN
  REWRITE_TAC[IN_ELIM_THM] THEN AP_TERM_TAC THEN
  GEN_REWRITE_TAC id [FUN_EQ_THM] THEN X_GEN_TAC `x::A` THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THEN ASM_REWRITE_TAC[] THEN
  AP_TERM_TAC THEN REWRITE_TAC[QUASI_EQ_CONNECTED_COMPONENT_OF_EQ] THEN
  ASM_SIMP_TAC[QUASI_COMPONENT_IN_QUASI_COMPONENTS_OF]);;

lemma connected_subset_quasi_components_of_pointwise:
   "        connected_components_of X \<subseteq> quasi_components_of X \<longleftrightarrow>
        \<forall>x. x \<in> topspace X
            \<Longrightarrow> quasi_component_of X x = connected_component_of X x"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[quasi_components_of; connected_components_of] THEN EQ_TAC THENL
   [ALL_TAC; REWRITE_TAC[EXTENSION; \<subseteq>; IN_ELIM_THM] THEN MESON_TAC[]] THEN
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> x \<in> f x \<and> f x \<subseteq> g x) \<and>
    (\<forall>x y. x \<in> s \<and> y \<in> s \<Longrightarrow> g x = g y \<or> disjnt (g x) (g y))
    \<Longrightarrow> {f x | x \<in> s} \<subseteq> {g x | x \<in> s} \<Longrightarrow> \<forall>x. x \<in> s \<Longrightarrow> f x = g x`) THEN
  SIMP_TAC[QUASI_COMPONENT_OF_DISJOINT; QUASI_COMPONENT_OF_EQ] THEN
  SIMP_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF; EXCLUDED_MIDDLE] THEN
  REWRITE_TAC[\<in>; CONNECTED_COMPONENT_OF_REFL]);;

lemma quasi_subset_connected_components_of_pointwise:
   "        quasi_components_of X \<subseteq> connected_components_of X \<longleftrightarrow>
        \<forall>x. x \<in> topspace X
            \<Longrightarrow> quasi_component_of X x = connected_component_of X x"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[quasi_components_of; connected_components_of] THEN EQ_TAC THENL
   [ALL_TAC; REWRITE_TAC[EXTENSION; \<subseteq>; IN_ELIM_THM] THEN MESON_TAC[]] THEN
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> x \<in> f x \<and> f x \<subseteq> g x) \<and>
    (\<forall>x y. x \<in> s \<and> y \<in> s \<Longrightarrow> f x = f y \<or> disjnt (f x) (f y))
    \<Longrightarrow> {g x | x \<in> s} \<subseteq> {f x | x \<in> s} \<Longrightarrow> \<forall>x. x \<in> s \<Longrightarrow> f x = g x`) THEN
  SIMP_TAC[CONNECTED_COMPONENT_OF_DISJOINT; CONNECTED_COMPONENT_OF_EQ] THEN
  SIMP_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF; EXCLUDED_MIDDLE] THEN
  REWRITE_TAC[\<in>; CONNECTED_COMPONENT_OF_REFL]);;

lemma quasi_eq_connected_components_of_pointwise:
   "        quasi_components_of X = connected_components_of X \<longleftrightarrow>
        \<forall>x. x \<in> topspace X
            \<Longrightarrow> quasi_component_of X x = connected_component_of X x"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [SIMP_TAC[GSYM CONNECTED_SUBSET_QUASI_COMPONENTS_OF_POINTWISE; SUBSET_REFL];
    REWRITE_TAC[quasi_components_of; connected_components_of] THEN
    REWRITE_TAC[EXTENSION; IN_ELIM_THM] THEN MESON_TAC[]]);;

lemma quasi_eq_connected_components_of_pointwise_alt:
   "        quasi_components_of X = connected_components_of X \<longleftrightarrow>
        \<forall>x. quasi_component_of X x = connected_component_of X x"
oops
  GEN_TAC THEN REWRITE_TAC[QUASI_EQ_CONNECTED_COMPONENTS_OF_POINTWISE] THEN
  EQ_TAC THEN SIMP_TAC[] THEN DISCH_TAC THEN X_GEN_TAC `x::A` THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THEN ASM_SIMP_TAC[] THEN
  ASM_MESON_TAC[CONNECTED_COMPONENT_OF_EQ_EMPTY;
                QUASI_COMPONENT_OF_EQ_EMPTY]);;

lemma quasi_eq_connected_components_of_inclusion:
   "        quasi_components_of X = connected_components_of X \<longleftrightarrow>
        connected_components_of X \<subseteq> quasi_components_of X \<or>
        quasi_components_of X \<subseteq> connected_components_of X"
oops
  REWRITE_TAC[CONNECTED_SUBSET_QUASI_COMPONENTS_OF_POINTWISE;
              QUASI_SUBSET_CONNECTED_COMPONENTS_OF_POINTWISE;
              QUASI_EQ_CONNECTED_COMPONENTS_OF_POINTWISE]);;

lemma quasi_eq_connected_components_of:
   "      finite(connected_components_of X) \<or>
      finite(quasi_components_of X) \<or>
      locally_connected_space X \<or>
      compact_space X \<and>
      (Hausdorff_space X \<or> regular_space X \<or> normal_space X)
      \<Longrightarrow> quasi_components_of X = connected_components_of X"
oops
  REPEAT GEN_TAC THEN DISCH_THEN
   (REPEAT_TCL DISJ_CASES_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC))
  THENL
   [REWRITE_TAC[QUASI_EQ_CONNECTED_COMPONENTS_OF_INCLUSION] THEN
    DISJ1_TAC THEN REWRITE_TAC[\<subseteq>] THEN
    ASM_MESON_TAC[OPEN_QUASI_EQ_CONNECTED_COMPONENTS_OF;
                  OPEN_IN_FINITE_CONNECTED_COMPONENTS];
    REWRITE_TAC[QUASI_EQ_CONNECTED_COMPONENTS_OF_INCLUSION] THEN
    DISJ2_TAC THEN REWRITE_TAC[\<subseteq>] THEN
    ASM_MESON_TAC[OPEN_QUASI_EQ_CONNECTED_COMPONENTS_OF;
                  OPEN_IN_FINITE_QUASI_COMPONENTS];
    REWRITE_TAC[EXTENSION] THEN
    ASM_MESON_TAC[OPEN_QUASI_EQ_CONNECTED_COMPONENTS_OF;
                  OPEN_IN_CONNECTED_COMPONENTS_OF_LOCALLY_CONNECTED_SPACE;
                  OPEN_IN_QUASI_COMPONENTS_OF_LOCALLY_CONNECTED_SPACE];
    REWRITE_TAC[QUASI_EQ_CONNECTED_COMPONENTS_OF_ALT]] THEN
  X_GEN_TAC `c::A=>bool` THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP QUASI_COMPONENTS_OF_SUBSET) THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_QUASI_COMPONENTS_OF) THEN
  ASM_REWRITE_TAC[connectedin; CONNECTED_SPACE_CLOSED_IN_EQ] THEN
  ASM_SIMP_TAC[CLOSED_IN_CLOSED_SUBTOPOLOGY; NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; GSYM disjnt] THEN STRIP_TAC THEN
  MP_TAC(fst(EQ_IMP_RULE(ISPEC `X::A topology` normal_space))) THEN
  ANTS_TAC THENL
   [ASM_MESON_TAC[COMPACT_HAUSDORFF_OR_REGULAR_IMP_NORMAL_SPACE];
    DISCH_THEN(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`])] THEN
  ASM_REWRITE_TAC[NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `v::A=>bool`] THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [`X::A topology`; `c::A=>bool`; `topspace X - (u \<union> v):A=>bool`]
   SEPARATED_BETWEEN_QUASI_COMPONENT_COMPACT) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL
   [MATCH_MP_TAC CLOSED_IN_COMPACT_SPACE THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC CLOSED_IN_DIFF THEN
    ASM_SIMP_TAC[OPEN_IN_UNION; CLOSED_IN_TOPSPACE];
    DISCH_THEN(MP_TAC \<circ> snd \<circ> EQ_IMP_RULE)] THEN
  ANTS_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[separated_between]] THEN
  REWRITE_TAC[NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`e::A=>bool`; `g::A=>bool`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ>
   SPEC `g \<union> u::A=>bool` \<circ>
   MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ] QUASI_COMPONENT_OF_CLOPEN_CASES)) THEN
  ASM_SIMP_TAC[OPEN_IN_UNION; NOT_IMP] THEN
  CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  SUBGOAL_THEN `g \<union> u::A=>bool = topspace X - (e \<inter> v)`
  SUBST1_TAC THENL
   [REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
    ASM SET_TAC[];
    MATCH_MP_TAC CLOSED_IN_DIFF THEN
    ASM_SIMP_TAC[CLOSED_IN_TOPSPACE; OPEN_IN_INTER]]);;

lemma quasi_eq_connected_component_of:
   "\<And>X (x::A).
      finite(connected_components_of X) \<or>
      finite(quasi_components_of X) \<or>
      locally_connected_space X \<or>
      compact_space X \<and>
      (Hausdorff_space X \<or> regular_space X \<or> normal_space X)
      \<Longrightarrow> quasi_component_of X x = connected_component_of X x"
oops
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP QUASI_EQ_CONNECTED_COMPONENTS_OF) THEN
  SIMP_TAC[QUASI_EQ_CONNECTED_COMPONENTS_OF_POINTWISE_ALT]);;


subsection\<open>Additional quasicomponent and continuum properties like Boundary Bumping\<close>


lemma cut_wire_fence_theorem_gen:
   "\<And>X s t::A=>bool.
        compact_space X \<and>
        (Hausdorff_space X \<or> regular_space X \<or> normal_space X) \<and>
        compactin X s \<and> closedin X t \<and>
        (\<forall>c. connectedin X c \<Longrightarrow> disjnt c s \<or> disjnt c t)
        \<Longrightarrow> separated_between X s t"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  ASM_SIMP_TAC[SEPARATED_BETWEEN_POINTWISE_LEFT; CLOSED_IN_COMPACT_SPACE] THEN
  ASM_SIMP_TAC[SEPARATED_BETWEEN_POINTWISE_RIGHT; CLOSED_IN_COMPACT_SPACE] THEN
  ASM_SIMP_TAC[CLOSED_IN_SUBSET; SING_SUBSET] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  ASM_CASES_TAC `(x::A) \<in> topspace X` THENL
   [ASM_REWRITE_TAC[]; ASM_MESON_TAC[COMPACT_IN_SUBSET_TOPSPACE; \<subseteq>]] THEN
  X_GEN_TAC `y::A` THEN DISCH_TAC THEN
  ASM_CASES_TAC `(y::A) \<in> topspace X` THENL
   [ASM_REWRITE_TAC[SEPARATED_BETWEEN_SINGS];
    ASM_MESON_TAC[CLOSED_IN_SUBSET; \<subseteq>]] THEN
  ASM_SIMP_TAC[QUASI_EQ_CONNECTED_COMPONENT_OF] THEN
  REWRITE_TAC[connected_component_of; NOT_EXISTS_THM] THEN
  X_GEN_TAC `c::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `c::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN ASM SET_TAC[]);;

lemma cut_wire_fence_theorem:
   "\<And>X s t::A=>bool.
        compact_space X \<and> Hausdorff_space X \<and>
        closedin X s \<and> closedin X t \<and>
        (\<forall>c. connectedin X c \<Longrightarrow> disjnt c s \<or> disjnt c t)
        \<Longrightarrow> separated_between X s t"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CUT_WIRE_FENCE_THEOREM_GEN THEN
  ASM_SIMP_TAC[CLOSED_IN_COMPACT_SPACE]);;

lemma separated_between_from_closed_subtopology:
   "\<And>X s t c::A=>bool.
        separated_between (subtopology X c) s (X frontier_of c) \<and>
        separated_between (subtopology X c) s t
        \<Longrightarrow> separated_between X s t"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[GSYM SEPARATED_BETWEEN_UNION] THEN
  REWRITE_TAC[SEPARATED_BETWEEN] THEN MATCH_MP_TAC MONO_EXISTS THEN
  GEN_TAC THEN REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN REPEAT CONJ_TAC THENL
   [MP_TAC(ISPECL
      [`X::A topology`; `topspace X \<inter> c::A=>bool`; `u::A=>bool`]
      CLOSED_IN_CLOSED_SUBTOPOLOGY) THEN
    ASM_REWRITE_TAC[GSYM SUBTOPOLOGY_RESTRICT] THEN
    ANTS_TAC THENL [ALL_TAC; SIMP_TAC[]] THEN
    SIMP_TAC[GSYM FRONTIER_OF_SUBSET_EQ; INTER_SUBSET] THEN
    REWRITE_TAC[GSYM FRONTIER_OF_RESTRICT] THEN ASM SET_TAC[];
    MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`; `u::A=>bool`]
      OPEN_IN_SUBSET_TOPSPACE_EQ) THEN
    ASM SET_TAC[];
    ASM SET_TAC[]]);;

lemma separated_between_from_closed_subtopology_frontier:
   "\<And>X s t::A=>bool.
        separated_between (subtopology X t) s (X frontier_of t)
        \<Longrightarrow> separated_between X s (X frontier_of t)"
oops
  ASM_MESON_TAC[SEPARATED_BETWEEN_FROM_CLOSED_SUBTOPOLOGY]);;

lemma separated_between_from_frontier_of_closed_subtopology:
   "\<And>X s t::A=>bool.
        separated_between (subtopology X t) s (X frontier_of t)
        \<Longrightarrow> separated_between X s (topspace X - t)"
oops
  REPEAT STRIP_TAC THEN
  GEN_REWRITE_TAC id [CONJUNCT2 SEPARATED_BETWEEN_FRONTIER_OF_EQ] THEN
  REPEAT CONJ_TAC THENL
   [SET_TAC[];
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP SEPARATED_BETWEEN_IMP_SUBSET) THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[];
    REWRITE_TAC[FRONTIER_OF_COMPLEMENT]] THEN
  MATCH_MP_TAC SEPARATED_BETWEEN_FROM_CLOSED_SUBTOPOLOGY_FRONTIER THEN
  ASM_REWRITE_TAC[]);;

lemma separated_between_compact_connected_component:
   "\<And>X c t::A=>bool.
        locally_compact_space X \<and> Hausdorff_space X \<and>
        c \<in> connected_components_of X \<and> compactin X c \<and>
        closedin X t \<and> disjnt c t
        \<Longrightarrow> separated_between X c t"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   `\<exists>n l::A=>bool.
        openin X n \<and>
        compactin X l \<and>
        closedin X l \<and>
        c \<subseteq> n \<and> n \<subseteq> l \<and> l \<subseteq> topspace X - t`
  STRIP_ASSUME_TAC THENL
   [MP_TAC(ISPEC `subtopology X (topspace X - t::A=>bool)`
        LOCALLY_COMPACT_SPACE_COMPACT_CLOSED_COMPACT) THEN
    ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY; COMPACT_IN_SUBTOPOLOGY] THEN
    ASM_SIMP_TAC[LOCALLY_COMPACT_SPACE_OPEN_SUBSET; OPEN_IN_OPEN_SUBTOPOLOGY;
                 OPEN_IN_DIFF; OPEN_IN_TOPSPACE] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `c::A=>bool`) THEN ANTS_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
      ASM SET_TAC[];
      REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
      STRIP_TAC THEN ASM_SIMP_TAC[COMPACT_IN_IMP_CLOSED_IN]];
    ALL_TAC] THEN
  MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`;
                 `topspace X - l::A=>bool`]
           (CONJUNCT2 SEPARATED_BETWEEN_FRONTIER_OF)) THEN
  ANTS_TAC THENL [ASM SET_TAC[]; DISCH_THEN(MP_TAC \<circ> fst \<circ> EQ_IMP_RULE)] THEN
  ANTS_TAC THENL
   [ALL_TAC;
    REWRITE_TAC[separated_between] THEN
    REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
    ASM SET_TAC[]] THEN
  MATCH_MP_TAC SEPARATED_BETWEEN_FROM_CLOSED_SUBTOPOLOGY THEN
  EXISTS_TAC `l::A=>bool` THEN
  ASM_REWRITE_TAC[FRONTIER_OF_COMPLEMENT] THEN
  MATCH_MP_TAC CUT_WIRE_FENCE_THEOREM THEN
  ASM_SIMP_TAC[CLOSED_IN_CLOSED_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY; HAUSDORFF_SPACE_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[FRONTIER_OF_SUBSET_CLOSED_IN; COMPACT_IN_IMP_CLOSED_IN] THEN
  REWRITE_TAC[CLOSED_IN_FRONTIER_OF; CONNECTED_IN_SUBTOPOLOGY] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `d::A=>bool` THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `d::A=>bool`; `c::A=>bool`]
        CONNECTED_COMPONENTS_OF_MAXIMAL) THEN
  ASM_REWRITE_TAC[TAUT `p \<or> q \<longleftrightarrow> \<not> p \<Longrightarrow> q`] THEN
  MATCH_MP_TAC MONO_IMP THEN CONJ_TAC THENL [SET_TAC[]; ALL_TAC] THEN
  REWRITE_TAC[frontier_of] THEN MATCH_MP_TAC(SET_RULE
   `c \<subseteq> v \<Longrightarrow> d \<subseteq> c \<Longrightarrow> disjnt d (u - v)`) THEN
  TRANS_TAC SUBSET_TRANS `n::A=>bool` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC[INTERIOR_OF_MAXIMAL]);;

lemma wilder_locally_compact_component_thm:
   "\<And>X c w::A=>bool.
        locally_compact_space X \<and> Hausdorff_space X \<and>
        c \<in> connected_components_of X \<and> compactin X c \<and>
        openin X w \<and> c \<subseteq> w
        \<Longrightarrow> \<exists>u v. openin X u \<and> openin X v \<and>
                  disjnt u v \<and> u \<union> v = topspace X \<and>
                  c \<subseteq> u \<and> u \<subseteq> w"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`; `topspace X - w::A=>bool`]
        SEPARATED_BETWEEN_COMPACT_CONNECTED_COMPONENT) THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE] THEN
  ANTS_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[separated_between]] THEN
  REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN ASM SET_TAC[]);;

lemma compact_quasi_eq_connected_components_of:
   "
        locally_compact_space X \<and> Hausdorff_space X \<and>
        compactin X c
        \<Longrightarrow> (c \<in> quasi_components_of X \<longleftrightarrow>
             c \<in> connected_components_of X)"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  GEN_TAC THEN REPEAT DISCH_TAC THEN
  REWRITE_TAC[quasi_components_of; connected_components_of] THEN
  MATCH_MP_TAC(SET_RULE
   `(\<forall>x. P x \<and> Q(g x) \<Longrightarrow> Q(f x)) \<and>
    (\<forall>x. P x \<and> Q(f x) \<Longrightarrow> f x = g x)
    \<Longrightarrow> \<forall>c. Q c \<Longrightarrow> (c \<in> {g x | P x} \<longleftrightarrow> c \<in> {f x | P x})`) THEN
  REWRITE_TAC[] THEN CONJ_TAC THEN X_GEN_TAC `x::A` THEN STRIP_TAC THENL
   [MATCH_MP_TAC CLOSED_COMPACT_IN THEN
    EXISTS_TAC `quasi_component_of X (x::A)` THEN
    ASM_REWRITE_TAC[CLOSED_IN_CONNECTED_COMPONENT_OF;
                    CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF];
    ALL_TAC] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[CONNECTED_COMPONENT_SUBSET_QUASI_COMPONENT_OF] THEN
  REWRITE_TAC[\<subseteq>] THEN X_GEN_TAC `y::A` THEN
  REWRITE_TAC[TAUT `p \<Longrightarrow> q \<longleftrightarrow> \<not> (p \<and> \<not> q)`] THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [`X::A topology`; `connected_component_of X (x::A)`; `{y::A}`]
        SEPARATED_BETWEEN_COMPACT_CONNECTED_COMPONENT) THEN
  ASM_REWRITE_TAC[CONNECTED_COMPONENT_IN_CONNECTED_COMPONENTS_OF] THEN
  ASM_REWRITE_TAC[NOT_IMP; DISJOINT_SING] THEN
  SUBGOAL_THEN `(y::A) \<in> topspace X` ASSUME_TAC THENL
   [ASM_MESON_TAC[\<subseteq>; QUASI_COMPONENT_OF_SUBSET_TOPSPACE];
    ASM_SIMP_TAC[CLOSED_IN_HAUSDORFF_SING]] THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`{x::A}`; `{y::A}`] \<circ> MATCH_MP
   (ONCE_REWRITE_RULE[IMP_CONJ] SEPARATED_BETWEEN_MONO)) THEN
  ASM_REWRITE_TAC[SUBSET_REFL; SEPARATED_BETWEEN_SINGS; SING_SUBSET] THEN
  REWRITE_TAC[IN_SING] THEN REWRITE_TAC[\<in>] THEN
  ASM_REWRITE_TAC[CONNECTED_COMPONENT_OF_REFL] THEN ASM_MESON_TAC[\<in>]);;

lemma boundary_bumping_theorem_closed_gen:
   "\<And>X s c::A=>bool.
        connected_space X \<and>
        locally_compact_space X \<and>
        Hausdorff_space X \<and>
        closedin X s \<and>
        (s \<noteq> topspace X) \<and>
        compactin X c \<and>
        c \<in> connected_components_of(subtopology X s)
        \<Longrightarrow> \<not> (c \<inter> X frontier_of s = {})"
oops
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [`subtopology X (s::A=>bool)`; `c::A=>bool`; `X frontier_of s::A=>bool`]
       SEPARATED_BETWEEN_COMPACT_CONNECTED_COMPONENT) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC LOCALLY_COMPACT_SPACE_CLOSED_SUBSET THEN ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY];
    ASM_REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
    SIMP_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER];
    ASM_SIMP_TAC[CLOSED_IN_CLOSED_SUBTOPOLOGY; CLOSED_IN_FRONTIER_OF] THEN
    ASM_SIMP_TAC[FRONTIER_OF_SUBSET_CLOSED_IN];
    ASM SET_TAC[];
    DISCH_THEN(MP_TAC \<circ> MATCH_MP
     SEPARATED_BETWEEN_FROM_CLOSED_SUBTOPOLOGY_FRONTIER)] THEN
  ASM_SIMP_TAC[CONNECTED_SPACE_IMP_SEPARATED_BETWEEN_TRIVIAL] THEN
  ASM_SIMP_TAC[CONNECTED_SPACE_FRONTIER_EQ_EMPTY; CLOSED_IN_SUBSET] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP NONEMPTY_CONNECTED_COMPONENTS_OF) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE `c \<in> s \<Longrightarrow> (s \<noteq> {})`)) THEN
  REWRITE_TAC[CONNECTED_COMPONENTS_OF_EQ_EMPTY; TOPSPACE_SUBTOPOLOGY] THEN
  SET_TAC[]);;

lemma boundary_bumping_theorem_closed:
   "\<And>X s c::A=>bool.
        connected_space X \<and> compact_space X \<and> Hausdorff_space X \<and>
        closedin X s \<and> (s \<noteq> topspace X) \<and>
        c \<in> connected_components_of(subtopology X s)
        \<Longrightarrow> \<not> (c \<inter> X frontier_of s = {})"
oops
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC BOUNDARY_BUMPING_THEOREM_CLOSED_GEN THEN
  ASM_SIMP_TAC[COMPACT_IMP_LOCALLY_COMPACT_SPACE] THEN
  MATCH_MP_TAC CLOSED_IN_COMPACT_SPACE THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_CONNECTED_COMPONENTS_OF) THEN
  ASM_SIMP_TAC[CLOSED_IN_CLOSED_SUBTOPOLOGY]);;

lemma intermediate_continuum_exists:
   "\<And>X c u::A=>bool.
        connected_space X \<and>
        locally_compact_space X \<and>
        Hausdorff_space X \<and>
        compactin X c \<and> connectedin X c \<and>
        (c \<noteq> {}) \<and> (c \<noteq> topspace X) \<and>
        openin X u \<and> c \<subseteq> u
        \<Longrightarrow> \<exists>d. compactin X d \<and> connectedin X d \<and>
                c \<subset> d \<and> d \<subset> u"
oops
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CONNECTED_IN_SUBSET_TOPSPACE) THEN
  SUBGOAL_THEN `\<exists>a::A. a \<in> topspace X \<and> (a \<notin> c)` STRIP_ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  MP_TAC(ISPEC `subtopology X (u DELETE (a::A))`
        LOCALLY_COMPACT_SPACE_COMPACT_CLOSED_COMPACT) THEN
  ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY; COMPACT_IN_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[LOCALLY_COMPACT_SPACE_OPEN_SUBSET; OPEN_IN_OPEN_SUBTOPOLOGY;
               OPEN_IN_HAUSDORFF_DELETE; SUBSET_DELETE] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `c::A=>bool`) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `k::A=>bool`] THEN STRIP_TAC THEN
  MP_TAC(SPECL [`subtopology X (k::A=>bool)`; `c::A=>bool`]
        EXISTS_CONNECTED_COMPONENT_OF_SUPERSET) THEN
  ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
  ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `d::A=>bool` THEN
  STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_CONNECTED_COMPONENTS_OF) THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP
   (REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_COMPACT_SPACE)) THEN
  ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_IN_CONNECTED_COMPONENTS_OF) THEN
  ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC[\<subset>] THEN REPEAT CONJ_TAC THENL
   [ALL_TAC;
    ASM SET_TAC[];
    DISCH_THEN SUBST_ALL_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `u::A=>bool` \<circ>
        GEN_REWRITE_RULE id [CONNECTED_SPACE_CLOPEN_IN]) THEN
    ASM_SIMP_TAC[COMPACT_IN_IMP_CLOSED_IN] THEN ASM SET_TAC[]] THEN
  DISCH_THEN(SUBST_ALL_TAC \<circ> SYM) THEN
  MP_TAC(ISPECL [`X::A topology`; `k::A=>bool`; `c::A=>bool`]
        BOUNDARY_BUMPING_THEOREM_CLOSED_GEN) THEN
  ASM_SIMP_TAC[COMPACT_IN_IMP_CLOSED_IN; NOT_IMP] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[frontier_of]] THEN
  MATCH_MP_TAC(SET_RULE `s \<subseteq> u \<Longrightarrow> s \<inter> (t - u) = {}`) THEN
  TRANS_TAC SUBSET_TRANS `v::A=>bool` THEN
  ASM_SIMP_TAC[INTERIOR_OF_MAXIMAL_EQ]);;

lemma boundary_bumping_theorem_gen:
   "\<And>X s c::A=>bool.
        connected_space X \<and>
        locally_compact_space X \<and>
        Hausdorff_space X \<and>
        s \<subset> topspace X \<and>
        c \<in> connected_components_of(subtopology X s) \<and>
        compactin X (X closure_of c)
        \<Longrightarrow> \<not> (X frontier_of c \<inter> X frontier_of s = {})"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[\<subset>] THEN STRIP_TAC THEN
  REWRITE_TAC[frontier_of] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
  REWRITE_TAC[SUBSET_INTER; TOPSPACE_SUBTOPOLOGY] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONNECTED_IN_CONNECTED_COMPONENTS_OF) THEN
  REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP NONEMPTY_CONNECTED_COMPONENTS_OF) THEN
  MATCH_MP_TAC(SET_RULE
   `i \<subseteq> i' \<and> c \<subseteq> c' \<and> \<not> (c \<subseteq> i')
    \<Longrightarrow> \<not> ((c - i) \<inter> (c' - i') = {})`) THEN
  REPEAT CONJ_TAC THENL
   [ASM_MESON_TAC[INTERIOR_OF_MONO];
    ASM_MESON_TAC[CLOSURE_OF_MONO];
    DISCH_TAC] THEN
  SUBGOAL_THEN `X closure_of c::A=>bool = c` SUBST_ALL_TAC THENL
   [MATCH_MP_TAC SUBSET_ANTISYM THEN ASM_SIMP_TAC[CLOSURE_OF_SUBSET] THEN
    MATCH_MP_TAC CONNECTED_COMPONENTS_OF_MAXIMAL THEN
    EXISTS_TAC `subtopology X (s::A=>bool)`THEN
    ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
     [ASM_SIMP_TAC[CONNECTED_IN_SUBTOPOLOGY; CONNECTED_IN_CLOSURE_OF] THEN
      MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`] INTERIOR_OF_SUBSET) THEN
      ASM SET_TAC[];
      MATCH_MP_TAC(SET_RULE `c \<subseteq> d \<and> (c \<noteq> {}) \<Longrightarrow> \<not> disjnt c d`) THEN
      ASM_SIMP_TAC[CLOSURE_OF_SUBSET]];
    ALL_TAC] THEN
  MP_TAC(ISPECL
   [`X::A topology`; `c::A=>bool`; `X interior_of s::A=>bool`]
        INTERMEDIATE_CONTINUUM_EXISTS) THEN
  ASM_REWRITE_TAC[OPEN_IN_INTERIOR_OF; NOT_IMP] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN `d::A=>bool` STRIP_ASSUME_TAC) THEN
  MP_TAC(SET_RULE `(c::A=>bool) \<subset> d \<Longrightarrow> \<not> (d \<subseteq> c)`) THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONNECTED_COMPONENTS_OF_MAXIMAL THEN
  EXISTS_TAC `subtopology X (s::A=>bool)` THEN
  ASM_REWRITE_TAC[CONNECTED_IN_SUBTOPOLOGY] THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`] INTERIOR_OF_SUBSET) THEN
  ASM SET_TAC[]);;

lemma boundary_bumping_theorem:
   "\<And>X s c::A=>bool.
        connected_space X \<and>
        compact_space X \<and>
        Hausdorff_space X \<and>
        s \<subset> topspace X \<and>
        c \<in> connected_components_of(subtopology X s)
        \<Longrightarrow> \<not> (X frontier_of c \<inter> X frontier_of s = {})"
oops
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC BOUNDARY_BUMPING_THEOREM_GEN THEN
  ASM_SIMP_TAC[COMPACT_IMP_LOCALLY_COMPACT_SPACE] THEN
  ASM_SIMP_TAC[CLOSED_IN_COMPACT_SPACE; CLOSED_IN_CLOSURE_OF]);;


lemma Hausdorff_space_mtopology:
   "Hausdorff_space mtopology"
oops
  REWRITE_TAC[Hausdorff_space; TOPSPACE_MTOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`m::A metric`; `x::A`; `y::A`] THEN STRIP_TAC THEN
  EXISTS_TAC `mball m (x::A,d x y / 2)` THEN
  EXISTS_TAC `mball m (y::A,d x y / 2)` THEN
  REWRITE_TAC[SET_RULE `disjnt s t \<longleftrightarrow> \<forall>x. x \<in> s \<and> x \<in> t \<Longrightarrow> False`] THEN
  REWRITE_TAC[OPEN_IN_MBALL; IN_MBALL] THEN
  POP_ASSUM_LIST(MP_TAC \<circ> end_itlist CONJ) THEN CONV_TAC METRIC_ARITH);;

lemma t1_space_mtopology:
   "t1_space mtopology"
oops
  SIMP_TAC[HAUSDORFF_IMP_T1_SPACE; HAUSDORFF_SPACE_MTOPOLOGY]);;




(* k-spaces (with no Hausdorff-ness assumptions built in).                   *)


let k_space = new_definition
 `k_space (X::A topology) \<longleftrightarrow>
        \<forall>s. s \<subseteq> topspace X
            \<Longrightarrow> (closedin X s \<longleftrightarrow>
                 \<forall>k. compactin X k
                     \<Longrightarrow> closedin (subtopology X k) (k \<inter> s))`;;

lemma k_space:
   "        k_space X \<longleftrightarrow>
        \<forall>s. s \<subseteq> topspace X \<and>
            (\<forall>k. compactin X k
                 \<Longrightarrow> closedin (subtopology X k) (k \<inter> s))
            \<Longrightarrow> closedin X s"
oops
  GEN_TAC THEN REWRITE_TAC[k_space] THEN
  MESON_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED]);;

lemma k_space_open:
   "        k_space X \<longleftrightarrow>
        \<forall>s. s \<subseteq> topspace X \<and>
            (\<forall>k. compactin X k
                 \<Longrightarrow> openin (subtopology X k) (k \<inter> s))
            \<Longrightarrow> openin X s"
oops
  GEN_TAC THEN REWRITE_TAC[K_SPACE] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC `s::A=>bool` THEN STRIP_TAC THEN
  GEN_REWRITE_TAC id [OPEN_IN_CLOSED_IN_EQ; closedin] THEN
  ASM_REWRITE_TAC[] THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  REWRITE_TAC[SUBSET_DIFF] THEN X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  GEN_REWRITE_TAC id [OPEN_IN_CLOSED_IN_EQ; closedin] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
  (CONJ_TAC THENL [SET_TAC[]; ALL_TAC]) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMP THEN AP_TERM_TAC THEN ASM SET_TAC[]);;

lemma k_space_alt:
   "        k_space X \<longleftrightarrow>
        \<forall>s. s \<subseteq> topspace X
            \<Longrightarrow> (openin X s \<longleftrightarrow>
                 \<forall>k. compactin X k
                     \<Longrightarrow> openin (subtopology X k) (k \<inter> s))"
oops
  GEN_TAC THEN REWRITE_TAC[K_SPACE_OPEN] THEN
  MESON_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN]);;

lemma k_space_quotient_map_image:
   "\<And>X X' (q::A=>B).
        quotient_map X X' q \<and> k_space X \<Longrightarrow> k_space X'"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[K_SPACE] THEN
  STRIP_TAC THEN X_GEN_TAC `s::B=>bool` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> CONJUNCT2 \<circ> GEN_REWRITE_RULE id [QUOTIENT_MAP]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `s::B=>bool`) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(SUBST1_TAC \<circ> SYM) THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC[SUBSET_RESTRICT] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   `subtopology X k =
    subtopology
     (subtopology X {x \<in> topspace X. (q::A=>B) x \<in> q ` k}) k`
  SUBST1_TAC THENL
   [REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN AP_TERM_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN SET_TAC[];
    ALL_TAC] THEN
  SUBGOAL_THEN
   `k \<inter> {x \<in> topspace X. q x \<in> s} =
    k \<inter> {x. x \<in> topspace(subtopology X
                  {x \<in> topspace X. (q::A=>B) x \<in> q ` k}) \<and>
                 q x \<in> (image (q::A=>B) k \<inter> s)}`
  SUBST1_TAC THENL
   [REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN SET_TAC[];
    ALL_TAC] THEN
  MATCH_MP_TAC CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED THEN
  MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
  EXISTS_TAC `subtopology X' (image (q::A=>B) k)` THEN CONJ_TAC THENL
   [REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
    CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    ASM_MESON_TAC[QUOTIENT_IMP_CONTINUOUS_MAP];
    FIRST_X_ASSUM MATCH_MP_TAC THEN MATCH_MP_TAC IMAGE_COMPACT_IN THEN
    ASM_MESON_TAC[QUOTIENT_IMP_CONTINUOUS_MAP]]);;

lemma k_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> k_space X \<Longrightarrow> k_space X'"
oops
  MESON_TAC[K_SPACE_QUOTIENT_MAP_IMAGE;
            RETRACTION_IMP_QUOTIENT_MAP]);;

lemma homeomorphic_k_space:
   "\<And>(X::A topology) (X':B topology).
      X homeomorphic_space X'
      \<Longrightarrow> (k_space X \<longleftrightarrow> k_space X')"
oops
  REWRITE_TAC[homeomorphic_space; HOMEOMORPHIC_MAPS_MAP] THEN
  REWRITE_TAC[GSYM SECTION_AND_RETRACTION_EQ_HOMEOMORPHIC_MAP] THEN
  MESON_TAC[K_SPACE_RETRACTION_MAP_IMAGE]);;

lemma k_space_perfect_map_image:
   "\<And>X X' f.
        k_space X \<and> perfect_map X X' f
        \<Longrightarrow> k_space X'"
oops
  MESON_TAC[PERFECT_IMP_QUOTIENT_MAP; K_SPACE_QUOTIENT_MAP_IMAGE]);;

lemma locally_compact_imp_k_space:
   "locally_compact_space X \<Longrightarrow> k_space X"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[K_SPACE] THEN
  X_GEN_TAC `s::A=>bool` THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> RAND_CONV) [GSYM CLOSURE_OF_SUBSET_EQ] THEN
  ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[\<subseteq>; NOT_FORALL_THM; NOT_IMP; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `x::A` THEN STRIP_TAC THEN
  SUBGOAL_THEN `(x::A) \<in> topspace X` ASSUME_TAC THENL
   [ASM_MESON_TAC[CLOSURE_OF_SUBSET_TOPSPACE; \<subseteq>]; ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [locally_compact_space]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` MP_TAC) THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `k::A=>bool` THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[GSYM CLOSURE_OF_SUBSET_EQ] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `x::A` \<circ> REWRITE_RULE[\<subseteq>] \<circ> CONJUNCT2) THEN
  ASM_REWRITE_TAC[IN_INTER; CLOSURE_OF_SUBTOPOLOGY] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  ASM_REWRITE_TAC[SET_RULE `k \<inter> k \<inter> s = s \<inter> k`; IN_CLOSURE_OF] THEN
  X_GEN_TAC `v::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_CLOSURE_OF]) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `u \<inter> v::A=>bool`) THEN
  ASM_SIMP_TAC[OPEN_IN_INTER] THEN ASM SET_TAC[]);;

lemma compact_imp_k_space:
   "compact_space X \<Longrightarrow> k_space X"
oops
  MESON_TAC[LOCALLY_COMPACT_IMP_K_SPACE;
            COMPACT_IMP_LOCALLY_COMPACT_SPACE]);;

lemma k_space_discrete_topology:
   "\<And>u::A=>bool. k_space(discrete_topology u)"
oops
  SIMP_TAC[K_SPACE; CLOSED_IN_DISCRETE_TOPOLOGY;
           TOPSPACE_DISCRETE_TOPOLOGY]);;

lemma metrizable_imp_k_space:
   "metrizable_space X \<Longrightarrow> k_space X"
oops
  REWRITE_TAC[FORALL_METRIZABLE_SPACE] THEN X_GEN_TAC `m::A metric` THEN
  REWRITE_TAC[K_SPACE] THEN X_GEN_TAC `s::A=>bool` THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[METRIC_CLOSED_IN_IFF_SEQUENTIALLY_CLOSED] THEN
  MAP_EVERY X_GEN_TAC [`a::num=>A`; `l::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(l::A) insert image a UNIV`) THEN
  ANTS_TAC THENL
   [MATCH_MP_TAC COMPACT_IN_SEQUENCE_WITH_LIMIT THEN
    EXISTS_TAC `a::num=>A` THEN REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
    ASM SET_TAC[];
    REWRITE_TAC[GSYM MTOPOLOGY_SUBMETRIC] THEN
    REWRITE_TAC[METRIC_CLOSED_IN_IFF_SEQUENTIALLY_CLOSED] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`a::num=>A`; `l::A`] \<circ> CONJUNCT2) THEN
    ANTS_TAC THENL [ALL_TAC; SIMP_TAC[IN_INTER]] THEN
    CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    ASM_REWRITE_TAC[LIMIT_SUBTOPOLOGY; MTOPOLOGY_SUBMETRIC] THEN
    REWRITE_TAC[IN_INSERT] THEN MATCH_MP_TAC ALWAYS_EVENTUALLY THEN
    REWRITE_TAC[] THEN SET_TAC[]]);;

lemma k_space_mtopology:
   "k_spacemtopology"
oops
  REWRITE_TAC[GSYM FORALL_METRIZABLE_SPACE; METRIZABLE_IMP_K_SPACE]);;

lemma k_space_euclideanreal:
 (`k_space euclideanreal"
oops
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC; K_SPACE_MTOPOLOGY]);;

lemma k_space_closed_subtopology:
   "
        k_space X \<and> closedin X s \<Longrightarrow> k_space(subtopology X s)"
oops
  MAP_EVERY X_GEN_TAC [`X::A topology`; `c::A=>bool`] THEN
  REWRITE_TAC[K_SPACE] THEN STRIP_TAC THEN
  X_GEN_TAC `s::A=>bool` THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER; COMPACT_IN_SUBTOPOLOGY] THEN
  STRIP_TAC THEN
  MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k \<inter> c::A=>bool`) THEN
  REWRITE_TAC[INTER_SUBSET] THEN ANTS_TAC THENL
   [MP_TAC(ISPECL [`subtopology X (k::A=>bool)`; `k \<inter> c::A=>bool`]
        CLOSED_IN_COMPACT_SPACE) THEN
    ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED] THEN
    ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY; COMPACT_IN_SUBTOPOLOGY];
    ASM_SIMP_TAC[SET_RULE `s \<subseteq> c \<Longrightarrow> (k \<inter> c) \<inter> s = k \<inter> s`;
                 SUBTOPOLOGY_SUBTOPOLOGY] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_TRANS) THEN
    REWRITE_TAC[SET_RULE `c \<inter> k \<inter> c = k \<inter> c`] THEN
    ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED]]);;

lemma k_space_subtopology:
   "
        (\<forall>t. t \<subseteq> topspace X \<and> t \<subseteq> s \<and>
             (\<forall>k. compactin X k
                  \<Longrightarrow> closedin (subtopology X (k \<inter> s)) (k \<inter> t))
             \<Longrightarrow> closedin (subtopology X s) t) \<and>
        (\<forall>k. compactin X k
             \<Longrightarrow> k_space(subtopology X (k \<inter> s)))
        \<Longrightarrow> k_space(subtopology X s)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[K_SPACE] THEN
  X_GEN_TAC `u::A=>bool` THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER; COMPACT_IN_SUBTOPOLOGY] THEN
  STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ>
    GEN_REWRITE_RULE RAND_CONV [K_SPACE] \<circ>
    SPEC `k::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; X_GEN_TAC `c::A=>bool`] THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC `c::A=>bool`) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
  MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL [AP_TERM_TAC; ALL_TAC] THEN
  ASM SET_TAC[]);;

lemma k_space_subtopology_open:
   "
        (\<forall>t. t \<subseteq> topspace X \<and> t \<subseteq> s \<and>
             (\<forall>k. compactin X k
                  \<Longrightarrow> openin (subtopology X (k \<inter> s)) (k \<inter> t))
             \<Longrightarrow> openin (subtopology X s) t) \<and>
        (\<forall>k. compactin X k
             \<Longrightarrow> k_space(subtopology X (k \<inter> s)))
        \<Longrightarrow> k_space(subtopology X s)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[K_SPACE_OPEN] THEN
  X_GEN_TAC `u::A=>bool` THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBSET_INTER; COMPACT_IN_SUBTOPOLOGY] THEN
  STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ>
    GEN_REWRITE_RULE RAND_CONV [K_SPACE_OPEN] \<circ>
    SPEC `k::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; X_GEN_TAC `c::A=>bool`] THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC `c::A=>bool`) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
  MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL [AP_TERM_TAC; ALL_TAC] THEN
  ASM SET_TAC[]);;

lemma k_space_open_subtopology:
   "
        (kc_space X \<or> Hausdorff_space X \<or> regular_space X) \<and>
        k_space X \<and> openin X s
        \<Longrightarrow> k_space(subtopology X s)"
oops
  lemma lemma:
   "\<And>X (v::A=>bool).
          kc_space X \<and> compact_space X \<and> openin X v
          \<Longrightarrow> k_space(subtopology X v)"
oops
    REPEAT STRIP_TAC THEN
    REWRITE_TAC[K_SPACE; TOPSPACE_SUBTOPOLOGY; SUBTOPOLOGY_SUBTOPOLOGY;
                COMPACT_IN_SUBTOPOLOGY; SUBSET_INTER] THEN
    X_GEN_TAC `s::A=>bool` THEN
    SIMP_TAC[SET_RULE `k \<subseteq> v \<Longrightarrow> v \<inter> k = k`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC (LABEL_TAC "*")) THEN
    FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN
    SUBGOAL_THEN
     `s::A=>bool = v \<inter> ((topspace X - v) \<union> s)` SUBST1_TAC
    THENL [ASM SET_TAC[]; MATCH_MP_TAC CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED] THEN
    MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN_GEN THEN ASM_REWRITE_TAC[] THEN
    ASM_REWRITE_TAC[compactin; UNION_SUBSET; SUBSET_DIFF] THEN
    X_GEN_TAC `U:(A=>bool)->bool` THEN STRIP_TAC THEN
    SUBGOAL_THEN `compactin X (topspace X - v::A=>bool)` MP_TAC THENL
     [MATCH_MP_TAC CLOSED_IN_COMPACT_SPACE THEN
      ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE];
      REWRITE_TAC[compactin; SUBSET_DIFF]] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `U:(A=>bool)->bool`) THEN
    ASM_SIMP_TAC[SET_RULE `s \<subseteq> t \<Longrightarrow> (t - u) \<inter> s = s - u`] THEN
    DISCH_THEN(X_CHOOSE_THEN `V1:(A=>bool)->bool` STRIP_ASSUME_TAC) THEN
    REMOVE_THEN "*" (MP_TAC \<circ> SPEC `topspace X - \<Union> V1::A=>bool`) THEN
    SUBGOAL_THEN `openin X (\<Union> V1::A=>bool)` ASSUME_TAC THENL
     [ASM_MESON_TAC[OPEN_IN_UNIONS; \<subseteq>]; ALL_TAC] THEN
    ASM_SIMP_TAC[CLOSED_IN_COMPACT_SPACE; CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE;
                 CLOSED_IN_CLOSED_SUBTOPOLOGY] THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
      CLOSED_IN_COMPACT_SPACE) \<circ> CONJUNCT1) THEN
    ASM_REWRITE_TAC[compactin] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `U:(A=>bool)->bool` \<circ> CONJUNCT2) THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN `V2:(A=>bool)->bool` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `V1 \<union> V2:(A=>bool)->bool` THEN
    ASM_REWRITE_TAC[FINITE_UNION] THEN ASM SET_TAC[])
in

  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC K_SPACE_SUBTOPOLOGY_OPEN THEN CONJ_TAC THENL
   [X_GEN_TAC `t::A=>bool` THEN STRIP_TAC THEN
    MATCH_MP_TAC OPEN_IN_SUBSET_TOPSPACE THEN ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id
     [K_SPACE_OPEN]) THEN
    ASM_REWRITE_TAC[] THEN X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_TRANS) THEN
    ASM_SIMP_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN];
    X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    FIRST_X_ASSUM DISJ_CASES_TAC THENL
     [MP_TAC(ISPECL [`subtopology X (k::A=>bool)`; `k \<inter> s::A=>bool`]
        lemma) THEN
      ASM_SIMP_TAC[KC_SPACE_SUBTOPOLOGY; OPEN_IN_SUBTOPOLOGY_INTER_OPEN] THEN
      ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY] THEN
      REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY; INTER_ACI];
      MATCH_MP_TAC LOCALLY_COMPACT_IMP_K_SPACE THEN
      ONCE_REWRITE_TAC[SET_RULE `k \<inter> s = k \<inter> (k \<inter> s)`] THEN
      ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_SUBTOPOLOGY] THEN
      MATCH_MP_TAC LOCALLY_COMPACT_SPACE_OPEN_SUBSET THEN
      ASM_SIMP_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN] THEN
      ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY;
                   COMPACT_IMP_LOCALLY_COMPACT_SPACE] THEN
      ASM_MESON_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY;
                    REGULAR_SPACE_SUBTOPOLOGY]]]);;

lemma k_kc_space_subtopology:
   "
        k_space X \<and> kc_space X \<and>
        (openin X s \<or> closedin X s)
        \<Longrightarrow> k_space(subtopology X s) \<and> kc_space(subtopology X s)"
oops
  MESON_TAC[K_SPACE_OPEN_SUBTOPOLOGY; K_SPACE_CLOSED_SUBTOPOLOGY;
            KC_SPACE_SUBTOPOLOGY]);;

lemma k_space_as_quotient_explicit:
   "        k_space X \<longleftrightarrow>
        quotient_map (sum_topology {k. compactin X k} (subtopology X),
                      X)
                     snd"
oops
  REWRITE_TAC[quotient_map; OPEN_IN_SUM_TOPOLOGY] THEN
  REWRITE_TAC[IN_ELIM_THM; TOPSPACE_SUM_TOPOLOGY; SUBSET_RESTRICT] THEN
  REWRITE_TAC[Sigma; IN_ELIM_PAIR_THM] THEN
  GEN_TAC THEN SIMP_TAC[K_SPACE_ALT; IN_ELIM_THM] THEN
  SIMP_TAC[o_THM; TOPSPACE_SUBTOPOLOGY_SUBSET; COMPACT_IN_SUBSET_TOPSPACE] THEN
  REWRITE_TAC[GSYM \<inter>] THEN MATCH_MP_TAC(TAUT
   `(p \<longleftrightarrow> p') \<and> q \<Longrightarrow> (p \<longleftrightarrow> q \<and> p')`) THEN
  CONJ_TAC THENL [MESON_TAC[]; ALL_TAC] THEN
  REWRITE_TAC[SET_RULE `image f {x,y | P x y} = {f(x,y) | P x y}`] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[\<subseteq>; FORALL_IN_GSPEC] THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  MAP_EVERY EXISTS_TAC [`{x::A}`; `x::A`] THEN
  ASM_REWRITE_TAC[COMPACT_IN_SING; IN_SING]);;

lemma k_space_as_quotient:
   "        k_space X \<longleftrightarrow>
        ?q (X':((A=>bool)#A)topology).
                locally_compact_space X' \<and> quotient_map X' X q"
oops
  GEN_TAC THEN EQ_TAC THENL
   [DISCH_TAC THEN MAP_EVERY EXISTS_TAC
     [`snd:(A=>bool)#A=>A`;
      `sum_topology {k::A=>bool | compactin X k} (subtopology X)`] THEN
    ASM_REWRITE_TAC[GSYM K_SPACE_AS_QUOTIENT_EXPLICIT] THEN
    REWRITE_TAC[LOCALLY_COMPACT_SPACE_SUM_TOPOLOGY; IN_ELIM_THM] THEN
    SIMP_TAC[COMPACT_IMP_LOCALLY_COMPACT_SPACE; COMPACT_SPACE_SUBTOPOLOGY];
    MESON_TAC[LOCALLY_COMPACT_IMP_K_SPACE; K_SPACE_QUOTIENT_MAP_IMAGE]]);;

lemma k_space_prod_topology_left:
   "\<And>(X::A topology) (X':B topology).
        locally_compact_space X \<and>
        (Hausdorff_space X \<or> regular_space X) \<and>
        k_space X'
        \<Longrightarrow> k_space(prod_topology X X')"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [K_SPACE_AS_QUOTIENT]) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`q:(B=>bool)#B=>B`; `top'':((B=>bool)#B)topology`] THEN
  STRIP_TAC THEN
  MP_TAC(ISPECL
   [`X::A topology`; `top'':((B=>bool)#B)topology`; `X':B topology`;
    `q:(B=>bool)#B=>B`] QUOTIENT_MAP_PROD_RIGHT) THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] K_SPACE_QUOTIENT_MAP_IMAGE) THEN
  MATCH_MP_TAC LOCALLY_COMPACT_IMP_K_SPACE THEN
  ASM_REWRITE_TAC[LOCALLY_COMPACT_SPACE_PROD_TOPOLOGY]);;

lemma k_space_prod_topology_right:
   "\<And>(X::A topology) (X':B topology).
        k_space X \<and>
        locally_compact_space X' \<and>
        (Hausdorff_space X' \<or> regular_space X')
        \<Longrightarrow> k_space(prod_topology X X')"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [K_SPACE_AS_QUOTIENT]) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`q:(A=>bool)#A=>A`; `top'':((A=>bool)#A)topology`] THEN
  STRIP_TAC THEN
  MP_TAC(ISPECL
   [`top'':((A=>bool)#A)topology`; `X::A topology`; `X':B topology`;
    `q:(A=>bool)#A=>A`] QUOTIENT_MAP_PROD_LEFT) THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] K_SPACE_QUOTIENT_MAP_IMAGE) THEN
  MATCH_MP_TAC LOCALLY_COMPACT_IMP_K_SPACE THEN
  ASM_REWRITE_TAC[LOCALLY_COMPACT_SPACE_PROD_TOPOLOGY]);;

lemma continuous_map_from_k_space:
   "\<And>X X' f.
        k_space X \<and>
        (\<forall>k. compactin X k \<Longrightarrow> continuous_map(subtopology X k,X') f)
        \<Longrightarrow> continuous_map X X' f"
oops
  REWRITE_TAC[K_SPACE] THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC[CONTINUOUS_MAP_CLOSED_IN] THEN
  MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN
  CONJ_TAC THENL
   [X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{x::A}`)) THEN
    ASM_REWRITE_TAC[SING_SUBSET; COMPACT_IN_SING] THEN
    REWRITE_TAC[continuous_map; TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[];
    DISCH_TAC] THEN
  X_GEN_TAC `c::B=>bool` THEN DISCH_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  REWRITE_TAC[SUBSET_RESTRICT] THEN X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   `k \<inter> {x \<in> topspace X. f x \<in> c} =
    {x. x \<in> topspace(subtopology X k) \<and> f x \<in> (f ` k \<inter> c)}`
  SUBST1_TAC THENL
   [REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
  EXISTS_TAC `subtopology X' (image f k)` THEN
  ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED] THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
  SET_TAC[]);;

lemma closed_map_into_k_space:
   "\<And>X X' f.
      k_space X' \<and>
      f ` (topspace X) \<subseteq> topspace X' \<and>
      (\<forall>k. compactin X' k
           \<Longrightarrow> closed_map(subtopology X {x \<in> topspace X. f x \<in> k},
                          subtopology X' k) f)
      \<Longrightarrow> closed_map X X' f"
oops
  REWRITE_TAC[K_SPACE] THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC[closed_map] THEN X_GEN_TAC `c::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN CONJ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN ASM SET_TAC[];
    X_GEN_TAC `k::B=>bool` THEN DISCH_TAC] THEN
  SUBGOAL_THEN
   `k \<inter> f ` c =
    image f ({x \<in> topspace X. f x \<in> k} \<inter> c)`
  SUBST1_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN ASM SET_TAC[];
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::B=>bool`) THEN
  ASM_REWRITE_TAC[closed_map] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED]);;

lemma open_map_into_k_space:
   "\<And>X X' f.
      k_space X' \<and>
      f ` (topspace X) \<subseteq> topspace X' \<and>
      (\<forall>k. compactin X' k
           \<Longrightarrow> open_map(subtopology X {x \<in> topspace X. f x \<in> k},
                        subtopology X' k) f)
      \<Longrightarrow> open_map X X' f"
oops
  REWRITE_TAC[K_SPACE_OPEN] THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC[open_map] THEN X_GEN_TAC `c::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN CONJ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN ASM SET_TAC[];
    X_GEN_TAC `k::B=>bool` THEN DISCH_TAC] THEN
  SUBGOAL_THEN
   `k \<inter> f ` c =
    image f ({x \<in> topspace X. f x \<in> k} \<inter> c)`
  SUBST1_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN ASM SET_TAC[];
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::B=>bool`) THEN
  ASM_REWRITE_TAC[open_map] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN]);;

lemma quotient_map_into_k_space:
   "\<And>X X' f.
     k_space X' \<and>
     continuous_map X X' f \<and>
     f ` (topspace X) = topspace X' \<and>
     (\<forall>k. compactin X' k
          \<Longrightarrow> quotient_map(subtopology X {x \<in> topspace X. f x \<in> k},
                           subtopology X' k) f)
     \<Longrightarrow> quotient_map X X' f"
oops
  REWRITE_TAC[K_SPACE] THEN REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[QUOTIENT_MAP] THEN X_GEN_TAC `c::B=>bool` THEN DISCH_TAC THEN
  EQ_TAC THENL
   [DISCH_TAC; ASM_MESON_TAC[CLOSED_IN_CONTINUOUS_MAP_PREIMAGE]] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `k::B=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::B=>bool`) THEN
  ASM_REWRITE_TAC[QUOTIENT_MAP; TOPSPACE_SUBTOPOLOGY; SUBSET_INTER] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `k \<inter> c::B=>bool` \<circ> CONJUNCT2) THEN
  ANTS_TAC THENL [ASM SET_TAC[]; DISCH_THEN(SUBST1_TAC \<circ> SYM)] THEN
  REWRITE_TAC[SET_RULE
   `{x. x \<in> topspace X \<inter> {x \<in> topspace X. f x \<in> k} \<and>
         f x \<in> k \<inter> c} =
    {x \<in> topspace X. f x \<in> k} \<inter>
    {x \<in> topspace X. f x \<in> c}`] THEN
  ASM_SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED]);;

lemma quotient_map_into_k_space_eq:
   "\<And>X X' f.
        k_space X' \<and> kc_space X'
        \<Longrightarrow> (quotient_map X X' f \<longleftrightarrow>
             continuous_map X X' f \<and>
             f ` (topspace X) = topspace X' \<and>
             \<forall>k. compactin X' k
                  \<Longrightarrow> quotient_map
                       (subtopology X {x \<in> topspace X. f x \<in> k},
                        subtopology X' k) f)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
   [ASM_SIMP_TAC[QUOTIENT_IMP_SURJECTIVE_MAP; QUOTIENT_IMP_CONTINUOUS_MAP] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC QUOTIENT_MAP_RESTRICTION THEN
    RULE_ASSUM_TAC(REWRITE_RULE[kc_space]) THEN ASM_SIMP_TAC[];
    MATCH_MP_TAC QUOTIENT_MAP_INTO_K_SPACE THEN ASM_REWRITE_TAC[]]);;

lemma open_map_into_k_space_eq:
   "\<And>X X' f.
        k_space X'
        \<Longrightarrow> (open_map X X' f \<longleftrightarrow>
             f ` (topspace X) \<subseteq> topspace X' \<and>
             \<forall>k. compactin X' k
                  \<Longrightarrow> open_map
                       (subtopology X {x \<in> topspace X. f x \<in> k},
                        subtopology X' k) f)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_SIMP_TAC[OPEN_MAP_INTO_K_SPACE] THEN
  ASM_SIMP_TAC[OPEN_MAP_IMP_SUBSET_TOPSPACE] THEN
  ASM_SIMP_TAC[OPEN_MAP_RESTRICTION]);;

lemma closed_map_into_k_space_eq:
   "\<And>X X' f.
        k_space X'
        \<Longrightarrow> (closed_map X X' f \<longleftrightarrow>
             f ` (topspace X) \<subseteq> topspace X' \<and>
             \<forall>k. compactin X' k
                  \<Longrightarrow> closed_map
                       (subtopology X {x \<in> topspace X. f x \<in> k},
                        subtopology X' k) f)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_SIMP_TAC[CLOSED_MAP_INTO_K_SPACE] THEN
  ASM_SIMP_TAC[CLOSED_MAP_IMP_SUBSET_TOPSPACE] THEN
  ASM_SIMP_TAC[CLOSED_MAP_RESTRICTION]);;

lemma proper_map_into_k_space:
   "\<And>X X' f.
      k_space X' \<and>
      f ` (topspace X) \<subseteq> topspace X' \<and>
      (\<forall>k. compactin X' k
           \<Longrightarrow> proper_map(subtopology X {x \<in> topspace X. f x \<in> k},
                          subtopology X' k) f)
      \<Longrightarrow> proper_map X X' f"
oops
  REWRITE_TAC[proper_map] THEN REPEAT STRIP_TAC THENL
   [MATCH_MP_TAC CLOSED_MAP_INTO_K_SPACE THEN ASM_SIMP_TAC[];
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `{y::B}`) THEN
    ASM_REWRITE_TAC[COMPACT_IN_SING] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `y::B` \<circ> CONJUNCT2) THEN
    ASM_REWRITE_TAC[IN_ELIM_THM; IN_INTER; TOPSPACE_SUBTOPOLOGY; IN_SING] THEN
    REWRITE_TAC[TAUT  `(p \<and> p \<and> q) \<and> q \<longleftrightarrow> p \<and> q`] THEN
    SIMP_TAC[COMPACT_IN_SUBTOPOLOGY]]);;

lemma proper_map_into_k_space_eq:
   "\<And>X X' f.
        k_space X'
        \<Longrightarrow> (proper_map X X' f \<longleftrightarrow>
             f ` (topspace X) \<subseteq> topspace X' \<and>
             \<forall>k. compactin X' k
                  \<Longrightarrow> proper_map
                       (subtopology X {x \<in> topspace X. f x \<in> k},
                        subtopology X' k) f)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_SIMP_TAC[PROPER_MAP_INTO_K_SPACE] THEN
  ASM_SIMP_TAC[PROPER_MAP_IMP_SUBSET_TOPSPACE] THEN
  ASM_SIMP_TAC[PROPER_MAP_RESTRICTION]);;

lemma compact_imp_proper_map:
   "\<And>X X' f.
        k_space X' \<and> kc_space X' \<and>
        f ` (topspace X) \<subseteq> topspace X' \<and>
        (continuous_map X X' f \<or> kc_space X) \<and>
        (\<forall>k. compactin X' k
             \<Longrightarrow> compactin X {x \<in> topspace X. f x \<in> k})
        \<Longrightarrow> proper_map X X' f"
oops
  REPEAT GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC(REWRITE_RULE[RIGHT_IMP_FORALL_THM; IMP_IMP]
   COMPACT_IMP_PROPER_MAP_GEN) THEN
  ASM_REWRITE_TAC[] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> REWRITE_RULE[K_SPACE]) THEN
  ASM_REWRITE_TAC[] THEN X_GEN_TAC `k::B=>bool` THEN
  DISCH_TAC THEN MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN_GEN THEN
  ASM_SIMP_TAC[KC_SPACE_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[COMPACT_IN_SUBTOPOLOGY; INTER_SUBSET] THEN
  ASM_MESON_TAC[INTER_COMM]);;

lemma proper_eq_compact_map:
   "\<And>X X' f.
        k_space X' \<and> kc_space X' \<and>
        (continuous_map X X' f \<or> kc_space X)
        \<Longrightarrow> (proper_map X X' f \<longleftrightarrow>
             f ` (topspace X) \<subseteq> topspace X' \<and>
             \<forall>k. compactin X' k
                 \<Longrightarrow> compactin X {x \<in> topspace X. f x \<in> k})"
oops
  REPEAT GEN_TAC THEN DISCH_TAC THEN EQ_TAC THENL
   [SIMP_TAC[PROPER_MAP_IMP_SUBSET_TOPSPACE] THEN
    SIMP_TAC[PROPER_MAP_ALT];
    STRIP_TAC THEN MATCH_MP_TAC COMPACT_IMP_PROPER_MAP THEN
    ASM_REWRITE_TAC[]]);;

lemma compact_imp_perfect_map:
   "\<And>X X' f.
        k_space X' \<and> kc_space X' \<and>
        continuous_map X X' f \<and> f ` (topspace X) = topspace X' \<and>
        (\<forall>k. compactin X' k
             \<Longrightarrow> compactin X {x \<in> topspace X. f x \<in> k})
        \<Longrightarrow> perfect_map X X' f"
oops
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[perfect_map] THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
  MATCH_MP_TAC COMPACT_IMP_PROPER_MAP THEN ASM_REWRITE_TAC[]);;


subsection\<open>More generally, the k-ification functor\<close>


let kification = define
 `kification (X::A topology) =
        topology {s. s \<subseteq> topspace X \<and>
                      \<forall>k. compactin X k
                           \<Longrightarrow> openin (subtopology X k) (k \<inter> s)}`;;

lemma openin_kification:
   "\<And>X (u::A=>bool).
        openin (kification X) u \<longleftrightarrow>
        u \<subseteq> topspace X \<and>
        \<forall>k. compactin X k  \<Longrightarrow> openin (subtopology X k) (k \<inter> u)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[kification] THEN
  W(MP_TAC \<circ> fst \<circ> EQ_IMP_RULE \<circ>
      PART_MATCH (lhand \<circ> rand) (CONJUNCT2 topology_tybij) \<circ>
        rator \<circ> lhand \<circ> snd) THEN
  ANTS_TAC THENL [ALL_TAC; SIMP_TAC[IN_ELIM_THM]] THEN
  REWRITE_TAC[istopology; IN_ELIM_THM; INTER_EMPTY; EMPTY_SUBSET] THEN
  SIMP_TAC[OPEN_IN_EMPTY; UNIONS_SUBSET; INTER_UNIONS] THEN CONJ_TAC THEN
  (REPEAT STRIP_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THENL
   [ONCE_REWRITE_TAC[SET_RULE
     `k \<inter> s \<inter> t = (k \<inter> s) \<inter> (k \<inter> t)`] THEN
    ASM_SIMP_TAC[OPEN_IN_INTER];
    MATCH_MP_TAC OPEN_IN_UNIONS THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
    ASM SET_TAC[]]);;

lemma openin_kification_finer:
   "\<And>X (s::A=>bool).
        openin X s \<Longrightarrow> openin (kification X) s"
oops
  SIMP_TAC[OPEN_IN_SUBTOPOLOGY_INTER_OPEN;
           OPEN_IN_KIFICATION; OPEN_IN_SUBSET]);;

lemma topspace_kification:
   "topspace(kification X) = topspace X"
oops
  REPEAT GEN_TAC THEN GEN_REWRITE_TAC LAND_CONV [topspace] THEN
  MATCH_MP_TAC(SET_RULE
   `s \<in> u \<and> (\<forall>t. t \<in> u \<Longrightarrow> t \<subseteq> s) \<Longrightarrow> \<Union> u = s`) THEN
  SIMP_TAC[IN_ELIM_THM; OPEN_IN_KIFICATION; SUBSET_REFL] THEN
  SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; OPEN_IN_SUBTOPOLOGY_REFL;
           SET_RULE `s \<subseteq> u \<Longrightarrow> s \<inter> u = s`]);;

lemma closedin_kification:
   "\<And>X (u::A=>bool).
        closedin (kification X) u \<longleftrightarrow>
        u \<subseteq> topspace X \<and>
        \<forall>k. compactin X k  \<Longrightarrow> closedin (subtopology X k) (k \<inter> u)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[closedin; TOPSPACE_KIFICATION] THEN
  ASM_CASES_TAC `(u::A=>bool) \<subseteq> topspace X` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[OPEN_IN_KIFICATION; TOPSPACE_SUBTOPOLOGY; SUBSET_DIFF] THEN
  ASM_SIMP_TAC[SET_RULE `u \<subseteq> v \<Longrightarrow> k \<inter> u \<subseteq> v \<inter> k`] THEN
  REWRITE_TAC[SET_RULE `u \<inter> k - k \<inter> s = k \<inter> (u - s)`]);;

lemma closedin_kification_finer:
   "\<And>X (s::A=>bool).
        closedin X s \<Longrightarrow> closedin (kification X) s"
oops
  SIMP_TAC[CLOSED_IN_SUBTOPOLOGY_INTER_CLOSED;
           CLOSED_IN_KIFICATION; CLOSED_IN_SUBSET]);;

lemma kification_eq_self:
   "kification X = X \<longleftrightarrow> k_space X"
oops
  REWRITE_TAC[TOPOLOGY_EQ; OPEN_IN_KIFICATION; K_SPACE_ALT] THEN
  MESON_TAC[OPEN_IN_SUBSET]);;

lemma compact_in_kification:
   "\<And>X (k::A=>bool).
        compactin (kification X) k \<longleftrightarrow> compactin X k"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[COMPACT_IN_CONTRACTIVE; OPEN_IN_KIFICATION_FINER;
              TOPSPACE_KIFICATION];
    DISCH_TAC THEN REWRITE_TAC[compactin]] THEN
  ASM_SIMP_TAC[TOPSPACE_KIFICATION; COMPACT_IN_SUBSET_TOPSPACE] THEN
  X_GEN_TAC `U:(A=>bool)->bool` THEN REWRITE_TAC[OPEN_IN_KIFICATION] THEN
  REWRITE_TAC[RIGHT_AND_FORALL_THM; RIGHT_IMP_FORALL_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  GEN_REWRITE_TAC LAND_CONV [SWAP_FORALL_THM] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `k::A=>bool`) THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [COMPACT_IN_SUBSPACE]) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[COMPACT_SPACE] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `image (\<lambda>u::A=>bool. k \<inter> u) U`) THEN
  REWRITE_TAC[FORALL_IN_IMAGE; EXISTS_FINITE_SUBSET_IMAGE] THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET] THEN
  REWRITE_TAC[GSYM SIMPLE_IMAGE; GSYM INTER_UNIONS] THEN
  ASM_REWRITE_TAC[SET_RULE `k \<inter> u = k \<longleftrightarrow> k \<subseteq> u`]);;

lemma compact_space_kification:
   "compact_space(kification X) \<longleftrightarrow> compact_space X"
oops
  REWRITE_TAC[compact_space; COMPACT_IN_KIFICATION; TOPSPACE_KIFICATION]);;

lemma kification_kification:
   "kification(kification X) = kification X"
oops
  REWRITE_TAC[TOPOLOGY_EQ; OPEN_IN_KIFICATION; TOPSPACE_KIFICATION;
              COMPACT_IN_KIFICATION] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN EQ_TAC THENL
   [ALL_TAC; ASM_MESON_TAC[OPEN_IN_KIFICATION_FINER]] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN `t::A=>bool` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [OPEN_IN_KIFICATION]) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `k::A=>bool`)) THEN
  ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN
  MATCH_MP_TAC MONO_EXISTS THEN ASM SET_TAC[]);;

lemma k_space_kification:
   "k_space(kification X)"
oops
  REWRITE_TAC[GSYM KIFICATION_EQ_SELF; KIFICATION_KIFICATION]);;

lemma continuous_map_into_kification:
   "\<And>X X' f.
        k_space X
        \<Longrightarrow> (continuous_map X (kification X') f \<longleftrightarrow>
             continuous_map X X' f)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[continuous_map; TOPSPACE_KIFICATION] THEN
  EQ_TAC THEN SIMP_TAC[OPEN_IN_KIFICATION_FINER] THEN
  STRIP_TAC THEN X_GEN_TAC `v::B=>bool` THEN
  REWRITE_TAC[OPEN_IN_KIFICATION] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (LABEL_TAC "*")) THEN
  FIRST_X_ASSUM(fun th -> GEN_REWRITE_TAC LAND_CONV
    [GSYM(REWRITE_RULE[GSYM KIFICATION_EQ_SELF] th)]) THEN
  REWRITE_TAC[OPEN_IN_KIFICATION; SUBSET_RESTRICT] THEN
  X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
  REMOVE_THEN "*" (MP_TAC \<circ> SPEC `image f k`) THEN ANTS_TAC THENL
   [MATCH_MP_TAC IMAGE_COMPACT_IN THEN EXISTS_TAC `X::A topology` THEN
    ASM_REWRITE_TAC[continuous_map];
    REWRITE_TAC[OPEN_IN_SUBTOPOLOGY; LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `u::B=>bool` THEN STRIP_TAC THEN
  EXISTS_TAC `{x \<in> topspace X. f x \<in> u}` THEN
  ASM_SIMP_TAC[] THEN ASM SET_TAC[]);;

lemma continuous_map_from_kification:
   "\<And>X X' f.
        continuous_map X X' f \<Longrightarrow> continuous_map(kification X,X') f"
oops
  REWRITE_TAC[continuous_map; TOPSPACE_KIFICATION] THEN
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC[OPEN_IN_KIFICATION_FINER]);;

lemma continuous_map_kification:
   "\<And>X X' f.
        continuous_map X X' f
        \<Longrightarrow> continuous_map(kification X,kification X') f"
oops
  SIMP_TAC[CONTINUOUS_MAP_INTO_KIFICATION; K_SPACE_KIFICATION] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FROM_KIFICATION]);;

lemma subtopology_kification_compact:
   "\<And>X (k::A=>bool).
        compactin X k
        \<Longrightarrow> subtopology (kification X) k = subtopology X k"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[TOPOLOGY_EQ; OPEN_IN_SUBTOPOLOGY] THEN
  X_GEN_TAC `u::A=>bool` THEN EQ_TAC THENL
   [ALL_TAC; MESON_TAC[OPEN_IN_KIFICATION_FINER]] THEN
  REWRITE_TAC[OPEN_IN_KIFICATION] THEN
  DISCH_THEN(X_CHOOSE_THEN `t::A=>bool` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN
  ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN
  MESON_TAC[INTER_COMM]);;

lemma subtopology_kification_finer:
   "\<And>X (s::A=>bool) u.
        openin (subtopology (kification X) s) u
        \<Longrightarrow> openin (kification (subtopology X s)) u"
oops
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; FORALL_IN_GSPEC] THEN
  REPEAT GEN_TAC THEN
  REWRITE_TAC[OPEN_IN_KIFICATION; TOPSPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN
  STRIP_TAC THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `k::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN MATCH_MP_TAC MONO_EXISTS THEN
  SET_TAC[]);;

lemma proper_map_from_kification:
   "\<And>X X' f.
        k_space X'
        \<Longrightarrow> (proper_map(kification X,X') f \<longleftrightarrow>
             proper_map X X' f)"
oops
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC[PROPER_MAP_INTO_K_SPACE_EQ] THEN
  REWRITE_TAC[TOPSPACE_KIFICATION; PROPER_MAP_ALT] THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY; COMPACT_IN_KIFICATION;
              TOPSPACE_SUBTOPOLOGY; IN_ELIM_THM; IN_INTER;
              TOPSPACE_KIFICATION] THEN
  MATCH_MP_TAC(MESON[]
   `(P \<and> (\<forall>k. Q k \<Longrightarrow> S k) \<Longrightarrow> (\<forall>k. Q k \<Longrightarrow> (R k \<longleftrightarrow> R' k)))
    \<Longrightarrow> (P \<and> (\<forall>k. Q k \<Longrightarrow> R k \<and> S k) \<longleftrightarrow>
         P \<and> (\<forall>k. Q k \<Longrightarrow> R' k \<and> S k))`) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> MATCH_MP (MESON[]
   `(\<forall>x. P x \<Longrightarrow> (\<forall>y. P y \<and> Q x y \<Longrightarrow> R x y))
    \<Longrightarrow> (\<forall>x. P x \<and> Q x x \<Longrightarrow> R x x)`))) THEN
  REWRITE_TAC[TAUT `(p \<and> p \<and> q) \<and> q \<longleftrightarrow> p \<and> q`; SUBSET_REFL] THEN
  SIMP_TAC[SUBTOPOLOGY_KIFICATION_COMPACT]);;

lemma perfect_map_from_kification:
   "\<And>X X' f.
        k_space X' \<and> perfect_map X X' f
        \<Longrightarrow> perfect_map(kification X,X') f"
oops
  SIMP_TAC[perfect_map; PROPER_MAP_FROM_KIFICATION;
           CONTINUOUS_MAP_FROM_KIFICATION; TOPSPACE_KIFICATION]);;

lemma k_space_perfect_map_image_eq:
   "\<And>X X' f.
     Hausdorff_space X \<and> perfect_map X X' f
     \<Longrightarrow> (k_space X \<longleftrightarrow> k_space X')"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_MESON_TAC[K_SPACE_PERFECT_MAP_IMAGE]; DISCH_TAC] THEN
  MP_TAC(ISPECL [`kification X::A topology`; `X::A topology`]
        HOMEOMORPHIC_K_SPACE) THEN
  ASM_REWRITE_TAC[HOMEOMORPHIC_SPACE; K_SPACE_KIFICATION] THEN
  DISCH_THEN MATCH_MP_TAC THEN EXISTS_TAC `\<lambda>x::A. x` THEN
  REWRITE_TAC[HOMEOMORPHIC_EQ_INJECTIVE_PERFECT_MAP] THEN
  MP_TAC(ISPECL
   [`kification X::A topology`; `X::A topology`; `X':B topology`;
    `\<lambda>x::A. x`; `f::A=>B`] PERFECT_MAP_FROM_COMPOSITION_RIGHT) THEN
  DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[o_DEF; ETA_AX; IMAGE_ID; TOPSPACE_KIFICATION] THEN
  ASM_SIMP_TAC[PERFECT_MAP_FROM_KIFICATION] THEN
  SIMP_TAC[CONTINUOUS_MAP_FROM_KIFICATION; CONTINUOUS_MAP_ID] THEN
  ASM_SIMP_TAC[PERFECT_IMP_CONTINUOUS_MAP]);;


subsection\<open>One-point compactifications and the Alexandroff extension construction\<close>


lemma one_point_compactification_dense:
   "        compact_space X \<and> \<not> compactin X (topspace X - {a})
        \<Longrightarrow> X closure_of (topspace X - {a}) = topspace X"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `(a::A) \<in> topspace X` THENL
   [STRIP_TAC;
    ASM_MESON_TAC[compact_space; SET_RULE `(a \<notin> s) \<Longrightarrow> s - {a} = s`]] THEN
  MATCH_MP_TAC(SET_RULE
   `u - {a} \<subseteq> s \<and> s \<subseteq> u \<and> (s \<noteq> u - {a}) \<Longrightarrow> s = u`) THEN
  REWRITE_TAC[CLOSURE_OF_EQ; CLOSURE_OF_SUBSET_TOPSPACE] THEN
  ASM_SIMP_TAC[CLOSURE_OF_SUBSET; DELETE_SUBSET] THEN
  ASM_MESON_TAC[CLOSED_IN_COMPACT_SPACE]);;

lemma one_point_compactification_interior:
   "        compact_space X \<and> \<not> compactin X (topspace X - {a})
        \<Longrightarrow> X interior_of {a} = {}"
oops
  REWRITE_TAC[INTERIOR_OF_CLOSURE_OF; SET_RULE `s - {a} = s - {a}`] THEN
  SIMP_TAC[ONE_POINT_COMPACTIFICATION_DENSE; DIFF_EQ_EMPTY]);;

lemma kc_space_one_point_compactification_gen:
   "        compact_space X
        \<Longrightarrow> (kc_space X \<longleftrightarrow>
             openin X (topspace X - {a}) \<and>
             (\<forall>k. compactin X k \<and> (a \<notin> k) \<Longrightarrow> closedin X k) \<and>
             k_space (subtopology X (topspace X - {a})) \<and>
             kc_space (subtopology X (topspace X - {a})))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_TAC THEN CONJ_TAC THENL
     [ASM_MESON_TAC[T1_SPACE_OPEN_IN_DELETE_ALT; KC_IMP_T1_SPACE;
                    OPEN_IN_TOPSPACE];
      ALL_TAC] THEN
    CONJ_TAC THENL [ASM_MESON_TAC[kc_space]; ALL_TAC] THEN
    MATCH_MP_TAC K_KC_SPACE_SUBTOPOLOGY THEN
    ASM_SIMP_TAC[COMPACT_IMP_K_SPACE] THEN DISJ1_TAC THEN
    ASM_MESON_TAC[T1_SPACE_OPEN_IN_DELETE_ALT; KC_IMP_T1_SPACE;
                  OPEN_IN_TOPSPACE];
    STRIP_TAC] THEN
  REWRITE_TAC[kc_space] THEN X_GEN_TAC `s::A=>bool` THEN DISCH_TAC THEN
  ASM_CASES_TAC `(a::A) \<in> s` THEN ASM_SIMP_TAC[] THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
  ASM_REWRITE_TAC[closedin] THEN
  SUBGOAL_THEN
   `topspace X - s::A=>bool =
    (topspace X - {a}) - (s - {a})`
  SUBST1_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  MATCH_MP_TAC OPEN_IN_TRANS_FULL THEN
  EXISTS_TAC `topspace X DELETE (a::A)` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC OPEN_IN_DIFF THEN
  ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; SUBSET_REFL] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [K_SPACE]) THEN
  REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY; SUBTOPOLOGY_SUBTOPOLOGY;
              TOPSPACE_SUBTOPOLOGY; SUBSET_INTER; SUBSET_DELETE] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `k::A=>bool` THEN STRIP_TAC THEN
  MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN
  CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ASM_SIMP_TAC[SET_RULE `(a \<notin> k) \<Longrightarrow> k \<inter> s - {a} = k \<inter> s`] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[IN_INTER] THEN
  MATCH_MP_TAC CLOSED_INTER_COMPACT_IN THEN ASM_SIMP_TAC[]);;

let alexandroff_compactification = new_definition
 `alexandroff_compactification (X::A topology) =
        topology ({ INL ` u | openin X u} \<union>
                  { INR () insert image INL (topspace X - c) | c |
                    compactin X c \<and> closedin X c})`;;

lemma openin_alexandroff_compactification:
   "\<And>(X::A topology) v.
        openin(alexandroff_compactification X) v \<longleftrightarrow>
        (\<exists>u. openin X u \<and> v = INL ` u) \<or>
        (\<exists>c. compactin X c \<and> closedin X c \<and>
             v = INR () insert image INL (topspace X - c))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[alexandroff_compactification] THEN
  W(MP_TAC \<circ> fst \<circ> EQ_IMP_RULE \<circ>
    PART_MATCH (lhand \<circ> rand) (CONJUNCT2 topology_tybij) \<circ>
    rator \<circ> lhand \<circ> snd) THEN
  ANTS_TAC THENL
   [ALL_TAC;
    DISCH_THEN SUBST1_TAC THEN GEN_REWRITE_TAC LAND_CONV [GSYM \<in>] THEN
    REWRITE_TAC[IN_UNION; IN_ELIM_THM] THEN MESON_TAC[]] THEN
  REWRITE_TAC[istopology] THEN REPEAT CONJ_TAC THENL
   [REWRITE_TAC[IN_UNION; IN_ELIM_THM] THEN DISJ1_TAC THEN
    REWRITE_TAC[SET_RULE `P \<and> {} = f ` s \<longleftrightarrow> s = {} \<and> P`] THEN
    REWRITE_TAC[UNWIND_THM2; OPEN_IN_EMPTY];
    MATCH_MP_TAC(SET_RULE
     `(\<forall>x y. R x y \<Longrightarrow> R y x) \<and>
      (\<forall>x y. x \<in> s \<and> y \<in> s \<Longrightarrow> R x y) \<and>
      (\<forall>x y. x \<in> s \<and> y \<in> t \<Longrightarrow> R x y) \<and>
      (\<forall>x y. x \<in> t \<and> y \<in> t \<Longrightarrow> R x y)
      \<Longrightarrow> \<forall>x y. x \<in> (s \<union> t) \<and> y \<in> (s \<union> t) \<Longrightarrow> R x y`) THEN
    CONJ_TAC THENL [MESON_TAC[INTER_COMM]; ALL_TAC] THEN
    REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; FORALL_IN_GSPEC] THEN
    REPEAT CONJ_TAC THENL
     [X_GEN_TAC `u::A=>bool` THEN DISCH_TAC THEN
      X_GEN_TAC `v::A=>bool` THEN DISCH_TAC THEN
      REWRITE_TAC[IN_UNION; IN_ELIM_THM] THEN DISJ1_TAC THEN
      EXISTS_TAC `u \<inter> v::A=>bool` THEN
      ASM_SIMP_TAC[OPEN_IN_INTER] THEN CONV_TAC SYM_CONV THEN
      MATCH_MP_TAC IMAGE_INTER_INJ THEN REWRITE_TAC[sum_INJECTIVE];
      X_GEN_TAC `u::A=>bool` THEN DISCH_TAC THEN
      X_GEN_TAC `c::A=>bool` THEN REPEAT DISCH_TAC THEN
      REWRITE_TAC[IN_UNION; IN_ELIM_THM] THEN DISJ1_TAC THEN
      EXISTS_TAC `u - c::A=>bool` THEN ASM_SIMP_TAC[OPEN_IN_DIFF] THEN
      REWRITE_TAC[EXTENSION; IN_IMAGE; IN_INTER; IN_INSERT] THEN
      MATCH_MP_TAC sum_INDUCT THEN
      REWRITE_TAC[IN_DIFF; sum_DISTINCT; sum_INJECTIVE; UNWIND_THM1] THEN
      ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET];
      X_GEN_TAC `c::A=>bool` THEN REPEAT DISCH_TAC THEN
      X_GEN_TAC `d::A=>bool` THEN REPEAT DISCH_TAC THEN
      REWRITE_TAC[IN_UNION; IN_ELIM_THM] THEN DISJ2_TAC THEN
      EXISTS_TAC `c \<union> d::A=>bool` THEN
      ASM_SIMP_TAC[CLOSED_IN_UNION; COMPACT_IN_UNION] THEN
      REWRITE_TAC[EXTENSION; IN_IMAGE; IN_INTER; IN_INSERT; IN_UNION] THEN
      MATCH_MP_TAC sum_INDUCT THEN
      REWRITE_TAC[IN_DIFF; sum_DISTINCT; sum_INJECTIVE; UNWIND_THM1] THEN
      SET_TAC[]];
    REWRITE_TAC[FORALL_SUBSET_UNION] THEN
    REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
    ONCE_REWRITE_TAC[SIMPLE_IMAGE_GEN] THEN
    REWRITE_TAC[FORALL_SUBSET_IMAGE] THEN
    REWRITE_TAC[SET_RULE `s \<subseteq> {x. P x} \<longleftrightarrow> \<forall>x. x \<in> s \<Longrightarrow> P x`] THEN
    X_GEN_TAC `uu:(A=>bool)->bool` THEN DISCH_TAC THEN
    X_GEN_TAC `cc:(A=>bool)->bool` THEN DISCH_TAC THEN
    ASM_CASES_TAC `cc:(A=>bool)->bool = {}` THENL
     [ASM_REWRITE_TAC[IMAGE_CLAUSES; UNION_EMPTY] THEN
      REWRITE_TAC[IN_UNION; IN_IMAGE] THEN DISJ1_TAC THEN
      EXISTS_TAC `\<Union> uu::A=>bool` THEN
      ASM_SIMP_TAC[IN_ELIM_THM; OPEN_IN_UNIONS] THEN
      REWRITE_TAC[UNIONS_IMAGE] THEN SET_TAC[];
      REWRITE_TAC[IN_UNION; IN_IMAGE] THEN DISJ2_TAC THEN EXISTS_TAC
       `\<Inter>(cc \<union> image (\<lambda>u. topspace X - u) uu):A=>bool` THEN
      CONJ_TAC THENL
       [REWRITE_TAC[EXTENSION] THEN MATCH_MP_TAC sum_INDUCT THEN
        REWRITE_TAC[IN_IMAGE; IN_DIFF; IN_INTERS; IN_INSERT;
                    IN_UNIONS; IN_UNION; IN_UNIV] THEN
        REWRITE_TAC[sum_DISTINCT; sum_INJECTIVE] THEN
        REWRITE_TAC[RIGHT_OR_DISTRIB; EXISTS_OR_THM; UNWIND_THM1] THEN
        REWRITE_TAC[LEFT_AND_EXISTS_THM; GSYM CONJ_ASSOC] THEN
        ONCE_REWRITE_TAC[SWAP_EXISTS_THM] THEN REWRITE_TAC[UNWIND_THM2] THEN
        REWRITE_TAC[IN_IMAGE; IN_UNIV; IN_DIFF; IN_INSERT] THEN
        REWRITE_TAC[sum_DISTINCT; sum_INJECTIVE] THEN
        CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
        REWRITE_TAC[TAUT `p \<or> q \<Longrightarrow> r \<longleftrightarrow> (p \<Longrightarrow> r) \<and> (q \<Longrightarrow> r)`] THEN
        X_GEN_TAC `a::A` THEN REWRITE_TAC[FORALL_AND_THM; UNWIND_THM1] THEN
        ASM_CASES_TAC `(a::A) \<in> topspace X` THEN ASM_REWRITE_TAC[] THENL
         [ALL_TAC; ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]] THEN
        ONCE_REWRITE_TAC[TAUT `\<not> (p \<and> q) \<longleftrightarrow> \<not> q \<or> \<not> p`] THEN
        BINOP_TAC THENL [ALL_TAC; MESON_TAC[]] THEN
        REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; LEFT_AND_EXISTS_THM] THEN
        ONCE_REWRITE_TAC[SWAP_EXISTS_THM] THEN
        REWRITE_TAC[GSYM CONJ_ASSOC; UNWIND_THM2; IN_DIFF] THEN
        ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET];
        FIRST_X_ASSUM(X_CHOOSE_TAC `c::A=>bool` \<circ>
          REWRITE_RULE[GSYM MEMBER_NOT_EMPTY]) THEN
        SUBGOAL_THEN `cc = (c::A=>bool) insert cc` SUBST1_TAC THENL
         [ASM SET_TAC[];
          REWRITE_TAC[INTERS_INSERT; SET_RULE
           `(insert x s) \<union> t = x insert (s \<union> t)`]] THEN
        REWRITE_TAC[IN_ELIM_THM] THEN MATCH_MP_TAC
         (MESON[CLOSED_IN_INTER; COMPACT_INTER_CLOSED_IN]
           `closedin X c \<and> compactin X c \<and> closedin X d
            \<Longrightarrow> compactin X (c \<inter> d) \<and> closedin X (c \<inter> d)`) THEN
        ASM_SIMP_TAC[] THEN MATCH_MP_TAC CLOSED_IN_INTERS THEN
        CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[FORALL_IN_UNION]] THEN
        ASM_SIMP_TAC[FORALL_IN_IMAGE; CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE]]]]);;

lemma topspace_alexandroff_compactification:
   "        topspace(alexandroff_compactification X) =
        INR () insert image INL (topspace X)"
oops
  GEN_TAC THEN GEN_REWRITE_TAC LAND_CONV [topspace] THEN MATCH_MP_TAC(SET_RULE
   `u \<in> s \<and> (\<forall>c. c \<in> s \<Longrightarrow> c \<subseteq> u) \<Longrightarrow> \<Union> s = u`) THEN
  REWRITE_TAC[FORALL_IN_GSPEC; OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  REWRITE_TAC[IN_ELIM_THM] THEN CONJ_TAC THENL
   [MESON_TAC[COMPACT_IN_EMPTY; CLOSED_IN_EMPTY; DIFF_EMPTY]; ALL_TAC] THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN SET_TAC[]);;

lemma closedin_alexandroff_compactification:
   "\<And>(X::A topology) c.
        closedin (alexandroff_compactification X) c \<longleftrightarrow>
        (\<exists>k. compactin X k \<and> closedin X k \<and> c = INL ` k) \<or>
        (\<exists>u. openin X u \<and>
             c = topspace(alexandroff_compactification X) - INL ` u)"
oops
  REPEAT GEN_TAC THEN GEN_REWRITE_TAC LAND_CONV [closedin] THEN
  REWRITE_TAC[OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  MATCH_MP_TAC(TAUT
   `(q' \<Longrightarrow> p) \<and> (r' \<Longrightarrow> p) \<and> (p \<Longrightarrow> (q \<longleftrightarrow> q') \<and> (r \<longleftrightarrow> r'))
    \<Longrightarrow> (p \<and> (q \<or> r) \<longleftrightarrow> r' \<or> q')`) THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  CONJ_TAC THENL [SET_TAC[]; ALL_TAC] THEN
  CONJ_TAC THENL [REWRITE_TAC[closedin] THEN SET_TAC[]; ALL_TAC] THEN
  REPEAT STRIP_TAC THEN AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `s::A=>bool` THEN REWRITE_TAC[] THEN
  REPEAT(MATCH_MP_TAC(TAUT `(p \<Longrightarrow> (q \<longleftrightarrow> r)) \<Longrightarrow> (p \<and> q \<longleftrightarrow> p \<and> r)`) THEN
         DISCH_TAC)
  THENL
   [FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP OPEN_IN_SUBSET);
    FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)] THEN
  REWRITE_TAC[EXTENSION; FORALL_SUM_THM; FORALL_ONE_THM] THEN
  REWRITE_TAC[IN_INSERT; IN_DIFF; IN_IMAGE] THEN
  REWRITE_TAC[sum_DISTINCT; sum_INJECTIVE; UNWIND_THM1] THEN
  MP_TAC(INST_TYPE [`:1`,`:B`] sum_DISTINCT) THEN
  MP_TAC(INST_TYPE [`:1`,`:B`] sum_INJECTIVE) THEN
  ASM SET_TAC[]);;

lemma closedin_alexandroff_compactification_image_inl:
   "\<And>(X::A topology) k.
        closedin (alexandroff_compactification X) (INL ` k) \<longleftrightarrow>
        compactin X k \<and> closedin X k"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  MATCH_MP_TAC(TAUT `(p' \<longleftrightarrow> p) \<and> \<not> q \<Longrightarrow> (p \<or> q \<longleftrightarrow> p')`) THEN
  SIMP_TAC[MATCH_MP (SET_RULE
   `(\<forall>x y. f x = f y \<longleftrightarrow> x = y) \<Longrightarrow> (f ` s = f ` t \<longleftrightarrow> s = t)`)
   (CONJUNCT1 sum_INJECTIVE)] THEN
  CONJ_TAC THENL [MESON_TAC[]; ALL_TAC] THEN
  MP_TAC(INST_TYPE [`:1`,`:B`] sum_DISTINCT) THEN SET_TAC[]);;

lemma open_map_inl:
   "open_map X (alexandroff_compactification X) INL"
oops
  REWRITE_TAC[open_map; OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  MESON_TAC[]);;

lemma continuous_map_inl:
   "continuous_map X (alexandroff_compactification X) INL"
oops
  REWRITE_TAC[continuous_map; OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION; IN_INSERT] THEN
  GEN_TAC THEN SIMP_TAC[FUN_IN_IMAGE] THEN X_GEN_TAC `v::A+1=>bool` THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[IN_INSERT; IN_IMAGE] THEN
  REWRITE_TAC[sum_DISTINCT; sum_INJECTIVE; UNWIND_THM1] THEN
  REWRITE_TAC[SET_RULE `x \<in> s \<and> x \<in> s - t \<longleftrightarrow> x \<in> s - t`] THEN
  ASM_SIMP_TAC[SET_RULE `s \<subseteq> t \<Longrightarrow> (x \<in> t \<and> x \<in> s \<longleftrightarrow> x \<in> s)`;
               OPEN_IN_SUBSET; IN_GSPEC; OPEN_IN_DIFF; OPEN_IN_TOPSPACE]);;

lemma embedding_map_inl:
   "embedding_map X (alexandroff_compactification X) INL"
oops
  GEN_TAC THEN MATCH_MP_TAC INJECTIVE_OPEN_IMP_EMBEDDING_MAP THEN
  REWRITE_TAC[CONTINUOUS_MAP_INL; OPEN_MAP_INL; sum_INJECTIVE]);;

lemma compact_space_alexandroff_compactification:
   "compact_space(alexandroff_compactification X)"
oops
  GEN_TAC THEN REWRITE_TAC[COMPACT_SPACE_ALT] THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  X_GEN_TAC `uu:(A+1=>bool)->bool` THEN
  REWRITE_TAC[INSERT_SUBSET] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_UNIONS]) THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A+1=>bool` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   `compactin (alexandroff_compactification(X::A topology))
               (topspace(alexandroff_compactification X) - u)`
  MP_TAC THENL
   [SUBGOAL_THEN
     `\<exists>c. compactin X c \<and> closedin X c \<and>
          topspace(alexandroff_compactification X) - u =
          image INL (c::A=>bool)`
    STRIP_ASSUME_TAC THENL
     [ALL_TAC; ASM_MESON_TAC[IMAGE_COMPACT_IN; CONTINUOUS_MAP_INL]] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `u::A+1=>bool`) THEN
    ASM_REWRITE_TAC[OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
    DISCH_THEN(DISJ_CASES_THEN MP_TAC) THENL
     [STRIP_TAC THEN UNDISCH_TAC `INR () \<in> (u::A+1=>bool)` THEN
      ASM_REWRITE_TAC[IN_IMAGE; sum_DISTINCT];
      MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `c::A=>bool` THEN STRIP_TAC THEN
      ASM_REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
      MATCH_MP_TAC(SET_RULE
       `c \<subseteq> s \<and> (\<forall>x. (z \<noteq> f x)) \<and> (\<forall>x y. f x = f y \<longleftrightarrow> x = y)
        \<Longrightarrow> (insert z f ` s) - (insert z image f (s - c)) =
            f ` c`) THEN
      ASM_SIMP_TAC[CLOSED_IN_SUBSET; sum_DISTINCT; sum_INJECTIVE]];
    REWRITE_TAC[compactin; SUBSET_DIFF] THEN
    ASM_REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `uu:(A+1=>bool)->bool`) THEN ANTS_TAC THENL
     [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN `vv:(A+1=>bool)->bool` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(u::A+1=>bool) insert vv` THEN
    ASM_REWRITE_TAC[FINITE_INSERT] THEN ASM SET_TAC[]]);;

lemma topspace_alexandroff_compactification_delete:
   "        topspace(alexandroff_compactification X) DELETE (INR ()) =
        image INL (topspace X)"
oops
  GEN_TAC THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  REWRITE_TAC[SET_RULE `(insert a s) - {a} = s \<longleftrightarrow> (a \<notin> s)`] THEN
  REWRITE_TAC[IN_IMAGE; sum_DISTINCT]);;

lemma alexandroff_compactification_dense:
   "        \<not> compact_space X
        \<Longrightarrow> (alexandroff_compactification X)
            closure_of (image INL (topspace X)) =
            topspace(alexandroff_compactification X)"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[GSYM TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
  MATCH_MP_TAC ONE_POINT_COMPACTIFICATION_DENSE THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  POP_ASSUM MP_TAC THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
  REWRITE_TAC[CONTRAPOS_THM; COMPACT_IN_SUBSPACE] THEN
  DISCH_THEN(MP_TAC \<circ> CONJUNCT2) THEN MATCH_MP_TAC EQ_IMP THEN
  MATCH_MP_TAC HOMEOMORPHIC_COMPACT_SPACE THEN
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
  MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
  REWRITE_TAC[EMBEDDING_MAP_INL]);;

lemma t0_space_one_point_compactification:
   "        compact_space X \<and>
        openin X (topspace X - {a})
        \<Longrightarrow> (t0_space X \<longleftrightarrow>
             t0_space (subtopology X (topspace X - {a})))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN REWRITE_TAC[T0_SPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[t0_space; TOPSPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[SET_RULE `s \<inter> s - {a} = s - {a}`] THEN
  ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; IN_DELETE; SUBSET_DELETE] THEN
  DISCH_TAC THEN MATCH_MP_TAC(MESON[]
   `(\<forall>x y. R x y \<Longrightarrow> R y x) \<and>
    (\<exists>a. (\<forall>x y. (P x \<and> (x \<noteq> a)) \<and> (P y \<and> (y \<noteq> a)) \<and> (x \<noteq> y) \<Longrightarrow> R x y) \<and>
         (\<forall>x. P x \<and> (x \<noteq> a) \<Longrightarrow> R a x))
    \<Longrightarrow> \<forall>x y. P x \<and> P y \<and> (x \<noteq> y) \<Longrightarrow> R x y`) THEN
  CONJ_TAC THENL [MESON_TAC[]; EXISTS_TAC `a::A`] THEN
  CONJ_TAC THENL [ASM_METIS_TAC[]; REPEAT STRIP_TAC] THEN
  EXISTS_TAC `topspace X DELETE (a::A)` THEN
  ASM_REWRITE_TAC[IN_DELETE]);;

lemma t0_space_alexandroff_compactification:
   "        t0_space(alexandroff_compactification X) \<longleftrightarrow>
        t0_space X"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   T0_SPACE_ONE_POINT_COMPACTIFICATION) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN ANTS_TAC THENL
   [REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    MESON_TAC[open_map; OPEN_IN_TOPSPACE; OPEN_MAP_INL];
    DISCH_THEN SUBST1_TAC THEN
    REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    MATCH_MP_TAC HOMEOMORPHIC_T0_SPACE THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
    REWRITE_TAC[EMBEDDING_MAP_INL]]);;

lemma t1_space_one_point_compactification:
   "        openin X (topspace X - {a}) \<and>
        (\<forall>k. compactin (subtopology X (topspace X - {a})) k \<and>
             closedin (subtopology X (topspace X - {a})) k
             \<Longrightarrow> closedin X k)
        \<Longrightarrow> (t1_space X \<longleftrightarrow>
             t1_space (subtopology X (topspace X - {a})))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN REWRITE_TAC[T1_SPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[T1_SPACE_CLOSED_IN_SING] THEN
  DISCH_TAC THEN X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  ASM_CASES_TAC `x::A = a` THENL
   [ASM_REWRITE_TAC[closedin; SING_SUBSET] THEN
    ASM_REWRITE_TAC[SET_RULE `s - {a} = s - {a}`];
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    REWRITE_TAC[COMPACT_IN_SING; TOPSPACE_SUBTOPOLOGY] THEN
    ASM_REWRITE_TAC[IN_INTER; IN_DELETE] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_DELETE]]);;

lemma t1_space_alexandroff_compactification:
   "        t1_space(alexandroff_compactification X) \<longleftrightarrow>
        t1_space X"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   T1_SPACE_ONE_POINT_COMPACTIFICATION) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN ANTS_TAC THENL
   [SIMP_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN CONJ_TAC THENL
     [MESON_TAC[open_map; OPEN_IN_TOPSPACE; OPEN_MAP_INL]; ALL_TAC] THEN
    ONCE_REWRITE_TAC[MESON[COMPACT_IN_SUBTOPOLOGY]
     `(compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k) \<longleftrightarrow>
      (k \<subseteq> u \<Longrightarrow> compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k)`] THEN
    REWRITE_TAC[FORALL_SUBSET_IMAGE] THEN
    X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    GEN_REWRITE_TAC RAND_CONV
     [CLOSED_IN_ALEXANDROFF_COMPACTIFICATION_IMAGE_INL] THEN
    MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_MAP_COMPACTNESS;
      MATCH_MP_TAC HOMEOMORPHIC_MAP_CLOSEDNESS] THEN
    ASM_REWRITE_TAC[GSYM embedding_map; EMBEDDING_MAP_INL];
    DISCH_THEN SUBST1_TAC THEN
    REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    MATCH_MP_TAC HOMEOMORPHIC_T1_SPACE THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
    REWRITE_TAC[EMBEDDING_MAP_INL]]);;

lemma kc_space_one_point_compactification:
   "        compact_space X \<and>
        openin X (topspace X - {a}) \<and>
        (\<forall>k. compactin (subtopology X (topspace X - {a})) k \<and>
             closedin (subtopology X (topspace X - {a})) k
             \<Longrightarrow> closedin X k)
        \<Longrightarrow> (kc_space X \<longleftrightarrow>
             k_space (subtopology X (topspace X - {a})) \<and>
             kc_space (subtopology X (topspace X - {a})))"
oops
  SIMP_TAC[KC_SPACE_ONE_POINT_COMPACTIFICATION_GEN] THEN
  REWRITE_TAC[kc_space; COMPACT_IN_SUBTOPOLOGY; SUBSET_DELETE] THEN
  MESON_TAC[COMPACT_IN_SUBSET_TOPSPACE]);;

lemma kc_space_alexandroff_compactification:
   "        kc_space(alexandroff_compactification X) \<longleftrightarrow>
        k_space X \<and> kc_space X"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   KC_SPACE_ONE_POINT_COMPACTIFICATION) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN ANTS_TAC THENL
   [SIMP_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN CONJ_TAC THENL
     [MESON_TAC[open_map; OPEN_IN_TOPSPACE; OPEN_MAP_INL]; ALL_TAC] THEN
    ONCE_REWRITE_TAC[MESON[COMPACT_IN_SUBTOPOLOGY]
     `(compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k) \<longleftrightarrow>
      (k \<subseteq> u \<Longrightarrow> compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k)`] THEN
    REWRITE_TAC[FORALL_SUBSET_IMAGE] THEN
    X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    GEN_REWRITE_TAC RAND_CONV
     [CLOSED_IN_ALEXANDROFF_COMPACTIFICATION_IMAGE_INL] THEN
    MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_MAP_COMPACTNESS;
      MATCH_MP_TAC HOMEOMORPHIC_MAP_CLOSEDNESS] THEN
    ASM_REWRITE_TAC[GSYM embedding_map; EMBEDDING_MAP_INL];
    DISCH_THEN SUBST1_TAC THEN
    REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_K_SPACE;
      MATCH_MP_TAC HOMEOMORPHIC_KC_SPACE] THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
    REWRITE_TAC[EMBEDDING_MAP_INL]]);;

lemma regular_space_one_point_compactification:
   "        compact_space X \<and>
        openin X (topspace X - {a}) \<and>
        (\<forall>k. compactin (subtopology X (topspace X - {a})) k \<and>
             closedin (subtopology X (topspace X - {a})) k
             \<Longrightarrow> closedin X k)
        \<Longrightarrow> (regular_space X \<longleftrightarrow>
             regular_space (subtopology X (topspace X - {a})) \<and>
             locally_compact_space (subtopology X (topspace X - {a})))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [SIMP_TAC[REGULAR_SPACE_SUBTOPOLOGY] THEN
    ASM_MESON_TAC[LOCALLY_COMPACT_SPACE_OPEN_SUBSET;
                  COMPACT_IMP_LOCALLY_COMPACT_SPACE];
    STRIP_TAC] THEN
  REWRITE_TAC[GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN] THEN
  REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `x::A`] THEN
  ASM_CASES_TAC `x::A = a` THEN ASM_REWRITE_TAC[] THEN STRIP_TAC THENL
   [MP_TAC(ISPEC `subtopology X (topspace X DELETE (a::A))`
        LOCALLY_COMPACT_SPACE_COMPACT_CLOSED_COMPACT) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `topspace X - u::A=>bool`) THEN ANTS_TAC THENL
     [REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN
      CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
      MATCH_MP_TAC CLOSED_IN_COMPACT_SPACE THEN
      ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE];
      ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; SUBSET_DIFF; SUBSET_DELETE;
                   COMPACT_IN_SUBTOPOLOGY; LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [`v::A=>bool`; `k::A=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `k::A=>bool`) THEN
    ASM_SIMP_TAC[COMPACT_IN_SUBTOPOLOGY; SUBSET_DELETE] THEN DISCH_TAC THEN
    MAP_EVERY EXISTS_TAC
     [`topspace X - k::A=>bool`; `topspace X - v::A=>bool`] THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; CLOSED_IN_DIFF; OPEN_IN_TOPSPACE;
                 CLOSED_IN_TOPSPACE] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN ASM SET_TAC[];
    MP_TAC(ISPEC `subtopology X (topspace X DELETE (a::A))`
        LOCALLY_COMPACT_REGULAR_SPACE_NEIGHBOURHOOD_BASE) THEN
    ASM_REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN DISCH_THEN(MP_TAC \<circ> SPECL
     [`(topspace X DELETE (a::A)) \<inter> u`; `x::A`]) THEN
    ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; SUBSET_DELETE;
                 OPEN_IN_INTER; IN_INTER; IN_DELETE] THEN
    FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN ASM SET_TAC[]]);;

lemma regular_space_alexandroff_compactification:
   "        regular_space(alexandroff_compactification X) \<longleftrightarrow>
        regular_space X \<and> locally_compact_space X"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   REGULAR_SPACE_ONE_POINT_COMPACTIFICATION) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN ANTS_TAC THENL
   [SIMP_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN CONJ_TAC THENL
     [MESON_TAC[open_map; OPEN_IN_TOPSPACE; OPEN_MAP_INL]; ALL_TAC] THEN
    ONCE_REWRITE_TAC[MESON[COMPACT_IN_SUBTOPOLOGY]
     `(compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k) \<longleftrightarrow>
      (k \<subseteq> u \<Longrightarrow> compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k)`] THEN
    REWRITE_TAC[FORALL_SUBSET_IMAGE] THEN
    X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    GEN_REWRITE_TAC RAND_CONV
     [CLOSED_IN_ALEXANDROFF_COMPACTIFICATION_IMAGE_INL] THEN
    MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_MAP_COMPACTNESS;
      MATCH_MP_TAC HOMEOMORPHIC_MAP_CLOSEDNESS] THEN
    ASM_REWRITE_TAC[GSYM embedding_map; EMBEDDING_MAP_INL];
    DISCH_THEN SUBST1_TAC THEN
    REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_REGULAR_SPACE;
      MATCH_MP_TAC HOMEOMORPHIC_LOCALLY_COMPACT_SPACE] THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
    REWRITE_TAC[EMBEDDING_MAP_INL]]);;

lemma Hausdorff_space_one_point_compactification:
   "        compact_space X \<and>
        openin X (topspace X - {a}) \<and>
        (\<forall>k. compactin (subtopology X (topspace X - {a})) k \<and>
             closedin (subtopology X (topspace X - {a})) k
             \<Longrightarrow> closedin X k)
        \<Longrightarrow> (Hausdorff_space X \<longleftrightarrow>
             Hausdorff_space (subtopology X (topspace X - {a})) \<and>
             locally_compact_space (subtopology X (topspace X - {a})))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY] THEN
    ASM_MESON_TAC[COMPACT_HAUSDORFF_IMP_REGULAR_SPACE;
                 REGULAR_SPACE_ONE_POINT_COMPACTIFICATION];
    ASM_METIS_TAC[REGULAR_SPACE_ONE_POINT_COMPACTIFICATION;
                  LOCALLY_COMPACT_HAUSDORFF_IMP_REGULAR_SPACE;
                  REGULAR_T1_IMP_HAUSDORFF_SPACE; HAUSDORFF_IMP_T1_SPACE;
                  T1_SPACE_ONE_POINT_COMPACTIFICATION]]);;

lemma Hausdorff_space_alexandroff_compactification:
   "        Hausdorff_space(alexandroff_compactification X) \<longleftrightarrow>
        Hausdorff_space X \<and> locally_compact_space X"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   HAUSDORFF_SPACE_ONE_POINT_COMPACTIFICATION) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN ANTS_TAC THENL
   [SIMP_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN CONJ_TAC THENL
     [MESON_TAC[open_map; OPEN_IN_TOPSPACE; OPEN_MAP_INL]; ALL_TAC] THEN
    ONCE_REWRITE_TAC[MESON[COMPACT_IN_SUBTOPOLOGY]
     `(compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k) \<longleftrightarrow>
      (k \<subseteq> u \<Longrightarrow> compactin (subtopology X u) k \<and> P k \<Longrightarrow> Q k)`] THEN
    REWRITE_TAC[FORALL_SUBSET_IMAGE] THEN
    X_GEN_TAC `k::A=>bool` THEN DISCH_TAC THEN
    GEN_REWRITE_TAC RAND_CONV
     [CLOSED_IN_ALEXANDROFF_COMPACTIFICATION_IMAGE_INL] THEN
    MATCH_MP_TAC EQ_IMP THEN BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_MAP_COMPACTNESS;
      MATCH_MP_TAC HOMEOMORPHIC_MAP_CLOSEDNESS] THEN
    ASM_REWRITE_TAC[GSYM embedding_map; EMBEDDING_MAP_INL];
    DISCH_THEN SUBST1_TAC THEN
    REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
    BINOP_TAC THENL
     [MATCH_MP_TAC HOMEOMORPHIC_HAUSDORFF_SPACE;
      MATCH_MP_TAC HOMEOMORPHIC_LOCALLY_COMPACT_SPACE] THEN
    ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
    MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
    REWRITE_TAC[EMBEDDING_MAP_INL]]);;

lemma completely_regular_space_alexandroff_compactification:
   "        completely_regular_space(alexandroff_compactification X) \<longleftrightarrow>
        completely_regular_space X \<and> locally_compact_space X"
oops
  MESON_TAC[REGULAR_SPACE_ALEXANDROFF_COMPACTIFICATION;
            COMPLETELY_REGULAR_EQ_REGULAR_SPACE;
            COMPACT_IMP_LOCALLY_COMPACT_SPACE;
            COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION]);;

lemma Hausdorff_space_one_point_compactification_asymmetric_prod:
   "        compact_space X
        \<Longrightarrow> (Hausdorff_space X \<longleftrightarrow>
             kc_space
              (prod_topology X (subtopology X (topspace X - {a}))) \<and>
             k_space
              (prod_topology X (subtopology X (topspace X - {a}))))"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `(a::A) \<in> topspace X` THENL
   [ALL_TAC;
    ASM_SIMP_TAC[SUBTOPOLOGY_TOPSPACE; KC_SPACE_COMPACT_PROD_TOPOLOGY; SET_RULE
       `(a \<notin> s) \<Longrightarrow> s - {a} = s`] THEN
    SIMP_TAC[COMPACT_IMP_K_SPACE; COMPACT_SPACE_PROD_TOPOLOGY]] THEN
  STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
   [REWRITE_TAC[PROD_TOPOLOGY_SUBTOPOLOGY] THEN CONJ_TAC THENL
     [MATCH_MP_TAC HAUSDORFF_IMP_KC_SPACE THEN
      MATCH_MP_TAC HAUSDORFF_SPACE_SUBTOPOLOGY THEN
      ASM_REWRITE_TAC[HAUSDORFF_SPACE_PROD_TOPOLOGY];

      MATCH_MP_TAC K_SPACE_OPEN_SUBTOPOLOGY THEN
      ASM_REWRITE_TAC[HAUSDORFF_SPACE_PROD_TOPOLOGY] THEN
      ASM_REWRITE_TAC[OPEN_IN_CROSS; OPEN_IN_TOPSPACE] THEN
      ASM_SIMP_TAC[COMPACT_IMP_K_SPACE; COMPACT_SPACE_PROD_TOPOLOGY] THEN
      REPEAT DISJ2_TAC THEN
      ONCE_REWRITE_TAC[SET_RULE `s - {a} = s - {a}`] THEN
      MATCH_MP_TAC OPEN_IN_DIFF THEN
      ASM_SIMP_TAC[OPEN_IN_TOPSPACE; CLOSED_IN_HAUSDORFF_SING]];
    ALL_TAC] THEN
  ASM_CASES_TAC `topspace X = {a::A}` THENL
   [ASM_REWRITE_TAC[Hausdorff_space] THEN SET_TAC[];
    ALL_TAC] THEN
  MP_TAC(ISPECL
   [`prod_topology X (subtopology X (topspace X DELETE (a::A)))`;
    `X::A topology`; `fst::A#A=>A`] KC_SPACE_RETRACTION_MAP_IMAGE) THEN
  ASM_REWRITE_TAC[RETRACTION_MAP_FST; TOPSPACE_SUBTOPOLOGY] THEN
  ANTS_TAC THENL [ASM SET_TAC[]; DISCH_TAC] THEN
  REWRITE_TAC[HAUSDORFF_SPACE_CLOSED_IN_DIAGONAL] THEN
  SUBGOAL_THEN
   `closedin (prod_topology X (subtopology X (topspace X - {a})))
              {x::A,x | x \<in> topspace X - {a}}`
  MP_TAC THENL
   [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [K_SPACE]) THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_GSPEC; TOPSPACE_PROD_TOPOLOGY] THEN
    SIMP_TAC[IN_DELETE; IN_CROSS; TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
    X_GEN_TAC `k::A#A=>bool` THEN DISCH_TAC THEN
    MATCH_MP_TAC CLOSED_IN_SUBTOPOLOGY_INTER_SUBSET THEN
    EXISTS_TAC `(image fst (k::A#A=>bool)) \<times> (snd ` k)` THEN
    CONJ_TAC THENL
     [ALL_TAC;
      REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_CROSS; IN_IMAGE;
                  EXISTS_PAIR_THM; PAIR_EQ] THEN
      SET_TAC[]] THEN
    MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN
    REWRITE_TAC[INTER_SUBSET] THEN
    FIRST_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [kc_space]) THEN
    SUBGOAL_THEN
     `(fst ` k \<times> snd ` k) \<inter>
       {x,x | x \<in> topspace X \<and> \<not> (x::A = a)} =
      image (\<lambda>x::A. x,x) (fst ` k \<inter> snd ` k)`
    SUBST1_TAC THENL
     [FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
      REWRITE_TAC[\<subseteq>; EXTENSION; FORALL_PAIR_THM] THEN
      REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; IN_INTER; IN_IMAGE; IN_DELETE;
                  EXISTS_PAIR_THM; PAIR_EQ; IN_ELIM_THM; IN_CROSS;
                  TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
      MESON_TAC[];
      ALL_TAC] THEN
    MATCH_MP_TAC IMAGE_COMPACT_IN THEN
    EXISTS_TAC `subtopology X (topspace X DELETE (a::A))` THEN
    REWRITE_TAC[CONTINUOUS_MAP_PAIRED; CONTINUOUS_MAP_ID] THEN
    SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_ID] THEN
    REWRITE_TAC[COMPACT_IN_SUBTOPOLOGY] THEN CONJ_TAC THENL
     [ALL_TAC;
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
      REWRITE_TAC[\<subseteq>; EXTENSION; FORALL_PAIR_THM] THEN
      REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; IN_INTER; IN_IMAGE; IN_DELETE;
                  EXISTS_PAIR_THM; PAIR_EQ; IN_ELIM_THM; IN_CROSS;
                  TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
      MESON_TAC[]] THEN
    MATCH_MP_TAC COMPACT_INTER_CLOSED_IN THEN CONJ_TAC THENL
     [MATCH_MP_TAC IMAGE_COMPACT_IN THEN
      EXISTS_TAC
       `prod_topology X (subtopology X (topspace X DELETE (a::A)))` THEN
      ASM_REWRITE_TAC[CONTINUOUS_MAP_FST];
      ALL_TAC] THEN
    MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN_GEN THEN
    ASM_REWRITE_TAC[] THEN  MATCH_MP_TAC IMAGE_COMPACT_IN THEN
    EXISTS_TAC
     `prod_topology X (subtopology X (topspace X DELETE (a::A)))` THEN
    ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[PROD_TOPOLOGY_SUBTOPOLOGY] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    REWRITE_TAC[CONTINUOUS_MAP_SND];
    ALL_TAC] THEN
  REWRITE_TAC[GSYM CLOSURE_OF_SUBSET_EQ] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_GSPEC; TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
  DISCH_THEN(ASSUME_TAC \<circ> CONJUNCT2) THEN
  REWRITE_TAC[FORALL_PAIR_THM; closure_of; IN_ELIM_THM] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN
  REWRITE_TAC[EXISTS_PAIR_THM; PAIR_EQ; TOPSPACE_PROD_TOPOLOGY] THEN
  REWRITE_TAC[MESON[] `(\<exists>x. P x \<and> a = x \<and> b = x) \<longleftrightarrow> a = b \<and> P b`] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC; UNWIND_THM1; IN_CROSS] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC `\<not> (x::A = a) \<or> (y \<noteq> a)` THENL
   [ALL_TAC; ASM_MESON_TAC[]] THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(y,x):A#A`);
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(x,y):A#A`)] THEN
  ASM_REWRITE_TAC[closure_of; IN_ELIM_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS;
                  IN_DELETE; PAIR_EQ; TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  (ANTS_TAC THENL [ALL_TAC; MESON_TAC[]]) THEN
  REWRITE_TAC[IMP_CONJ_ALT; PROD_TOPOLOGY_SUBTOPOLOGY] THEN
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; FORALL_IN_GSPEC] THEN
  ASM_REWRITE_TAC[IN_INTER; IN_CROSS; IN_DELETE; EXISTS_PAIR_THM] THEN
  REWRITE_TAC[PAIR_EQ] THEN
  REWRITE_TAC[MESON[] `(\<exists>x. P x \<and> a = x \<and> b = x) \<longleftrightarrow> a = b \<and> P b`] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC; UNWIND_THM1] THENL
   [ALL_TAC;
    X_GEN_TAC `t::A#A=>bool` THEN REPEAT DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC
     `t \<inter> (topspace X \<times> (topspace X DELETE (a::A)))`) THEN
    ASM_SIMP_TAC[IN_INTER; IN_CROSS; IN_DELETE] THEN
    ANTS_TAC THENL [ALL_TAC; MESON_TAC[]] THEN
    MATCH_MP_TAC OPEN_IN_INTER THEN
    ASM_REWRITE_TAC[OPEN_IN_CROSS; OPEN_IN_TOPSPACE] THEN
    ASM_MESON_TAC[T1_SPACE_OPEN_IN_DELETE_ALT; OPEN_IN_TOPSPACE;
                  KC_IMP_T1_SPACE]] THEN
  X_GEN_TAC `t::A#A=>bool` THEN REPEAT DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC
   `{z. z \<in> topspace(prod_topology X X) \<and>
         (snd z::A,fst z) \<in>
         (t \<inter> (topspace X \<times> (topspace X DELETE (a::A))))}`) THEN
  ANTS_TAC THENL
   [ALL_TAC;
    ASM_REWRITE_TAC[IN_ELIM_THM; IN_INTER; IN_CROSS; TOPSPACE_PROD_TOPOLOGY;
                      IN_DELETE] THEN
    MESON_TAC[]] THEN
  CONJ_TAC THENL
   [ASM_REWRITE_TAC[IN_ELIM_THM; IN_INTER; IN_CROSS; TOPSPACE_PROD_TOPOLOGY;
                    IN_DELETE];
    MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
    EXISTS_TAC `prod_topology (X::A topology) X` THEN
    REWRITE_TAC[CONTINUOUS_MAP_PAIRED] THEN
    REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND] THEN
     MATCH_MP_TAC OPEN_IN_INTER THEN
    ASM_REWRITE_TAC[OPEN_IN_CROSS; OPEN_IN_TOPSPACE] THEN
    ASM_MESON_TAC[T1_SPACE_OPEN_IN_DELETE_ALT; OPEN_IN_TOPSPACE;
                  KC_IMP_T1_SPACE]]);;

lemma Hausdorff_space_alexandroff_compactification_asymmetric_prod:
   "        Hausdorff_space(alexandroff_compactification X) \<longleftrightarrow>
        kc_space(prod_topology (alexandroff_compactification X) X) \<and>
        k_space(prod_topology (alexandroff_compactification X) X)"
oops
  GEN_TAC THEN MP_TAC(ISPECL
   [`alexandroff_compactification(X::A topology)`; `INR ()::A+1`]
   HAUSDORFF_SPACE_ONE_POINT_COMPACTIFICATION_ASYMMETRIC_PROD) THEN
  REWRITE_TAC[COMPACT_SPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  DISCH_THEN SUBST1_TAC THEN MATCH_MP_TAC
   (MESON[HOMEOMORPHIC_K_SPACE; HOMEOMORPHIC_KC_SPACE]
    `X homeomorphic_space X'
     \<Longrightarrow> (kc_space X \<and> k_space X \<longleftrightarrow> kc_space X' \<and> k_space X')`) THEN
  MATCH_MP_TAC HOMEOMORPHIC_SPACE_PROD_TOPOLOGY THEN
  REWRITE_TAC[HOMEOMORPHIC_SPACE_REFL] THEN
  REWRITE_TAC[TOPSPACE_ALEXANDROFF_COMPACTIFICATION_DELETE] THEN
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
  MATCH_MP_TAC EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE THEN
  REWRITE_TAC[EMBEDDING_MAP_INL]);;

lemma kc_space_as_compactification_unique:
   "        kc_space X \<and> compact_space X
        \<Longrightarrow> \<forall>u. openin X u \<longleftrightarrow>
                if a \<in> u
                then u \<subseteq> topspace X \<and>
                     compactin X (topspace X - u)
                else openin (subtopology X (topspace X - {a})) u"
oops
  REPEAT GEN_TAC THEN STRIP_TAC THEN X_GEN_TAC `u::A=>bool` THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL
   [ASM_MESON_TAC[OPEN_IN_CLOSED_IN_EQ; CLOSED_IN_COMPACT_SPACE; kc_space];
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP KC_IMP_T1_SPACE) THEN
    ASM_SIMP_TAC[T1_SPACE_OPEN_IN_DELETE_ALT; OPEN_IN_TOPSPACE;
                 OPEN_IN_OPEN_SUBTOPOLOGY; SUBSET_DELETE] THEN
    MESON_TAC[OPEN_IN_SUBSET]]);;

lemma kc_space_as_compactification_unique_explicit:
   "        kc_space X \<and> compact_space X
        \<Longrightarrow> \<forall>u. openin X u \<longleftrightarrow>
                if a \<in> u
                then u \<subseteq> topspace X \<and>
                     compactin (subtopology X (topspace X - {a}))
                                (topspace X - u) \<and>
                     closedin (subtopology X (topspace X - {a}))
                                (topspace X - u)
                else openin (subtopology X (topspace X - {a})) u"
oops
  SIMP_TAC[KC_SPACE_SUBTOPOLOGY; MESON[kc_space]
   `kc_space X
    \<Longrightarrow> (compactin X s \<and> closedin X s \<longleftrightarrow> compactin X s)`] THEN
  SIMP_TAC[COMPACT_IN_SUBTOPOLOGY; SET_RULE
   `a \<in> u \<Longrightarrow> s - u \<subseteq> s - {a}`] THEN
  REWRITE_TAC[KC_SPACE_AS_COMPACTIFICATION_UNIQUE]);;

lemma alexandroff_compactification_unique:
   "        kc_space X \<and> compact_space X \<and> a \<in> topspace X
        \<Longrightarrow> alexandroff_compactification
             (subtopology X (topspace X - {a}))
            homeomorphic_space X"
oops
  lemma lemma:
   (`(INL ` s = INL ` t \<longleftrightarrow> s = t) \<and>
     (INR insert x INL ` s = INR insert x INL ` t \<longleftrightarrow> s = t) \<and>
     \<not> (INR insert x INL ` s = INL ` t)"
oops
    REWRITE_TAC[EXTENSION; IN_IMAGE; IN_INSERT;
                sum_DISTINCT; sum_INJECTIVE] THEN
    MESON_TAC[sum_DISTINCT; sum_INJECTIVE])
in

  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SPACE_SYM] THEN
  REWRITE_TAC[HOMEOMORPHIC_SPACE; homeomorphic_map] THEN
  EXISTS_TAC `\<lambda>x::A. if x = a then INR () else INL x` THEN
  CONJ_TAC THENL [ALL_TAC; MESON_TAC[sum_INJECTIVE; sum_DISTINCT]] THEN
  REWRITE_TAC[quotient_map; TOPSPACE_ALEXANDROFF_COMPACTIFICATION] THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; DELETE_SUBSET] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  REWRITE_TAC[FORALL_SUBSET_INSERT; FORALL_SUBSET_IMAGE] THEN
  X_GEN_TAC `u::A=>bool` THEN REWRITE_TAC[SUBSET_DELETE] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[COND_RAND] THEN ONCE_REWRITE_TAC[COND_RATOR] THEN
  REWRITE_TAC[IN_INSERT; IN_IMAGE; sum_DISTINCT; sum_INJECTIVE] THEN
  REWRITE_TAC[UNWIND_THM1] THEN MP_TAC(ISPECL [`X::A topology`; `a::A`]
        KC_SPACE_AS_COMPACTIFICATION_UNIQUE_EXPLICIT) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(fun th -> REWRITE_TAC[th]) THEN
  ASM_REWRITE_TAC[IN_ELIM_THM; SUBSET_RESTRICT] THEN
  REWRITE_TAC[OPEN_IN_ALEXANDROFF_COMPACTIFICATION] THEN
  REWRITE_TAC[lemma] THEN
  SUBGOAL_THEN
   `{x::A | x \<in> topspace X \<and> (if x = a then False else x \<in> u)} = u`
  SUBST1_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  CONJ_TAC THENL [MESON_TAC[]; ALL_TAC] THEN
  REWRITE_TAC[TAUT `(if p then True else q) \<longleftrightarrow> p \<or> q`] THEN
  REWRITE_TAC[SET_RULE
   `u - {x. x \<in> u \<and> (x = a \<or> x \<in> s)} = u - {a} - s`] THEN
  ONCE_REWRITE_TAC[MESON[CLOSED_IN_SUBSET]
   `closedin X s \<and> P s \<longleftrightarrow>
    \<not> (s \<subseteq> topspace X \<Longrightarrow> closedin X s \<Longrightarrow> \<not> P s)`] THEN
  SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; DELETE_SUBSET] THEN
  ASM_SIMP_TAC[SET_RULE
   `a \<in> t \<and> (a \<notin> u) \<and> u \<subseteq> t \<and> s \<subseteq> t - {a}
    \<Longrightarrow> (u = t - {a} - s \<longleftrightarrow> t - {a} - u = s)`] THEN
  REWRITE_TAC[NOT_IMP; GSYM CONJ_ASSOC] THEN ONCE_REWRITE_TAC[TAUT
   `p \<and> q \<and> r \<and> s \<longleftrightarrow> s \<and> p \<and> q \<and> r`] THEN
  REWRITE_TAC[UNWIND_THM1] THEN ASM SET_TAC[]);;


subsection\<open>Homotopy of maps p,q : X=>Y with property P of all intermediate maps\<close>
subsection\<open>We often just want to require that it fixes some subset, but to take in   \<close>
text\<open> the case of loop homotopy it's convenient to have a general property P\<close>


let homotopic_with = new_definition
  `homotopic_with P (X,Y) p q \<longleftrightarrow>
   \<exists>h. continuous_map
       (prod_topology (subtopology euclideanreal (real_interval[0,1])) X,
        Y) h \<and>
       (\<forall>x. h(0,x) = p x) \<and> (\<forall>x. h(1,x) = q x) \<and>
       (\<forall>t. t \<in> real_interval[0,1] \<Longrightarrow> P(\<lambda>x. h(t,x)))`;;

lemma homotopic_with:
   "\<And>P X Y p q::A=>B.
        (\<forall>h k. (\<forall>x. x \<in> topspace X \<Longrightarrow> h x = k x) \<Longrightarrow> (P h \<longleftrightarrow> P k))
        \<Longrightarrow> (homotopic_with P (X,Y) p q \<longleftrightarrow>
             \<exists>h. continuous_map
                  (prod_topology
                   (subtopology euclideanreal (real_interval [0,1])) X,
                   Y) h \<and>
                (\<forall>x. x \<in> topspace X \<Longrightarrow> h (0,x) = p x) \<and>
                (\<forall>x. x \<in> topspace X \<Longrightarrow> h (1,x) = q x) \<and>
                (\<forall>t. t \<in> real_interval[0,1] \<Longrightarrow> P (\<lambda>x. h (t,x))))"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[homotopic_with] THEN EQ_TAC THENL
   [MATCH_MP_TAC MONO_EXISTS THEN SIMP_TAC[]; ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN `h::real#A=>B` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `\<lambda>(t,x). if x \<in> topspace X then (h::real#A=>B)(t,x)
                      else if t = 0 then p x else q x` THEN
  ASM_SIMP_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
  REWRITE_TAC[COND_ID] THEN CONJ_TAC THENL
   [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
        CONTINUOUS_MAP_EQ)) THEN
    SIMP_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS];
    X_GEN_TAC `t::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `t::real`) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EQ_IMP THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN SIMP_TAC[]]);;

lemma homotopic_with_imp_continuous_maps:
   "\<And>P X Y p q::A=>B.
        homotopic_with P (X,Y) p q
        \<Longrightarrow> continuous_map X Y p \<and> continuous_map X Y q"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[homotopic_with; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `h::real#A=>B` THEN REPEAT STRIP_TAC THENL
   [SUBGOAL_THEN `p = (h::real#A=>B) \<circ> (\<lambda>x. (0,x))` SUBST1_TAC THENL
     [ASM_REWRITE_TAC[FUN_EQ_THM; o_THM]; ALL_TAC];
    SUBGOAL_THEN `q = (h::real#A=>B) \<circ> (\<lambda>x. (1,x))` SUBST1_TAC THENL
     [ASM_REWRITE_TAC[FUN_EQ_THM; o_THM]; ALL_TAC]] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
        CONTINUOUS_MAP_COMPOSE)) THEN
  REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX] THEN
  REWRITE_TAC[CONTINUOUS_MAP_ID; CONTINUOUS_MAP_CONST] THEN DISJ2_TAC THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL; INTER_UNIV] THEN
  REWRITE_TAC[IN_REAL_INTERVAL] THEN REAL_ARITH_TAC);;

lemma homotopic_with_imp_property:
   "\<And>P X Y f g::A=>B. homotopic_with P (X,Y) f g \<Longrightarrow> P f \<and> P g"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopic_with] THEN
  DISCH_THEN(X_CHOOSE_THEN `h::real#A=>B` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN DISCH_THEN
   (fun th -> MP_TAC(SPEC `0::real` th) THEN
              MP_TAC(SPEC `1::real` th)) THEN
  ASM_SIMP_TAC[ENDS_IN_UNIT_REAL_INTERVAL; ETA_AX]);;

lemma homotopic_with_equal:
   "\<And>P X X' f g.
        P f \<and> P g \<and>
        continuous_map X X' f \<and>
        (\<forall>x. x \<in> topspace X \<Longrightarrow> f x = g x)
        \<Longrightarrow> homotopic_with P (X,X') f g"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[homotopic_with] THEN
  EXISTS_TAC `(\<lambda>(t,x). if t = 1 then g x else f x):real#A=>B` THEN
  ASM_REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_EQ THEN EXISTS_TAC `(f \<circ> snd):real#A=>B` THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; FORALL_PAIR_THM] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; o_THM; IN_CROSS] THEN
    ASM_SIMP_TAC[COND_ID] THEN MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[] THEN
    SIMP_TAC[PROD_TOPOLOGY_SUBTOPOLOGY; CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_SND];
    X_GEN_TAC `t::real` THEN ASM_CASES_TAC `t::real = 1` THEN
    ASM_REWRITE_TAC[ETA_AX]]);;

lemma homotopic_with_refl:
   "\<And>P X X' f::A=>B.
        homotopic_with P (X,X') f f \<longleftrightarrow>
        continuous_map X X' f \<and> P f"
oops
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[HOMOTOPIC_WITH_IMP_CONTINUOUS_MAPS; HOMOTOPIC_WITH_IMP_PROPERTY];
    DISCH_TAC THEN MATCH_MP_TAC HOMOTOPIC_WITH_EQUAL THEN
    ASM_REWRITE_TAC[]]);;

lemma homotopic_with_sym:
   "\<And>P X Y f g::A=>B.
     homotopic_with P (X,Y) f g \<longleftrightarrow> homotopic_with P (X,Y) g f"
oops
  REPLICATE_TAC 3 GEN_TAC THEN MATCH_MP_TAC(MESON[]
   `(\<forall>x y. P x y \<Longrightarrow> P y x) \<Longrightarrow> (\<forall>x y. P x y \<longleftrightarrow> P y x)`) THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopic_with] THEN
  DISCH_THEN(X_CHOOSE_THEN `h::real#A=>B` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `\<lambda>(t,x). (h::real#A=>B) (1 - t,x)` THEN
  ASM_REWRITE_TAC[REAL_SUB_REFL; REAL_SUB_RZERO] THEN CONJ_TAC THENL
   [REWRITE_TAC[LAMBDA_PAIR] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
      `prod_topology (subtopology euclideanreal (real_interval [0,1]))
                     (X::A topology)` THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_PAIRED; CONTINUOUS_MAP_SND] THEN
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY;
                FORALL_PAIR_THM; IN_CROSS; IN_REAL_INTERVAL] THEN
    CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM ETA_AX] THEN
    REWRITE_TAC[CONTINUOUS_MAP_OF_FST] THEN
    SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_ID];
    REWRITE_TAC[IN_REAL_INTERVAL] THEN REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN
    ASM_REAL_ARITH_TAC]);;

lemma homotopic_with_trans:
   "\<And>P X X' f g h.
        homotopic_with P (X,X') f g \<and>
        homotopic_with P (X,X') g h
        \<Longrightarrow> homotopic_with P (X,X') f h"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopic_with; IN_REAL_INTERVAL] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN `h::real#A=>B` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN `k::real#A=>B` STRIP_ASSUME_TAC)) THEN
  EXISTS_TAC `\<lambda>z. if fst z \<le> 1 / 2
                  then (h::real#A=>B)(2 * fst z,snd z)
                  else (k::real#A=>B)(2 * fst z - 1,snd z)` THEN
  REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_CASES_LE THEN
    SIMP_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    CONJ_TAC THENL
     [REWRITE_TAC[PROD_TOPOLOGY_SUBTOPOLOGY] THEN
      SIMP_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_FROM_SUBTOPOLOGY];
      CONJ_TAC THEN
      GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
      MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
       `prod_topology (subtopology euclideanreal (real_interval [0,1]))
                      (X::A topology)` THEN
      ASM_REWRITE_TAC[] THEN
      REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX] THEN
      SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_SND] THEN
      REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
      REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY;
                  FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_INTER;
                  IN_ELIM_THM; IN_CROSS; IN_REAL_INTERVAL] THEN
      (CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC]) THEN
      TRY(MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB) THEN
      REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
      MATCH_MP_TAC CONTINUOUS_MAP_REAL_LMUL THEN
      MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
      REWRITE_TAC[PROD_TOPOLOGY_SUBTOPOLOGY] THEN
      MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
      REWRITE_TAC[CONTINUOUS_MAP_FST; ETA_AX]];
    X_GEN_TAC `t::real` THEN STRIP_TAC THEN
    ASM_CASES_TAC `t \<le> 1 / 2` THEN ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REAL_ARITH_TAC]);;

lemma homotopic_with_compose_continuous_map_left:
   "\<And>p q f g (h::B=>C) top1 top2 top3.
        homotopic_with p (top1,top2) f g \<and>
        continuous_map top2 top3 h \<and>
        (\<forall>j. p j \<Longrightarrow> q(h \<circ> j))
        \<Longrightarrow> homotopic_with q (top1,top3) (h \<circ> f) (h \<circ> g)"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ_ALT] THEN STRIP_TAC THEN
  REWRITE_TAC[homotopic_with; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `k::real#A=>B` THEN STRIP_TAC THEN
  EXISTS_TAC `(h::B=>C) \<circ> (k::real#A=>B)` THEN
  ASM_REWRITE_TAC[o_THM] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[CONTINUOUS_MAP_COMPOSE]; ALL_TAC] THEN
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  ASM_SIMP_TAC[]);;

lemma homotopic_compose_continuous_map_left:
   "\<And>f g (h::B=>C) top1 top2 top3.
        homotopic_with (\<lambda>k. True) (top1,top2) f g \<and>
        continuous_map top2 top3 h
        \<Longrightarrow> homotopic_with (\<lambda>k. True) (top1,top3) (h \<circ> f) (h \<circ> g)"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ_ALT] THEN STRIP_TAC THEN
  MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT]
   HOMOTOPIC_WITH_COMPOSE_CONTINUOUS_MAP_LEFT) THEN
  ASM_REWRITE_TAC[]);;

lemma homotopic_with_compose_continuous_map_right:
   "\<And>p q (f::B=>C) g (h::A=>B) top1 top2 top3.
        homotopic_with p (top2,top3) f g \<and>
        continuous_map top1 top2 h \<and>
        (\<forall>j. p j \<Longrightarrow> q(j \<circ> h))
        \<Longrightarrow> homotopic_with q (top1,top3) (f \<circ> h) (g \<circ> h)"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ_ALT] THEN STRIP_TAC THEN
  REWRITE_TAC[homotopic_with; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `k::real#B=>C` THEN STRIP_TAC THEN
  EXISTS_TAC `\<lambda>(t,x). (k::real#B=>C)(t,(h::A=>B) x)` THEN
  ASM_REWRITE_TAC[o_THM] THEN CONJ_TAC THENL
   [REWRITE_TAC[LAMBDA_PAIR] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
    FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
       CONTINUOUS_MAP_COMPOSE)) THEN
    REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_OF_SND];
    GEN_TAC THEN REPLICATE_TAC 2 (DISCH_THEN(ANTE_RES_THEN MP_TAC)) THEN
    REWRITE_TAC[o_DEF]]);;

lemma homotopic_compose_continuous_map_right:
   "\<And>(f::B=>C) g (h::A=>B) top1 top2 top3.
        homotopic_with (\<lambda>k. True) (top2,top3) f g \<and>
        continuous_map top1 top2 h
        \<Longrightarrow> homotopic_with (\<lambda>k. True) (top1,top3) (f \<circ> h) (g \<circ> h)"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ_ALT] THEN STRIP_TAC THEN
  MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT]
   HOMOTOPIC_WITH_COMPOSE_CONTINUOUS_MAP_RIGHT) THEN
  ASM_REWRITE_TAC[]);;

lemma homotopic_from_subtopology:
   "\<And>P X X' s f (g::A=>B).
        homotopic_with P (X,X') f g
        \<Longrightarrow> homotopic_with P (subtopology X s,X') f g"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopic_with] THEN
  MATCH_MP_TAC MONO_EXISTS THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CONJUNCT2 PROD_TOPOLOGY_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY]);;

lemma homotopic_on_empty:
   "\<And>X X' f g.
        topspace X = {}
        \<Longrightarrow> (homotopic_with P (X,X') f g \<longleftrightarrow> P f \<and> P g)"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  REWRITE_TAC[HOMOTOPIC_WITH_IMP_PROPERTY] THEN STRIP_TAC THEN
  REWRITE_TAC[homotopic_with] THEN
  EXISTS_TAC `(\<lambda>(t,x). if t = 0 then f x else g x):real#A=>B` THEN
  ASM_SIMP_TAC[REAL_OF_NUM_EQ; ARITH_EQ; CROSS_EMPTY;
               CONTINUOUS_MAP_ON_EMPTY; TOPSPACE_PROD_TOPOLOGY] THEN
  X_GEN_TAC `t::real` THEN ASM_CASES_TAC `t::real = 0` THEN
  ASM_REWRITE_TAC[ETA_AX]);;

lemma homotopic_constant_maps:
   "\<And>(X::A topology) (X':B topology) a b.
        homotopic_with (\<lambda>x. True) (X,X') (\<lambda>x. a) (\<lambda>x. b) \<longleftrightarrow>
        topspace X = {} \<or> path_component_of X' a b"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[HOMOTOPIC_ON_EMPTY] THEN
  REWRITE_TAC[path_component_of; path_in; homotopic_with] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN `h::real#A=>B` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC `a::A` \<circ>
      GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    EXISTS_TAC `(h::real#A=>B) \<circ> (\<lambda>t. t,a)` THEN
    ASM_REWRITE_TAC[o_THM] THEN MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC
     `prod_topology (subtopology euclideanreal (real_interval[0,1]))
                    (X::A topology)` THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_PAIRED; CONTINUOUS_MAP_ID] THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_CONST];
    DISCH_THEN(X_CHOOSE_THEN `g::real=>B` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(g::real=>B) \<circ> (fst::real#A=>real)` THEN
    ASM_REWRITE_TAC[o_DEF; CONTINUOUS_MAP_OF_FST]]);;

lemma homotopic_with_eq:
   "\<And>P X X' f g f' g':A=>B.
        homotopic_with P (X,X') f g \<and>
        (\<forall>x. x \<in> topspace X \<Longrightarrow> f' x = f x \<and> g' x = g x) \<and>
        (\<forall>h k. (\<forall>x. x \<in> topspace X \<Longrightarrow> h x = k x) \<Longrightarrow> (P h \<longleftrightarrow> P k))
        \<Longrightarrow>  homotopic_with P (X,X') f' g'"
oops
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[homotopic_with] THEN
  DISCH_THEN(X_CHOOSE_THEN `h::real#A=>B`
   (fun th -> EXISTS_TAC
     `\<lambda>y. if snd y \<in> topspace X then (h::real#A=>B) y
          else if fst y = 0 then f'(snd y)
          else g'(snd y)` THEN
   MP_TAC th)) THEN
  REWRITE_TAC[REAL_OF_NUM_EQ; ARITH_EQ] THEN
  REPEAT(MATCH_MP_TAC MONO_AND THEN CONJ_TAC) THENL
   [MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] CONTINUOUS_MAP_EQ) THEN
    SIMP_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS];
    ASM_MESON_TAC[];
    ASM_MESON_TAC[];
    MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `t::real` THEN
    MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
    MATCH_MP_TAC EQ_IMP THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
    SIMP_TAC[]]);;

lemma homotopic_with_prod_topology:
   "\<And>p q r top1 top1' top2 top2' f (g::C=>D) f' g'.
      homotopic_with p (top1,top1') f f' \<and>
      homotopic_with q (top2,top2') g g' \<and>
      (\<forall>i j. p i \<and> q j \<Longrightarrow> r(\<lambda>(x,y). i x,j y))
      \<Longrightarrow> homotopic_with r (prod_topology top1 top2,prod_topology top1' top2')
                           (\<lambda>z. f(fst z),g(snd z)) (\<lambda>z. f'(fst z),g'(snd z))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[IMP_CONJ] THEN
  REWRITE_TAC[homotopic_with; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `h::real#A=>B` THEN STRIP_TAC THEN
  X_GEN_TAC `k::real#C=>D` THEN
  REWRITE_TAC[IMP_IMP] THEN STRIP_TAC THEN
  EXISTS_TAC `\<lambda>(t,x,y). (h::real#A=>B) (t,x),(k::real#C=>D) (t,y)` THEN
  ASM_REWRITE_TAC[FORALL_PAIR_THM] THEN ASM_SIMP_TAC[LAMBDA_PAIR_THM] THEN
  REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF] THEN
  REWRITE_TAC[LAMBDA_TRIPLE_THM] THEN REWRITE_TAC[LAMBDA_TRIPLE] THEN
  CONJ_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THENL
   [EXISTS_TAC
     `prod_topology (subtopology euclideanreal (real_interval [0,1]))
                    (top1::A topology)`;
    EXISTS_TAC
     `prod_topology (subtopology euclideanreal (real_interval [0,1]))
                    (top2::C topology)`] THEN
  ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CONTINUOUS_MAP_PAIRED] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND] THEN
  REWRITE_TAC[CONTINUOUS_MAP_OF_FST; CONTINUOUS_MAP_OF_SND] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND]);;

lemma homotopic_with_product_topology:
   "\<And>k (tops::K=>A topology) (tops':K=>B topology) p q f g.
     (\<forall>i. i \<in> k
          \<Longrightarrow> homotopic_with (p i) (tops i,tops' i) (f i) (g i)) \<and>
     (\<forall>h. (\<forall>i. i \<in> k \<Longrightarrow> p i (h i)) \<Longrightarrow> q(\<lambda>x. (\<lambda>i\<in>k. h i (x i))))
     \<Longrightarrow> homotopic_with q (product_topology k tops,product_topology k tops')
                          (\<lambda>z. (\<lambda>i\<in>k. (f i) (z i)))
                          (\<lambda>z. (\<lambda>i\<in>k. (g i) (z i)))"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[IMP_CONJ_ALT] THEN DISCH_TAC THEN
  REWRITE_TAC[homotopic_with] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> ONCE_DEPTH_CONV) [RIGHT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `h::K=>real#A=>B` THEN DISCH_TAC THEN
  EXISTS_TAC `\<lambda>(t,z). (\<lambda>i\<in>k. (h::K=>real#A=>B) i (t,z i))` THEN
  ASM_SIMP_TAC[RESTRICTION_EXTENSION] THEN
  ONCE_REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; FORALL_PAIR_THM] THEN
  REWRITE_TAC[RESTRICTION_IN_EXTENSIONAL] THEN
  X_GEN_TAC `i::K` THEN DISCH_TAC THEN
  GEN_REWRITE_TAC RAND_CONV [LAMBDA_PAIR_THM] THEN
  ASM_REWRITE_TAC[RESTRICTION] THEN REWRITE_TAC[LAMBDA_PAIR] THEN
  GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
   `prod_topology
     (subtopology euclideanreal (real_interval [0,1]))
     ((tops::K=>A topology) i)` THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_PAIRED] THEN
  REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_OF_SND] THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION]);;


subsection\<open>Homotopy equivalence of topological spaces\<close>


parse_as_infix("homotopy_equivalent_space",(12,"right"));;

let homotopy_equivalent_space = new_definition
 `(X::A topology) homotopy_equivalent_space (X':B topology) \<longleftrightarrow>
        \<exists>f g. continuous_map X X' f \<and>
              continuous_map X' X g \<and>
              homotopic_with (\<lambda>x. True) (X,X) (g \<circ> f) id \<and>
              homotopic_with (\<lambda>x. True) (X',X') (f \<circ> g) id`;;

lemma homeomorphic_imp_homotopy_equivalent_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> X homotopy_equivalent_space X'"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[homeomorphic_space; homotopy_equivalent_space] THEN
  REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
  REWRITE_TAC[homeomorphic_maps] THEN REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC HOMOTOPIC_WITH_EQUAL THEN
  ASM_REWRITE_TAC[o_THM; I_THM] THEN
  ASM_MESON_TAC[CONTINUOUS_MAP_COMPOSE]);;

lemma homotopy_equivalent_space_refl:
   "X homotopy_equivalent_space X"
oops
  SIMP_TAC[HOMEOMORPHIC_IMP_HOMOTOPY_EQUIVALENT_SPACE;
           HOMEOMORPHIC_SPACE_REFL]);;

lemma homotopy_equivalent_space_sym:
   "\<And>(X::A topology) (X':B topology).
        X homotopy_equivalent_space X' \<longleftrightarrow>
        X' homotopy_equivalent_space X"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopy_equivalent_space] THEN
  GEN_REWRITE_TAC RAND_CONV [SWAP_EXISTS_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN CONV_TAC TAUT);;

lemma homotopy_equivalent_space_trans:
   "        top1 homotopy_equivalent_space top2 \<and>
        top2 homotopy_equivalent_space top3
        \<Longrightarrow> top1 homotopy_equivalent_space top3"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopy_equivalent_space] THEN
  SIMP_TAC[LEFT_AND_EXISTS_THM; LEFT_IMP_EXISTS_THM] THEN
  SIMP_TAC[RIGHT_AND_EXISTS_THM; LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC
   [`f1::A=>B`; `g1::B=>A`;
    `f2::B=>C`; `g2::C=>B`] THEN
  STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [`(f2::B=>C) \<circ> (f1::A=>B)`;
    `(g1::B=>A) \<circ> (g2::C=>B)`] THEN
  REWRITE_TAC[IMAGE_o] THEN REPLICATE_TAC 2
   (CONJ_TAC THENL [ASM_MESON_TAC[CONTINUOUS_MAP_COMPOSE]; ALL_TAC]) THEN
  CONJ_TAC THEN MATCH_MP_TAC HOMOTOPIC_WITH_TRANS THENL
   [EXISTS_TAC `(g1::B=>A) \<circ> id \<circ> (f1::A=>B)`;
    EXISTS_TAC `(f2::B=>C) \<circ> id \<circ> (g2::C=>B)`] THEN
  (CONJ_TAC THENL [ALL_TAC; ASM_REWRITE_TAC[I_O_ID]]) THEN
  REWRITE_TAC[GSYM o_ASSOC] THEN
  MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_LEFT THEN
  EXISTS_TAC `top2::B topology` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[o_ASSOC] THEN
  MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_RIGHT THEN
  EXISTS_TAC `top2::B topology` THEN ASM_REWRITE_TAC[]);;

lemma deformation_retraction_imp_homotopy_equivalent_space:
   "\<And>X X' (r::A=>B) s.
        homotopic_with (\<lambda>x. True) (X,X) (s \<circ> r) id \<and>
        retraction_maps(X,X') (r,s)
        \<Longrightarrow> X homotopy_equivalent_space X'"
oops
  REWRITE_TAC[LEFT_FORALL_IMP_THM; I_DEF] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[homotopy_equivalent_space] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `r::A=>B` THEN
  REWRITE_TAC[retraction_maps] THEN STRIP_TAC THEN
  EXISTS_TAC `s::B=>A` THEN ASM_REWRITE_TAC[I_DEF] THEN
  MATCH_MP_TAC HOMOTOPIC_WITH_EQUAL THEN
  ASM_REWRITE_TAC[o_THM] THEN ASM_MESON_TAC[CONTINUOUS_MAP_COMPOSE]);;

lemma deformation_retract_imp_homotopy_equivalent_space:
   "\<And>X X' (r::A=>A).
        homotopic_with (\<lambda>x. True) (X,X) r id \<and>
        retraction_maps(X,X') (r,id)
        \<Longrightarrow> X homotopy_equivalent_space X'"
oops
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC DEFORMATION_RETRACTION_IMP_HOMOTOPY_EQUIVALENT_SPACE THEN
  MAP_EVERY EXISTS_TAC [`r::A=>A`; `id::A=>A`] THEN
  ASM_REWRITE_TAC[I_O_ID]);;

lemma deformation_retract_of_space:
   "
        s \<subseteq> topspace X \<and>
        (\<exists>r. homotopic_with (\<lambda>x. True) (X,X) id r \<and>
             retraction_maps(X,subtopology X s) (r,id)) \<longleftrightarrow>
        s retract_of_space X \<and>
        (\<exists>f. homotopic_with (\<lambda>x. True) (X,X) id f \<and>
             f ` (topspace X) \<subseteq> s)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[retract_of_space; retraction_maps; I_DEF] THEN
  SIMP_TAC[CONTINUOUS_MAP_ID; CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
  ASM_CASES_TAC `(s::A=>bool) \<subseteq> topspace X` THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  EQ_TAC THENL
   [REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `r::A=>A` THEN
    REPEAT STRIP_TAC THEN EXISTS_TAC `r::A=>A` THEN ASM_REWRITE_TAC[];
    DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_THEN `r::A=>A` STRIP_ASSUME_TAC) MP_TAC) THEN
    REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `f::A=>A` THEN
    STRIP_TAC THEN EXISTS_TAC `r::A=>A` THEN ASM_REWRITE_TAC[] THEN
    TRANS_TAC HOMOTOPIC_WITH_TRANS `f::A=>A` THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC HOMOTOPIC_WITH_EQ THEN
    MAP_EVERY EXISTS_TAC [`(r::A=>A) \<circ> (f::A=>A)`; `(r::A=>A) \<circ> (\<lambda>x. x)`] THEN
    ASM_SIMP_TAC[o_THM] THEN CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_LEFT THEN
    EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[] THEN
    ONCE_REWRITE_TAC[HOMOTOPIC_WITH_SYM] THEN ASM_REWRITE_TAC[]]);;


(* Contractible spaces. The definition (which agrees with "contractible" on  *)
(* subsets of Euclidean space) is a little cryptic because we don't in fact  *)
text\<open> assume that the constant "a" is in the space. This forces the convention  \<close>
text\<open> that the empty space / set is contractible, avoiding some special cases.  \<close>


let contractible_space = new_definition
 `contractible_space (X::A topology) \<longleftrightarrow>
        \<exists>a. homotopic_with (\<lambda>x. True) (X,X) (\<lambda>x. x) (\<lambda>x. a)`;;

lemma contractible_space_empty:
   "topspace X = {} \<Longrightarrow> contractible_space X"
oops
  REWRITE_TAC[contractible_space; homotopic_with] THEN
  SIMP_TAC[CONTINUOUS_MAP_ON_EMPTY; TOPSPACE_PROD_TOPOLOGY; CROSS_EMPTY] THEN
  REPEAT STRIP_TAC THEN MAP_EVERY EXISTS_TAC
   [`undefined::A`; `\<lambda>(t,x):real#A. if t = 0 then x else undefined`] THEN
  REWRITE_TAC[REAL_ARITH `\<not> (1 = 0)`]);;

lemma contractible_space_sing:
   "topspace X = {a} \<Longrightarrow> contractible_space X"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[contractible_space] THEN
  EXISTS_TAC `a::A` THEN REWRITE_TAC[homotopic_with] THEN
  EXISTS_TAC `(\<lambda>(t,x). if t = 0 then x else a):real#A=>A` THEN
  REWRITE_TAC[REAL_ARITH `\<not> (1 = 0)`] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_EQ THEN EXISTS_TAC `(\<lambda>z. a):real#A=>A` THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_CONST; IN_SING] THEN
  ASM_REWRITE_TAC[FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
  SET_TAC[]);;

lemma contractible_space_subset_sing:
   "topspace X \<subseteq> {a} \<Longrightarrow> contractible_space X"
oops
  REWRITE_TAC[SET_RULE `s \<subseteq> {a} \<longleftrightarrow> s = {} \<or> s = {a}`] THEN
  MESON_TAC[CONTRACTIBLE_SPACE_EMPTY; CONTRACTIBLE_SPACE_SING]);;

lemma contractible_space_subtopology_sing:
   "contractible_space(subtopology X {a})"
oops
  REPEAT GEN_TAC THEN MATCH_MP_TAC CONTRACTIBLE_SPACE_SUBSET_SING THEN
  EXISTS_TAC `a::A` THEN REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; INTER_SUBSET]);;

lemma contractible_space:
   "        contractible_space X \<longleftrightarrow>
        topspace X = {} \<or>
        \<exists>a. a \<in> topspace X \<and>
            homotopic_with (\<lambda>x. True) (X,X) (\<lambda>x. x) (\<lambda>x. a)"
oops
  GEN_TAC THEN ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY] THEN
  REWRITE_TAC[contractible_space] THEN EQ_TAC THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `a::A` THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP HOMOTOPIC_WITH_IMP_CONTINUOUS_MAPS) THEN
  REWRITE_TAC[continuous_map] THEN ASM SET_TAC[]);;

lemma contractible_imp_path_connected_space:
   "        contractible_space X \<Longrightarrow> path_connected_space X"
oops
  GEN_TAC THEN
  ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[PATH_CONNECTED_SPACE_TOPSPACE_EMPTY; CONTRACTIBLE_SPACE] THEN
  REWRITE_TAC[homotopic_with; LEFT_IMP_EXISTS_THM; RIGHT_AND_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `h::real#A=>A`] THEN STRIP_TAC THEN
  REWRITE_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT] THEN
  SUBGOAL_THEN
   `\<forall>x::A. x \<in> topspace X \<Longrightarrow> path_component_of X x a`
  MP_TAC THENL
   [ALL_TAC;
    ASM_MESON_TAC[PATH_COMPONENT_OF_TRANS; PATH_COMPONENT_OF_SYM]] THEN
  X_GEN_TAC `b::A` THEN DISCH_TAC THEN REWRITE_TAC[path_component_of] THEN
  EXISTS_TAC `(h::real#A=>A) \<circ> (\<lambda>x. x,b)` THEN
  ASM_REWRITE_TAC[o_THM] THEN REWRITE_TAC[path_in] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
   `prod_topology (subtopology euclideanreal (real_interval[0,1]))
                  (X::A topology)` THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF] THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ID; CONTINUOUS_MAP_CONST]);;

lemma contractible_imp_connected_space:
   "contractible_space X \<Longrightarrow> connected_space X"
oops
  MESON_TAC[CONTRACTIBLE_IMP_PATH_CONNECTED_SPACE;
            PATH_CONNECTED_IMP_CONNECTED_SPACE]);;

lemma contractible_space_alt:
   "        contractible_space X \<longleftrightarrow>
        \<forall>a. a \<in> topspace X
            \<Longrightarrow> homotopic_with (\<lambda>x. True) (X,X) (\<lambda>x. x) (\<lambda>x. a)"
oops
  GEN_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONTRACTIBLE_SPACE]) THEN
    DISCH_THEN(DISJ_CASES_THEN MP_TAC) THENL [ASM SET_TAC[]; ALL_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN `b::A` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] HOMOTOPIC_WITH_TRANS) THEN
    REWRITE_TAC[HOMOTOPIC_CONSTANT_MAPS] THEN DISJ2_TAC THEN
    MATCH_MP_TAC PATH_CONNECTED_SPACE_IMP_PATH_COMPONENT_OF THEN
    ASM_SIMP_TAC[CONTRACTIBLE_IMP_PATH_CONNECTED_SPACE];
    DISCH_TAC THEN REWRITE_TAC[CONTRACTIBLE_SPACE] THEN ASM SET_TAC[]]);;

lemma nullhomotopic_through_contractible_space:
   "\<And>f (g::B=>C) top1 top2 top3.
        continuous_map top1 top2 f \<and>
        continuous_map top2 top3 g \<and>
        contractible_space top2
        \<Longrightarrow> \<exists>c. homotopic_with (\<lambda>h. True) (top1,top3) (g \<circ> f) (\<lambda>x. c)"
oops
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [contractible_space]) THEN
  DISCH_THEN(X_CHOOSE_THEN `b::B` MP_TAC) THEN
  DISCH_THEN(MP_TAC \<circ> ISPECL [`g::B=>C`; `top3::C topology`] \<circ> MATCH_MP
   (ONCE_REWRITE_RULE[IMP_CONJ] HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_LEFT)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC \<circ> ISPECL [`f::A=>B`; `top1::A topology`] \<circ> MATCH_MP
   (ONCE_REWRITE_RULE[IMP_CONJ] HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_RIGHT)) THEN
  ASM_REWRITE_TAC[o_DEF] THEN DISCH_TAC THEN
  EXISTS_TAC `(g::B=>C) b` THEN ASM_REWRITE_TAC[]);;

lemma nullhomotopic_into_contractible_space:
   "\<And>f top1 top2.
        continuous_map top1 top2 f \<and> contractible_space top2
        \<Longrightarrow> \<exists>c. homotopic_with (\<lambda>h. True) (top1,top2) f (\<lambda>x. c)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `f = (\<lambda>x. x) \<circ> f` SUBST1_TAC THENL
   [REWRITE_TAC[o_THM; FUN_EQ_THM];
    MATCH_MP_TAC NULLHOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE THEN
    EXISTS_TAC `top2::B topology` THEN ASM_REWRITE_TAC[CONTINUOUS_MAP_ID]]);;

lemma nullhomotopic_from_contractible_space:
   "\<And>f top1 top2.
        continuous_map top1 top2 f \<and> contractible_space top1
        \<Longrightarrow> \<exists>c. homotopic_with (\<lambda>h. True) (top1,top2) f (\<lambda>x. c)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `f = f \<circ> (\<lambda>x. x)` SUBST1_TAC THENL
   [REWRITE_TAC[o_THM; FUN_EQ_THM];
    MATCH_MP_TAC NULLHOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE THEN
    EXISTS_TAC `top1::A topology` THEN ASM_REWRITE_TAC[CONTINUOUS_MAP_ID]]);;

lemma homotopic_through_contractible_space:
   "\<And>f (g::B=>C) f' g' top1 top2 top3.
        continuous_map top1 top2 f \<and>
        continuous_map top1 top2 f' \<and>
        continuous_map top2 top3 g \<and>
        continuous_map top2 top3 g' \<and>
        contractible_space top2 \<and> path_connected_space top3
        \<Longrightarrow> homotopic_with (\<lambda>h. True) (top1,top3) (g \<circ> f) (g' \<circ> f')"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [`f::A=>B`; `g::B=>C`;
    `top1::A topology`; `top2::B topology`; `top3::C topology`]
   NULLHOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE) THEN
  MP_TAC(ISPECL
   [`f':A=>B`; `g':B=>C`;
    `top1::A topology`; `top2::B topology`; `top3::C topology`]
   NULLHOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `c::C` THEN
  DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP HOMOTOPIC_WITH_IMP_CONTINUOUS_MAPS) THEN
  REWRITE_TAC[CONTINUOUS_MAP_CONST] THEN DISCH_TAC THEN
  X_GEN_TAC `d::C` THEN DISCH_THEN(fun th -> MP_TAC th THEN
     MP_TAC(MATCH_MP HOMOTOPIC_WITH_IMP_CONTINUOUS_MAPS th)) THEN
  REWRITE_TAC[CONTINUOUS_MAP_CONST] THEN DISCH_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] HOMOTOPIC_WITH_TRANS) THEN
  ONCE_REWRITE_TAC[HOMOTOPIC_WITH_SYM] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        HOMOTOPIC_WITH_TRANS)) THEN
  REWRITE_TAC[HOMOTOPIC_CONSTANT_MAPS] THEN
  ASM_MESON_TAC[PATH_CONNECTED_SPACE_IFF_PATH_COMPONENT]);;

lemma homotopic_from_contractible_space:
   "\<And>f g X X'.
        continuous_map X X' f \<and> continuous_map X X' g \<and>
        contractible_space X \<and> path_connected_space X'
        \<Longrightarrow> homotopic_with (\<lambda>x. True) (X,X') f g"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [`\<lambda>x::A. x`; `f::A=>B`; `\<lambda>x::A. x`;
    `g::A=>B`; `X::A topology`; `X::A topology`;
    `X':B topology`] HOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ID; o_DEF; ETA_AX]);;

lemma homotopic_into_contractible_space:
   "\<And>f g X X'.
        continuous_map X X' f \<and> continuous_map X X' g \<and>
        contractible_space X'
        \<Longrightarrow> homotopic_with (\<lambda>x. True) (X,X') f g"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [`f::A=>B`; `\<lambda>x::B. x`;
    `g::A=>B`; `\<lambda>x::B. x`; `X::A topology`; `X':B topology`;
    `X':B topology`] HOMOTOPIC_THROUGH_CONTRACTIBLE_SPACE) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ID; o_DEF; ETA_AX] THEN
  ASM_SIMP_TAC[CONTRACTIBLE_IMP_PATH_CONNECTED_SPACE]);;

lemma homotopy_dominated_contractibility:
   "\<And>f g X X'.
        continuous_map X X' f \<and>
        continuous_map X' X g \<and>
        homotopic_with (\<lambda>x. True) (X',X') (f \<circ> g) id \<and>
        contractible_space X
        \<Longrightarrow> contractible_space X'"
oops
  REPEAT GEN_TAC THEN SIMP_TAC[contractible_space; I_DEF] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`f::A=>B`; `X::A topology`; `X':B topology`]
        NULLHOMOTOPIC_FROM_CONTRACTIBLE_SPACE) THEN
  ASM_REWRITE_TAC[contractible_space; I_DEF] THEN
  ANTS_TAC THENL [ASM_MESON_TAC[]; ALL_TAC] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `b::B` THEN
  ONCE_REWRITE_TAC[HOMOTOPIC_WITH_SYM] THEN DISCH_TAC THEN
  MATCH_MP_TAC HOMOTOPIC_WITH_TRANS THEN
  EXISTS_TAC `f \<circ> (g::B=>A)` THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN `(\<lambda>x. (b::B)) = (\<lambda>x. b) \<circ> (g::B=>A)`
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF]; ALL_TAC] THEN
  MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_RIGHT THEN
  EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[]);;

lemma homotopy_equivalent_space_contractibility:
   "\<And>(X::A topology) (X':B topology).
        X homotopy_equivalent_space X'
        \<Longrightarrow> (contractible_space X \<longleftrightarrow> contractible_space X')"
oops
  REWRITE_TAC[homotopy_equivalent_space] THEN REPEAT STRIP_TAC THEN EQ_TAC THEN
  MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ]
   (REWRITE_RULE[CONJ_ASSOC] HOMOTOPY_DOMINATED_CONTRACTIBILITY)) THEN
  ASM_MESON_TAC[]);;

lemma homeomorphic_space_contractibility:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (contractible_space X \<longleftrightarrow> contractible_space X')"
oops
  MESON_TAC[HOMOTOPY_EQUIVALENT_SPACE_CONTRACTIBILITY;
            HOMEOMORPHIC_IMP_HOMOTOPY_EQUIVALENT_SPACE]);;

lemma contractible_eq_homotopy_equivalent_singleton_subtopology:
   "        contractible_space X \<longleftrightarrow>
        topspace X = {} \<or>
        \<exists>a. a \<in> topspace X \<and>
            X homotopy_equivalent_space (subtopology X {a})"
oops
  GEN_TAC THEN ASM_CASES_TAC `topspace X::A=>bool = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY] THEN EQ_TAC THENL
   [ASM_REWRITE_TAC[CONTRACTIBLE_SPACE] THEN MATCH_MP_TAC MONO_EXISTS THEN
    X_GEN_TAC `a::A` THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[homotopy_equivalent_space] THEN
    MAP_EVERY EXISTS_TAC [`(\<lambda>x. a):A=>A`; `(\<lambda>x. x):A=>A`] THEN
    ASM_SIMP_TAC[o_DEF; CONTINUOUS_MAP_FROM_SUBTOPOLOGY; CONTINUOUS_MAP_ID;
      IN_INTER; CONTINUOUS_MAP_CONST; TOPSPACE_SUBTOPOLOGY; IN_SING] THEN
    ONCE_REWRITE_TAC[HOMOTOPIC_WITH_SYM] THEN
    ASM_REWRITE_TAC[I_DEF] THEN MATCH_MP_TAC HOMOTOPIC_WITH_EQUAL THEN
    REWRITE_TAC[CONTINUOUS_MAP_ID; TOPSPACE_SUBTOPOLOGY] THEN SET_TAC[];
    DISCH_THEN(X_CHOOSE_THEN `a::A` STRIP_ASSUME_TAC) THEN
    FIRST_ASSUM(SUBST1_TAC \<circ>
      MATCH_MP HOMOTOPY_EQUIVALENT_SPACE_CONTRACTIBILITY) THEN
    MATCH_MP_TAC CONTRACTIBLE_SPACE_SING THEN
    EXISTS_TAC `a::A` THEN ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
    ASM SET_TAC[]]);;

lemma contractible_space_retraction_map_image:
   "\<And>X X' f.
        retraction_map X X' f \<and> contractible_space X
        \<Longrightarrow> contractible_space X'"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[IMP_CONJ; retraction_map; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::B=>A` THEN REWRITE_TAC[retraction_maps] THEN STRIP_TAC THEN
  REWRITE_TAC[contractible_space; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `a::A` THEN STRIP_TAC THEN EXISTS_TAC `f a` THEN
  MATCH_MP_TAC HOMOTOPIC_WITH_EQ THEN
  EXISTS_TAC `f \<circ> (\<lambda>x. x) \<circ> (g::B=>A)` THEN
  EXISTS_TAC `f \<circ> (\<lambda>x. a) \<circ> (g::B=>A)` THEN
  ASM_SIMP_TAC[o_THM] THEN
  MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_LEFT THEN
  EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC HOMOTOPIC_COMPOSE_CONTINUOUS_MAP_RIGHT THEN
  EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[]);;

lemma contractible_space_prod_topology:
   "\<And>(top1::A topology) (top2::B topology).
        contractible_space(prod_topology top1 top2) \<longleftrightarrow>
        topspace top1 = {} \<or> topspace top2 = {} \<or>
        contractible_space top1 \<and> contractible_space top2"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace top1::A=>bool = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY; TOPSPACE_PROD_TOPOLOGY;
               CROSS_EQ_EMPTY] THEN
  ASM_CASES_TAC `topspace top2::B=>bool = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY; TOPSPACE_PROD_TOPOLOGY;
               CROSS_EQ_EMPTY] THEN
  EQ_TAC THENL
   [DISCH_THEN(fun th -> CONJ_TAC THEN MP_TAC th) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ]
     CONTRACTIBLE_SPACE_RETRACTION_MAP_IMAGE)
    THENL [EXISTS_TAC `fst::A#B=>A`; EXISTS_TAC `snd::A#B=>B`] THEN
    ASM_REWRITE_TAC[RETRACTION_MAP_FST; RETRACTION_MAP_SND];
    ASM_REWRITE_TAC[CONTRACTIBLE_SPACE; TOPSPACE_PROD_TOPOLOGY;
                    CROSS_EQ_EMPTY; EXISTS_PAIR_THM] THEN
    REWRITE_TAC[IN_CROSS; LEFT_AND_EXISTS_THM] THEN
    REWRITE_TAC[RIGHT_AND_EXISTS_THM; GSYM CONJ_ASSOC] THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `a::A` THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `b::B` THEN
    ASM_CASES_TAC `(a::A) \<in> topspace top1` THEN ASM_REWRITE_TAC[] THEN
    ASM_CASES_TAC `(b::B) \<in> topspace top2` THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[TAUT
     `p \<and> q \<and> r \<Longrightarrow> s \<longleftrightarrow> p \<and> q \<Longrightarrow> r \<Longrightarrow> s`]
    HOMOTOPIC_WITH_PROD_TOPOLOGY)) THEN SIMP_TAC[]]);;

lemma contractible_space_product_topology:
   "\<And>k (tops::K=>A topology).
        contractible_space(product_topology k tops) \<longleftrightarrow>
        topspace (product_topology k tops) = {} \<or>
        \<forall>i. i \<in> k \<Longrightarrow> contractible_space(tops i)"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `topspace(product_topology k (tops::K=>A topology)) = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY] THEN EQ_TAC THENL
   [DISCH_TAC THEN X_GEN_TAC `i::K` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
     CONTRACTIBLE_SPACE_RETRACTION_MAP_IMAGE)) THEN
    EXISTS_TAC `\<lambda>x::K=>A. x i` THEN
    ASM_SIMP_TAC[RETRACTION_MAP_PRODUCT_PROJECTION];
    REWRITE_TAC[contractible_space] THEN
    GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM] THEN
    REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `a::K=>A` THEN DISCH_TAC THEN
    EXISTS_TAC `RESTRICTION k (a::K=>A)` THEN FIRST_X_ASSUM
     (MP_TAC \<circ> ISPEC `\<lambda>z:(K=>A)->(K=>A). True` \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        HOMOTOPIC_WITH_PRODUCT_TOPOLOGY)) THEN
    REWRITE_TAC[] THEN MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT]
        HOMOTOPIC_WITH_EQ) THEN
    REWRITE_TAC[ETA_AX] THEN REWRITE_TAC[FUN_EQ_THM] THEN
    REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; IN_ELIM_THM] THEN
    REWRITE_TAC[EXTENSIONAL; IN_ELIM_THM; RESTRICTION] THEN MESON_TAC[]]);;

lemma contractible_space_subtopology_euclideanreal:
   "contractible_space(subtopology euclideanreal s) \<longleftrightarrow> is_interval s"
oops
  GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(MP_TAC \<circ> MATCH_MP CONTRACTIBLE_IMP_PATH_CONNECTED_SPACE) THEN
    REWRITE_TAC[GSYM PATH_CONNECTED_IN_TOPSPACE] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
    REWRITE_TAC[PATH_CONNECTED_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
    REWRITE_TAC[PATH_CONNECTED_IN_EUCLIDEANREAL];
    ALL_TAC] THEN
  ASM_CASES_TAC `s::real=>bool = {}` THEN
  ASM_SIMP_TAC[CONTRACTIBLE_SPACE_EMPTY;
               TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC `z::real`) THEN REWRITE_TAC[is_interval] THEN
  STRIP_TAC THEN REWRITE_TAC[contractible_space; homotopic_with] THEN
  EXISTS_TAC `z::real` THEN
  EXISTS_TAC `\<lambda>(t::real,x). (1 - t) * x + t * z` THEN REWRITE_TAC[] THEN
  CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN CONJ_TAC THENL
   [REWRITE_TAC[LAMBDA_PAIR; GSYM SUBTOPOLOGY_CROSS] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_ADD THEN
    CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_MAP_REAL_MUL THEN
    SIMP_TAC[CONTINUOUS_MAP_REAL_CONST; CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND;
             CONTINUOUS_MAP_REAL_SUB];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; FORALL_PAIR_THM] THEN
    MAP_EVERY X_GEN_TAC [`t::real`; `x::real`] THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; IN_REAL_INTERVAL] THEN
    STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
    MAP_EVERY EXISTS_TAC [`min x z::real`; `max z x::real`] THEN
    GEN_REWRITE_TAC id [CONJ_ASSOC] THEN CONJ_TAC THENL
     [REWRITE_TAC[real_max; real_min] THEN ASM_MESON_TAC[]; ALL_TAC] THEN
    MATCH_MP_TAC REAL_CONVEX_BOUNDS_LE THEN ASM_REAL_ARITH_TAC]);;

lemma contractible_space_euclideanreal:
 (`contractible_space euclideanreal"
oops
  ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN
  REWRITE_TAC[CONTRACTIBLE_SPACE_SUBTOPOLOGY_EUCLIDEANREAL] THEN
  REWRITE_TAC[IS_REALINTERVAL_UNIV]);;


(* Completely metrizable (a.k.a. "topologically complete") spaces.           *)


let completely_metrizable_space = new_definition
 `completely_metrizable_space X \<longleftrightarrow>
  \<exists>m. mcomplete \<and> X = mtopology`;;

lemma completely_metrizable_imp_metrizable_space:
   "completely_metrizable_space X \<Longrightarrow> metrizable_space X"
oops
  REWRITE_TAC[completely_metrizable_space; metrizable_space] THEN
  MESON_TAC[]);;

lemma forall_mcomplete_topology:
   "(\<forall>m::A metric. mcomplete \<Longrightarrow> P mtopology (M)) \<longleftrightarrow>
       \<forall>X. completely_metrizable_space X \<Longrightarrow> P X (topspace X)"
oops
  SIMP_TAC[completely_metrizable_space; LEFT_IMP_EXISTS_THM;
           TOPSPACE_MTOPOLOGY] THEN
  MESON_TAC[]);;

lemma forall_completely_metrizable_space:
 (`(\<forall>X. completely_metrizable_space X \<Longrightarrow> P X (topspace X)) \<longleftrightarrow>
   (\<forall>m::A metric. mcomplete \<Longrightarrow> P mtopology (M))"
oops
  SIMP_TAC[completely_metrizable_space; LEFT_IMP_EXISTS_THM;
           TOPSPACE_MTOPOLOGY] THEN
  MESON_TAC[]);;

lemma exists_completely_metrizable_space:
   "(\<exists>X. completely_metrizable_space X \<and> P X (topspace X)) \<longleftrightarrow>
       (\<exists>m::A metric.mcomplete \<and>  P mtopology (M))"
oops
  REWRITE_TAC[MESON[] `(\<exists>x. P x \<and> Q x) \<longleftrightarrow> \<not> (\<forall>x. P x \<Longrightarrow> \<not> Q x)`] THEN
  REWRITE_TAC[FORALL_MCOMPLETE_TOPOLOGY] THEN MESON_TAC[]);;

lemma completely_metrizable_space_mtopology:
   "mcomplete \<Longrightarrow> completely_metrizable_spacemtopology"
oops
  REWRITE_TAC[FORALL_MCOMPLETE_TOPOLOGY]);;

lemma completely_metrizable_space_discrete_topology:
   "\<And>u::A=>bool. completely_metrizable_space(discrete_topology u)"
oops
  REWRITE_TAC[completely_metrizable_space] THEN
  MESON_TAC[MTOPOLOGY_DISCRETE_METRIC; MCOMPLETE_DISCRETE_METRIC]);;

lemma completely_metrizable_space_euclideanreal:
 (`completely_metrizable_space euclideanreal"
oops
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_MTOPOLOGY THEN
  REWRITE_TAC[MCOMPLETE_REAL_EUCLIDEAN_METRIC]);;

lemma completely_metrizable_space_closedin:
   "
        completely_metrizable_space X \<and> closedin X s
        \<Longrightarrow> completely_metrizable_space(subtopology X s)"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[GSYM FORALL_MCOMPLETE_TOPOLOGY] THEN
  REWRITE_TAC[GSYM MTOPOLOGY_SUBMETRIC] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_MTOPOLOGY THEN
  MATCH_MP_TAC CLOSED_IN_MCOMPLETE_IMP_MCOMPLETE THEN ASM_REWRITE_TAC[]);;

lemma homeomorphic_completely_metrizable_space:
   "\<And>(X::A topology) (X':B topology).
        X homeomorphic_space X'
        \<Longrightarrow> (completely_metrizable_space X \<longleftrightarrow>
             completely_metrizable_space X')"
oops
  lemma lemma:
   "\<And>(X::A topology) (X':B topology).
          X homeomorphic_space X'
          \<Longrightarrow> completely_metrizable_space X
              \<Longrightarrow> completely_metrizable_space X'"
oops
    REPEAT GEN_TAC THEN REWRITE_TAC[completely_metrizable_space] THEN
    REWRITE_TAC[homeomorphic_space; LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`f::A=>B`; `g::B=>A`] THEN DISCH_TAC THEN
    X_GEN_TAC `m::A metric` THEN DISCH_THEN(STRIP_ASSUME_TAC \<circ> GSYM) THEN
    ABBREV_TAC
     `m' = metric(topspace X',\<lambda>(x,y). d m ((g::B=>A) x,g y))` THEN
    MP_TAC(ISPECL [`g::B=>A`; `m::A metric`; `topspace X':B=>bool`]
          METRIC_INJECTIVE_IMAGE) THEN
    ASM_REWRITE_TAC[] THEN ANTS_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [homeomorphic_maps]) THEN
      EXPAND_TAC "X" THEN
      REWRITE_TAC[continuous_map; TOPSPACE_MTOPOLOGY] THEN SET_TAC[];
      STRIP_TAC THEN EXISTS_TAC `m':B metric`] THEN
    MATCH_MP_TAC(TAUT `(q \<Longrightarrow> p) \<and> q \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
     [DISCH_THEN(ASSUME_TAC \<circ> SYM) THEN
      UNDISCH_TAC `mcomplete(m::A metric)` THEN
      ASM_REWRITE_TAC[mcomplete; MCauchy; GSYM TOPSPACE_MTOPOLOGY] THEN
      DISCH_TAC THEN X_GEN_TAC `x::num=>B` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(g::B=>A) \<circ> (x::num=>B)`) THEN
      ASM_REWRITE_TAC[o_THM] THEN
      FIRST_X_ASSUM(STRIP_ASSUME_TAC \<circ>
        GEN_REWRITE_RULE id [homeomorphic_maps]) THEN
      ANTS_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[continuous_map]) THEN ASM SET_TAC[];
        DISCH_THEN(X_CHOOSE_TAC `y::A`)] THEN
      EXISTS_TAC `f y` THEN
      SUBGOAL_THEN `x = f \<circ> (g::B=>A) \<circ> (x::num=>B)` SUBST1_TAC THENL
       [REWRITE_TAC[FUN_EQ_THM; o_THM] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[continuous_map]) THEN ASM SET_TAC[];
        MATCH_MP_TAC CONTINUOUS_MAP_LIMIT THEN ASM_MESON_TAC[]];
      ALL_TAC] THEN
    REWRITE_TAC[TOPOLOGY_EQ; OPEN_IN_MTOPOLOGY] THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [HOMEOMORPHIC_MAPS_SYM]) THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP HOMEOMORPHIC_MAPS_IMP_MAP) THEN
    DISCH_THEN(fun th ->
      REWRITE_TAC[MATCH_MP HOMEOMORPHIC_MAP_OPENNESS_EQ th]) THEN
    X_GEN_TAC `v::B=>bool` THEN
    ASM_CASES_TAC `(v::B=>bool) \<subseteq> topspace X'` THEN
    ASM_REWRITE_TAC[] THEN
    EXPAND_TAC "X" THEN REWRITE_TAC[OPEN_IN_MTOPOLOGY] THEN
    ASM_REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
    ASM_REWRITE_TAC[IN_MBALL] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[homeomorphic_maps; continuous_map]) THEN
    MATCH_MP_TAC(TAUT `p \<and> (q \<longleftrightarrow> r) \<Longrightarrow> (p \<and> q \<longleftrightarrow> r)`) THEN
    CONJ_TAC THENL [ASM SET_TAC[]; EQ_TAC] THEN
    MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `b::B` THEN
    ASM_CASES_TAC `(b::B) \<in> v` THEN
    ASM_REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY] THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `r::real` THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[] THENL
     [X_GEN_TAC `y::B` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(g::B=>A) y`) THEN ASM SET_TAC[];
      ASM SET_TAC[]])
in

  REPEAT STRIP_TAC THEN EQ_TAC THEN MATCH_MP_TAC lemma THEN
  ASM_MESON_TAC[HOMEOMORPHIC_SPACE_SYM]);;

lemma completely_metrizable_space_retraction_map_image:
   "\<And>X X' (r::A=>B).
        retraction_map X X' r \<and> completely_metrizable_space X
        \<Longrightarrow> completely_metrizable_space X'"
oops
  MATCH_MP_TAC WEAKLY_HEREDITARY_IMP_RETRACTIVE_PROPERTY THEN
  REWRITE_TAC[HOMEOMORPHIC_COMPLETELY_METRIZABLE_SPACE] THEN
  REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_CLOSED_IN] THEN
  MESON_TAC[COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE;
            METRIZABLE_IMP_HAUSDORFF_SPACE]);;


text\<open> Product metric. For the nicest fit with the main Euclidean theories, we   \<close>
text\<open> make this the Euclidean product, though others would work topologically.  \<close>


let prod_metric = new_definition
 `prod_metric m1 m2 =
  metric((mspace m1 \<times> mspace m2):A#B=>bool,
         \<lambda>((x,y),(x',y')).
            sqrt(d x x' ^ 2 + d y y' ^ 2))`;;

lemma prod_metric:
 (`(!(m1::A metric) (m2::B metric).
      mspace(prod_metric m1 m2) = mspace m1 \<times> mspace m2) \<and>
   (!(m1::A metric) (m2::B metric).
        d(prod_metric m1 m2) =
        \<lambda>((x,y),(x',y')).
            sqrt(d x x' ^ 2 + d y y' ^ 2))"
oops
  REWRITE_TAC[AND_FORALL_THM] THEN REPEAT GEN_TAC THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> LAND_CONV) [mspace] THEN
  GEN_REWRITE_TAC (RAND_CONV \<circ> LAND_CONV) [d] THEN
  REWRITE_TAC[PAIR; GSYM PAIR_EQ] THEN REWRITE_TAC[prod_metric] THEN
  REWRITE_TAC[GSYM(CONJUNCT2 metric_tybij)] THEN
  REWRITE_TAC[is_metric_space; FORALL_PAIR_THM; IN_CROSS] THEN
  REPEAT CONJ_TAC THENL
   [SIMP_TAC[SQRT_POS_LE; REAL_LE_ADD; REAL_LE_POW_2];
    REWRITE_TAC[PAIR_EQ; SQRT_EQ_0] THEN SIMP_TAC[REAL_LE_POW_2; REAL_ARITH
     `0 \<le> x \<and> 0 \<le> y \<Longrightarrow> (x + y = 0 \<longleftrightarrow> x = 0 \<and> y = 0)`] THEN
    SIMP_TAC[REAL_POW_EQ_0; MDIST_0] THEN CONV_TAC NUM_REDUCE_CONV;
    SIMP_TAC[MDIST_SYM];
    MAP_EVERY X_GEN_TAC [`x1::A`; `y1::B`; `x2::A`; `y2::B`; `x3::A`; `y3::B`] THEN
    STRIP_TAC THEN MATCH_MP_TAC REAL_LE_LSQRT THEN
    ASM_SIMP_TAC[REAL_LE_ADD; SQRT_POS_LE; REAL_LE_POW_2] THEN
    REWRITE_TAC[REAL_ARITH
     `(a + b::real) ^ 2 = (a ^ 2 + b ^ 2) + 2 * a * b`] THEN
    SIMP_TAC[SQRT_POW_2; REAL_LE_ADD; REAL_LE_POW_2] THEN
    TRANS_TAC REAL_LE_TRANS
     `(d m1 (x1::A,x2) + d x2 x3) ^ 2 +
      (d m2 (y1::B,y2) + d y2 y3) ^ 2` THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC REAL_LE_ADD2 THEN CONJ_TAC THEN
      MATCH_MP_TAC REAL_POW_LE2 THEN
      ASM_MESON_TAC[MDIST_POS_LE; MDIST_TRIANGLE];
      REWRITE_TAC[REAL_ARITH
       `(x1 + x2) ^ 2 + (y1 + y2) ^ 2 \<le>
        ((x1 ^ 2 + y1 ^ 2) + (x2 ^ 2 + y2 ^ 2)) + 2 * b \<longleftrightarrow>
        x1 * x2 + y1 * y2 \<le> b`] THEN
      REWRITE_TAC[GSYM SQRT_MUL] THEN MATCH_MP_TAC REAL_LE_RSQRT THEN
      REWRITE_TAC[REAL_LE_POW_2; REAL_ARITH
        `(x1 * x2 + y1 * y2) ^ 2 \<le>
         (x1 ^ 2 + y1 ^ 2) * (x2 ^ 2 + y2 ^ 2) \<longleftrightarrow>
         0 \<le> (x1 * y2 - x2 * y1) ^ 2`]]]);;

lemma component_le_prod_metric:
   "        d x1 x2 \<le> d (prod_metric m1 m2) ((x1,y1),(x2,y2)) \<and>
        d y1 y2 \<le> d (prod_metric m1 m2) ((x1,y1),(x2,y2))"
oops
  REPEAT GEN_TAC THEN CONJ_TAC THEN REWRITE_TAC[PROD_METRIC] THEN
  MATCH_MP_TAC REAL_LE_RSQRT THEN REWRITE_TAC[REAL_LE_ADDR; REAL_LE_ADDL] THEN
  REWRITE_TAC[REAL_LE_POW_2]);;

lemma prod_metric_le_components:
   "        x1 \<in> mspace m1 \<and> x2 \<in> mspace m1 \<and>
        y1 \<in> mspace m2 \<and> y2 \<in> mspace m2
        \<Longrightarrow> d (prod_metric m1 m2) ((x1,y1),(x2,y2))
            \<le> d x1 x2 + d y1 y2"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[PROD_METRIC] THEN
  MATCH_MP_TAC REAL_LE_LSQRT THEN ASM_SIMP_TAC[REAL_LE_ADD; MDIST_POS_LE;
   REAL_ARITH `x ^ 2 + y ^ 2 \<le> (x + y) ^ 2 \<longleftrightarrow> 0 \<le> x * y`] THEN
  ASM_SIMP_TAC[REAL_LE_MUL; MDIST_POS_LE]);;

lemma mball_prod_metric_subset:
   "        mball (prod_metric m1 m2) ((x,y),r) \<subseteq>
        mball x r \<times> mball y r"
oops
  REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_MBALL; IN_CROSS;
              CONJUNCT1 PROD_METRIC] THEN
  MESON_TAC[COMPONENT_LE_PROD_METRIC; REAL_LET_TRANS]);;

lemma mcball_prod_metric_subset:
   "        mcball (prod_metric m1 m2) ((x,y),r) \<subseteq>
        mcball m1 (x,r) \<times> mcball m2 (y,r)"
oops
  REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_MCBALL; IN_CROSS;
              CONJUNCT1 PROD_METRIC] THEN
  MESON_TAC[COMPONENT_LE_PROD_METRIC; REAL_LE_TRANS]);;

lemma mball_subset_prod_metric:
   "\<And>m1 m2 x::A y::B r r'.
        mball x r \<times> mball y r'
        \<subseteq> mball (prod_metric m1 m2) ((x,y),r + r')"
oops
  REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_MBALL; IN_CROSS;
              CONJUNCT1 PROD_METRIC] THEN
  MESON_TAC[REAL_ARITH `x \<le> y + z \<and> y < a \<and> z < b \<Longrightarrow> x < a + b`;
            PROD_METRIC_LE_COMPONENTS]);;

lemma mcball_subset_prod_metric:
   "\<And>m1 m2 x::A y::B r r'.
        mcball m1 (x,r) \<times> mcball m2 (y,r')
        \<subseteq> mcball (prod_metric m1 m2) ((x,y),r + r')"
oops
  REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_MCBALL; IN_CROSS;
              CONJUNCT1 PROD_METRIC] THEN
  MESON_TAC[REAL_ARITH `x \<le> y + z \<and> y \<le> a \<and> z \<le> b \<Longrightarrow> x \<le> a + b`;
            PROD_METRIC_LE_COMPONENTS]);;

lemma mtopology_prod_metric:
   "\<And>(m1::A metric) (m2::B metric).
        mtopology(prod_metric m1 m2) =
        prod_topology (mtopology m1) (mtopology m2)"
oops
  REPEAT GEN_TAC THEN CONV_TAC SYM_CONV THEN REWRITE_TAC[prod_topology] THEN
  MATCH_MP_TAC TOPOLOGY_BASE_UNIQUE THEN
  REWRITE_TAC[SET_RULE `GSPEC a x \<longleftrightarrow> x \<in> GSPEC a`] THEN REPEAT CONJ_TAC THENL
   [REWRITE_TAC[FORALL_IN_GSPEC; OPEN_IN_MTOPOLOGY; PROD_METRIC] THEN
    MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::B=>bool`] THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[SUBSET_CROSS; FORALL_PAIR_THM; IN_CROSS] THEN
    MAP_EVERY X_GEN_TAC [`x::A`; `y::B`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::B`) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::A`) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `r1::real` THEN STRIP_TAC THEN
    X_GEN_TAC `r2::real` THEN STRIP_TAC THEN
    EXISTS_TAC `min r1 r2::real` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
    W(MP_TAC \<circ> PART_MATCH lhand MBALL_PROD_METRIC_SUBSET \<circ> lhand \<circ> snd) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_TRANS) THEN
    REWRITE_TAC[SUBSET_CROSS] THEN REPEAT DISJ2_TAC THEN CONJ_TAC;
    REWRITE_TAC[FORALL_PAIR_THM; EXISTS_IN_GSPEC] THEN
    MAP_EVERY X_GEN_TAC [`u::A#B=>bool`; `x::A`; `y::B`] THEN
    GEN_REWRITE_TAC (LAND_CONV \<circ> ONCE_DEPTH_CONV) [OPEN_IN_MTOPOLOGY] THEN
    DISCH_THEN(CONJUNCTS_THEN2 (CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC \<circ> SPEC `(x,y):A#B`)) ASSUME_TAC) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `r::real` THEN STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [`mball m1 (x::A,r / 2)`; `mball m2 (y::B,r / 2)`] THEN
    FIRST_ASSUM(MP_TAC \<circ> SPEC `(x,y):A#B` \<circ> REWRITE_RULE[\<subseteq>] \<circ>
     GEN_REWRITE_RULE RAND_CONV [CONJUNCT1 PROD_METRIC]) THEN
    ASM_REWRITE_TAC[IN_CROSS] THEN STRIP_TAC THEN
    ASM_SIMP_TAC[OPEN_IN_MBALL; IN_CROSS; CENTRE_IN_MBALL; REAL_HALF] THEN
    W(MP_TAC \<circ> PART_MATCH lhand MBALL_SUBSET_PROD_METRIC \<circ> lhand \<circ> snd) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_TRANS)] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP
   (REWRITE_RULE[IMP_CONJ_ALT] SUBSET_TRANS)) THEN
  MATCH_MP_TAC MBALL_SUBSET_CONCENTRIC THEN REAL_ARITH_TAC);;

lemma submetric_prod_metric:
   "\<And>m1 m2 s::A=>bool t::B=>bool.
        submetric (prod_metric m1 m2) (s \<times> t) =
        prod_metric (submetric1 s) (submetric2 t)"
oops
  REPEAT GEN_TAC THEN
  GEN_REWRITE_TAC RAND_CONV [prod_metric] THEN
  GEN_REWRITE_TAC LAND_CONV [submetric] THEN
  REWRITE_TAC[SUBMETRIC; PROD_METRIC; INTER_CROSS]);;

lemma metrizable_space_prod_topology:
   "        metrizable_space (prod_topology top1 top2) \<longleftrightarrow>
        topspace(prod_topology top1 top2) = {} \<or>
        metrizable_space top1 \<and> metrizable_space top2"
oops
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THENL
   [ASM_MESON_TAC[SUBTOPOLOGY_EQ_DISCRETE_TOPOLOGY_EMPTY;
                  METRIZABLE_SPACE_DISCRETE_TOPOLOGY];
    ASM_REWRITE_TAC[]] THEN
  EQ_TAC THENL
   [ALL_TAC; MESON_TAC[MTOPOLOGY_PROD_METRIC; metrizable_space]] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
  REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; LEFT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[FORALL_PAIR_THM; IN_CROSS] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `b::B`] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP METRIZABLE_SPACE_SUBTOPOLOGY) THENL
   [DISCH_THEN(MP_TAC \<circ> SPEC `(topspace top1 \<times> {b}):A#B=>bool`);
    DISCH_THEN(MP_TAC \<circ> SPEC `({a} \<times> topspace top2):A#B=>bool`)] THEN
  MATCH_MP_TAC EQ_IMP THEN MATCH_MP_TAC HOMEOMORPHIC_METRIZABLE_SPACE THEN
  REWRITE_TAC[SUBTOPOLOGY_CROSS; SUBTOPOLOGY_TOPSPACE] THENL
   [MATCH_MP_TAC PROD_TOPOLOGY_HOMEOMORPHIC_SPACE_LEFT;
    MATCH_MP_TAC PROD_TOPOLOGY_HOMEOMORPHIC_SPACE_RIGHT] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[]);;

lemma MCauchy_prod_metric:
   "\<And>m1 m2 x::num=>A#B.
        MCauchy (prod_metric m1 m2) x \<longleftrightarrow>
        MCauchy m1 (fst \<circ> x) \<and> MCauchy m2 (snd \<circ> x)"
oops
  REWRITE_TAC[FORALL_PAIR_FUN_THM] THEN MAP_EVERY X_GEN_TAC
   [`m1::A metric`; `m2::B metric`; `a::num=>A`; `b::num=>B`] THEN
  REWRITE_TAC[MCauchy; CONJUNCT1 PROD_METRIC; IN_CROSS; o_DEF] THEN
  ASM_CASES_TAC `\<forall>n. (a::num=>A) n \<in> mspace m1` THEN
  ASM_REWRITE_TAC[FORALL_AND_THM] THEN
  ASM_CASES_TAC `\<forall>n. (b::num=>B) n \<in> mspace m2` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THENL
   [ASM_MESON_TAC[COMPONENT_LE_PROD_METRIC; REAL_LET_TRANS];
    DISCH_TAC THEN X_GEN_TAC `e::real` THEN DISCH_TAC] THEN
  FIRST_X_ASSUM(CONJUNCTS_THEN (MP_TAC \<circ> SPEC `e / 2`)) THEN
  ASM_REWRITE_TAC[REAL_HALF; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `M::num` THEN DISCH_TAC THEN X_GEN_TAC `N::num` THEN DISCH_TAC THEN
  EXISTS_TAC `MAX M N` THEN
  REWRITE_TAC[ARITH_RULE `MAX M N \<le> n \<longleftrightarrow> M \<le> n \<and> N \<le> n`] THEN
  MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN STRIP_TAC THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`m::num`; `n::num`])) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(REAL_ARITH
   `z \<le> x + y \<Longrightarrow> x < e / 2 \<Longrightarrow> y < e / 2 \<Longrightarrow> z < e`) THEN
  ASM_MESON_TAC[PROD_METRIC_LE_COMPONENTS; REAL_ADD_SYM]);;

lemma mcomplete_prod_metric:
   "\<And>(m1::A metric) (m2::B metric).
        mcomplete (prod_metric m1 m2) \<longleftrightarrow>
        mspace m1 = {} \<or> mspace m2 = {} \<or> mcomplete m1 \<and> mcomplete m2"
oops
  REPEAT STRIP_TAC THEN MAP_EVERY ASM_CASES_TAC
   [`mspace m1::A=>bool = {}`; `mspace m2::B=>bool = {}`] THEN
  ASM_SIMP_TAC[MCOMPLETE_EMPTY_MSPACE; CONJUNCT1 PROD_METRIC; CROSS_EMPTY] THEN
  REWRITE_TAC[mcomplete; CAUCHY_IN_PROD_METRIC] THEN
  REWRITE_TAC[MTOPOLOGY_PROD_METRIC; LIMIT_PAIRWISE; EXISTS_PAIR_THM] THEN
  EQ_TAC THENL [ALL_TAC; ASM_MESON_TAC[]] THEN DISCH_TAC THEN CONJ_TAC THENL
   [X_GEN_TAC `x::num=>A` THEN DISCH_TAC THEN
    UNDISCH_TAC `\<not> (mspace m2::B=>bool = {})` THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `y::B` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(\<lambda>n. (x n,y)):num=>A#B`);
    X_GEN_TAC `y::num=>B` THEN DISCH_TAC THEN
    UNDISCH_TAC `\<not> (mspace m1::A=>bool = {})` THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(\<lambda>n. (x,y n)):num=>A#B`)] THEN
  ASM_REWRITE_TAC[o_DEF; ETA_AX; CAUCHY_IN_CONST] THEN MESON_TAC[]);;

lemma completely_metrizable_space_prod_topology:
   "        completely_metrizable_space (prod_topology top1 top2) \<longleftrightarrow>
        topspace(prod_topology top1 top2) = {} \<or>
        completely_metrizable_space top1 \<and> completely_metrizable_space top2"
oops
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC `topspace(prod_topology top1 top2):A#B=>bool = {}` THENL
   [ASM_MESON_TAC[SUBTOPOLOGY_EQ_DISCRETE_TOPOLOGY_EMPTY;
                  COMPLETELY_METRIZABLE_SPACE_DISCRETE_TOPOLOGY];
    ASM_REWRITE_TAC[]] THEN
  EQ_TAC THENL
   [ALL_TAC;
    REWRITE_TAC[completely_metrizable_space] THEN
    METIS_TAC[MCOMPLETE_PROD_METRIC; MTOPOLOGY_PROD_METRIC]] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
  REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; LEFT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[FORALL_PAIR_THM; IN_CROSS] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `b::B`] THEN REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP METRIZABLE_IMP_HAUSDORFF_SPACE \<circ>
     MATCH_MP COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE) THEN
  REWRITE_TAC[HAUSDORFF_SPACE_PROD_TOPOLOGY; TOPSPACE_PROD_TOPOLOGY] THEN
  REWRITE_TAC[EXTENSION; IN_ELIM_THM; IN_CROSS; FORALL_PAIR_THM] THEN
  (STRIP_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP
   (REWRITE_RULE[IMP_CONJ] COMPLETELY_METRIZABLE_SPACE_CLOSED_IN))
  THENL
   [DISCH_THEN(MP_TAC \<circ> SPEC `(topspace top1 \<times> {b}):A#B=>bool`);
    DISCH_THEN(MP_TAC \<circ> SPEC `({a} \<times> topspace top2):A#B=>bool`)] THEN
  REWRITE_TAC[CLOSED_IN_CROSS; CLOSED_IN_TOPSPACE] THEN
  ASM_SIMP_TAC[CLOSED_IN_HAUSDORFF_SING] THEN MATCH_MP_TAC EQ_IMP THEN
  MATCH_MP_TAC HOMEOMORPHIC_COMPLETELY_METRIZABLE_SPACE THEN
  REWRITE_TAC[SUBTOPOLOGY_CROSS; SUBTOPOLOGY_TOPSPACE] THENL
   [MATCH_MP_TAC PROD_TOPOLOGY_HOMEOMORPHIC_SPACE_LEFT;
    MATCH_MP_TAC PROD_TOPOLOGY_HOMEOMORPHIC_SPACE_RIGHT] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[]);;

lemma mbounded_cross:
   "\<And>(m1::A metric) (m2::B metric) s t.
        mbounded (prod_metric m1 m2) (s \<times> t) \<longleftrightarrow>
        s = {} \<or> t = {} \<or> mbounded m1 s \<and> mbounded m2 t"
oops
  REPEAT GEN_TAC THEN MAP_EVERY ASM_CASES_TAC
   [`s::A=>bool = {}`; `t::B=>bool = {}`] THEN
  ASM_REWRITE_TAC[MBOUNDED_EMPTY; CROSS_EMPTY] THEN
  REWRITE_TAC[mbounded; EXISTS_PAIR_THM] THEN MATCH_MP_TAC(MESON[]
   `(\<forall>x y. P x y \<longleftrightarrow> Q x \<and> R y)
    \<Longrightarrow> ((\<exists>x y. P x y) \<longleftrightarrow> (\<exists>x. Q x) \<and> (\<exists>y. R y))`) THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::B`] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_TAC `r::real`) THEN
    REWRITE_TAC[LEFT_AND_EXISTS_THM; RIGHT_AND_EXISTS_THM] THEN
    REPEAT(EXISTS_TAC `r::real`) THEN
    MATCH_MP_TAC(MESON[SUBSET_CROSS]
     `s \<times> t \<subseteq> u \<times> v \<and> (s \<noteq> {}) \<and> (t \<noteq> {})
      \<Longrightarrow> s \<subseteq> u \<and> t \<subseteq> v`) THEN
    ASM_MESON_TAC[SUBSET_TRANS; MCBALL_PROD_METRIC_SUBSET];
    DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_TAC `r1::real`) (X_CHOOSE_TAC `r2::real`)) THEN
    EXISTS_TAC `r1 + r2::real` THEN
    W(MP_TAC \<circ> PART_MATCH rand MCBALL_SUBSET_PROD_METRIC \<circ> rand \<circ> snd) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] SUBSET_TRANS) THEN
    ASM_REWRITE_TAC[SUBSET_CROSS]]);;

lemma mbounded_prod_metric:
   "\<And>(m1::A metric) (m2::B metric) u.
        mbounded (prod_metric m1 m2) u \<longleftrightarrow>
        mbounded m1 (fst ` u) \<and> mbounded m2 (snd ` u)"
oops
  REPEAT GEN_TAC THEN  EQ_TAC THENL
   [REWRITE_TAC[mbounded; \<subseteq>; FORALL_IN_IMAGE; FORALL_PAIR_THM] THEN
    REWRITE_TAC[EXISTS_PAIR_THM] THEN MATCH_MP_TAC(MESON[]
     `(\<forall>r x y. R x y r \<Longrightarrow> P x r \<and> Q y r)
      \<Longrightarrow> (\<exists>x y r. R x y r) \<Longrightarrow> (\<exists>x r. P x r) \<and> (\<exists>y r. Q y r)`) THEN
    MAP_EVERY X_GEN_TAC [`r::real`; `x::A`; `y::B`] THEN
    MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `x::A`; `y::B`; `r::real`]
        MCBALL_PROD_METRIC_SUBSET) THEN
    REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_CROSS] THEN MESON_TAC[];
    STRIP_TAC THEN MATCH_MP_TAC MBOUNDED_SUBSET THEN
    EXISTS_TAC `((fst ` u) \<times> (snd ` u)):A#B=>bool` THEN
    ASM_REWRITE_TAC[MBOUNDED_CROSS; IMAGE_EQ_EMPTY] THEN
    REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_CROSS] THEN
    REWRITE_TAC[IN_IMAGE; EXISTS_PAIR_THM] THEN MESON_TAC[]]);;

lemma mtotally_bounded_cross:
   "\<And>(m1::A metric) (m2::B metric) s t.
       mtotally_bounded (prod_metric m1 m2) (s \<times> t) \<longleftrightarrow>
       s = {} \<or> t = {} \<or> mtotally_bounded1 s \<and> mtotally_bounded2 t"
oops
  REPEAT GEN_TAC THEN MAP_EVERY ASM_CASES_TAC
   [`s::A=>bool = {}`; `t::B=>bool = {}`] THEN
  ASM_REWRITE_TAC[CROSS_EMPTY; TOTALLY_BOUNDED_IN_EMPTY] THEN
  REWRITE_TAC[TOTALLY_BOUNDED_IN_SEQUENTIALLY] THEN
  ASM_REWRITE_TAC[CONJUNCT1 PROD_METRIC; SUBSET_CROSS] THEN
  ASM_CASES_TAC `(s::A=>bool) \<subseteq> mspace m1` THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC `(t::B=>bool) \<subseteq> mspace m2` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THEN STRIP_TAC THEN TRY CONJ_TAC THENL
   [X_GEN_TAC `x::num=>A` THEN DISCH_TAC THEN
    UNDISCH_TAC `\<not> (t::B=>bool = {})` THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `y::B` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(\<lambda>n. (x n,y)):num=>A#B`) THEN
    ASM_REWRITE_TAC[IN_CROSS; CAUCHY_IN_PROD_METRIC] THEN
    MATCH_MP_TAC MONO_EXISTS THEN SIMP_TAC[o_DEF];
    X_GEN_TAC `y::num=>B` THEN DISCH_TAC THEN
    UNDISCH_TAC `\<not> (s::A=>bool = {})` THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(\<lambda>n. (x,y n)):num=>A#B`) THEN
    ASM_REWRITE_TAC[IN_CROSS; CAUCHY_IN_PROD_METRIC] THEN
    MATCH_MP_TAC MONO_EXISTS THEN SIMP_TAC[o_DEF];
    REWRITE_TAC[FORALL_PAIR_FUN_THM; IN_CROSS; FORALL_AND_THM] THEN
    MAP_EVERY X_GEN_TAC [`x::num=>A`; `y::num=>B`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::num=>A`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `r1::num=>num` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(y::num=>B) \<circ> (r1::num=>num)`) THEN
    ASM_REWRITE_TAC[o_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN `r2::num=>num` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(r1::num=>num) \<circ> (r2::num=>num)` THEN
    ASM_SIMP_TAC[o_THM; CAUCHY_IN_PROD_METRIC; o_ASSOC] THEN
    ONCE_REWRITE_TAC[o_ASSOC] THEN GEN_REWRITE_TAC
     (BINOP_CONV \<circ> RAND_CONV \<circ> LAND_CONV \<circ> LAND_CONV) [o_DEF] THEN
    ASM_REWRITE_TAC[ETA_AX] THEN ASM_SIMP_TAC[CAUCHY_IN_SUBSEQUENCE]]);;

lemma mtotally_bounded_prod_metric:
   "\<And>(m1::A metric) (m2::B metric) u.
        mtotally_bounded (prod_metric m1 m2) u \<longleftrightarrow>
        mtotally_bounded1 (fst ` u) \<and>
        mtotally_bounded2 (snd ` u)"
oops
  REPEAT GEN_TAC THEN  EQ_TAC THENL
   [REWRITE_TAC[TOTALLY_BOUNDED_IN_SEQUENTIALLY] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; FORALL_PAIR_THM] THEN
    REWRITE_TAC[CONJUNCT1 PROD_METRIC; IN_CROSS] THEN STRIP_TAC THEN
    CONJ_TAC THEN (CONJ_TAC THENL [ASM_MESON_TAC[]; ALL_TAC]) THEN
    SIMP_TAC[IN_IMAGE; SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    GEN_TAC THEN X_GEN_TAC `z::num=>A#B` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `z::num=>A#B`) THEN
    ASM_REWRITE_TAC[CAUCHY_IN_PROD_METRIC] THEN
    MATCH_MP_TAC MONO_EXISTS THEN ASM_SIMP_TAC[o_DEF];
    STRIP_TAC THEN MATCH_MP_TAC TOTALLY_BOUNDED_IN_SUBSET THEN
    EXISTS_TAC `((fst ` u) \<times> (snd ` u)):A#B=>bool` THEN
    ASM_REWRITE_TAC[TOTALLY_BOUNDED_IN_CROSS; IMAGE_EQ_EMPTY] THEN
    REWRITE_TAC[\<subseteq>; FORALL_PAIR_THM; IN_CROSS] THEN
    REWRITE_TAC[IN_IMAGE; EXISTS_PAIR_THM] THEN MESON_TAC[]]);;


text\<open> Three more restrictive notions of continuity for metric spaces.           \<close>


let lipschitz_continuous_map = new_definition
 `lipschitz_continuous_map m1 m2 f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> mspace m2 \<and>
        \<exists>B. \<forall>x y. x \<in> mspace m1 \<and> y \<in> mspace m1
                  \<Longrightarrow> d m2 (f x,f y) \<le> B * d x y`;;

lemma lipschitz_continuous_map_pos:
   "\<And>m1 m2 f::A=>B.
        lipschitz_continuous_map m1 m2 f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> mspace m2 \<and>
        \<exists>B. 0 < B \<and>
            \<forall>x y. x \<in> mspace m1 \<and> y \<in> mspace m1
                  \<Longrightarrow> d m2 (f x,f y) \<le> B * d x y"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[lipschitz_continuous_map] THEN
  AP_TERM_TAC THEN EQ_TAC THENL [ALL_TAC; MESON_TAC[]] THEN
  DISCH_THEN(X_CHOOSE_THEN `B::real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `abs B + 1` THEN CONJ_TAC THENL [REAL_ARITH_TAC; ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
  TRANS_TAC REAL_LE_TRANS `B * d m1 (x::A,y)` THEN
  ASM_SIMP_TAC[] THEN MATCH_MP_TAC REAL_LE_RMUL THEN
  ASM_SIMP_TAC[MDIST_POS_LE] THEN REAL_ARITH_TAC);;

lemma lipschitz_continuous_map_eq:
   "      (\<forall>x. x \<in> mspace m1 \<Longrightarrow> f x = g x) \<and> lipschitz_continuous_map m1 m2 f
      \<Longrightarrow> lipschitz_continuous_map m1 m2 g"
oops
  REWRITE_TAC[lipschitz_continuous_map] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IMP_CONJ] THEN SIMP_TAC[]);;

lemma lipschitz_continuous_map_from_submetric:
   "\<And>m1 m2 s f::A=>B.
        lipschitz_continuous_map m1 m2 f
        \<Longrightarrow> lipschitz_continuous_map (submetric1 s,m2) f"
oops
  REWRITE_TAC[lipschitz_continuous_map; SUBMETRIC] THEN SET_TAC[]);;

lemma lipschitz_continuous_map_from_submetric_mono:
   "           lipschitz_continuous_map (submetric1 t,m2) f \<and> s \<subseteq> t
           \<Longrightarrow> lipschitz_continuous_map (submetric1 s,m2) f"
oops
  MESON_TAC[LIPSCHITZ_CONTINUOUS_MAP_FROM_SUBMETRIC; SUBMETRIC_SUBMETRIC;
            SET_RULE `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`]);;

lemma lipschitz_continuous_map_into_submetric:
   "\<And>m1 m2 s f::A=>B.
        lipschitz_continuous_map m1 (submetric2 s) f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> s \<and>
        lipschitz_continuous_map m1 m2 f"
oops
  REWRITE_TAC[lipschitz_continuous_map; SUBMETRIC] THEN SET_TAC[]);;

lemma lipschitz_continuous_map_const:
   "        lipschitz_continuous_map m1 m2 (\<lambda>x. c) \<longleftrightarrow>
        mspace m1 = {} \<or> c \<in> mspace m2"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[lipschitz_continuous_map] THEN
  ASM_CASES_TAC `mspace m1::A=>bool = {}` THEN
  ASM_REWRITE_TAC[IMAGE_CLAUSES; EMPTY_SUBSET; NOT_IN_EMPTY] THEN
  ASM_CASES_TAC `(c::B) \<in> mspace m2` THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  EXISTS_TAC `1` THEN ASM_SIMP_TAC[MDIST_REFL; MDIST_POS_LE; REAL_MUL_LID]);;

lemma lipschitz_continuous_map_id:
   "lipschitz_continuous_map m1 m1 (\<lambda>x. x)"
oops
  REWRITE_TAC[lipschitz_continuous_map; IMAGE_ID; SUBSET_REFL] THEN
  GEN_TAC THEN EXISTS_TAC `1` THEN REWRITE_TAC[REAL_LE_REFL; REAL_MUL_LID]);;

lemma lipschitz_continuous_map_compose:
   "\<And>m1 m2 m3 f::A=>B g::B=>C.
      lipschitz_continuous_map m1 m2 f \<and> lipschitz_continuous_map m2 m3 g
      \<Longrightarrow> lipschitz_continuous_map m1 m3 (g \<circ> f)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_POS] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IMP_CONJ; LEFT_IMP_EXISTS_THM] THEN
  DISCH_TAC THEN X_GEN_TAC `B::real` THEN REPEAT DISCH_TAC THEN
  X_GEN_TAC `C::real` THEN REPEAT DISCH_TAC THEN ASM_SIMP_TAC[o_THM] THEN
  EXISTS_TAC `C * B::real` THEN ASM_SIMP_TAC[REAL_LT_MUL] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN REPEAT DISCH_TAC THEN
  TRANS_TAC REAL_LE_TRANS `C * d m2 (f x,f y)` THEN
  ASM_SIMP_TAC[GSYM REAL_MUL_ASSOC; REAL_LE_LMUL_EQ]);;

let uniformly_continuous_map = new_definition
 `uniformly_continuous_map m1 m2 f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> mspace m2 \<and>
        \<forall>e. 0 < e
            \<Longrightarrow> \<exists>d. 0 < d \<and>
                    !x x'. x \<in> mspace m1 \<and> x' \<in> mspace m1 \<and>
                           d x' x < d
                           \<Longrightarrow> d m2 (f x',f x) < e`;;

let UNIFORMLY_CONTINUOUS_MAP_SEQUENTIALLY,
    UNIFORMLY_CONTINUOUS_MAP_SEQUENTIALLY_ALT = (CONJ_PAIR \<circ> prove)
 (`(\<forall>m1 m2 f::A=>B.
        uniformly_continuous_map m1 m2 f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> mspace m2 \<and>
        \<forall>x y. (\<forall>n. x n \<in> mspace m1) \<and> (\<forall>n. y n \<in> mspace m1) \<and>
              tendsto (\<lambda>n. d m1 (x n,y n)) 0 sequentially
              \<Longrightarrow> tendsto
                    (\<lambda>n. d m2 (f(x n),f(y n))) 0 sequentially) \<and>
   (\<forall>m1 m2 f::A=>B.
        uniformly_continuous_map m1 m2 f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> mspace m2 \<and>
        \<forall>e x y. 0 < e \<and> (\<forall>n. x n \<in> mspace m1) \<and> (\<forall>n. y n \<in> mspace m1) \<and>
                tendsto (\<lambda>n. d m1 (x n,y n)) 0 sequentially
                \<Longrightarrow> \<exists>n. d m2 (f(x n),f(y n)) < e)"
oops
  REWRITE_TAC[AND_FORALL_THM] THEN REPEAT GEN_TAC THEN
  MATCH_MP_TAC(TAUT
   `(p \<Longrightarrow> q) \<and> (q \<Longrightarrow> r) \<and> (r \<Longrightarrow> p)
    \<Longrightarrow> (p \<longleftrightarrow> q) \<and> (p \<longleftrightarrow> r)`) THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[uniformly_continuous_map; \<subseteq>; FORALL_IN_IMAGE] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
    REWRITE_TAC[LIMIT_METRIC; EVENTUALLY_SEQUENTIALLY] THEN
    REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV; IMP_CONJ] THEN
    ASM_SIMP_TAC[MDIST_POS_LE; REAL_ARITH `0 \<le> x \<Longrightarrow> abs(0 - x) = x`] THEN
    ASM_MESON_TAC[];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    MAP_EVERY X_GEN_TAC [`e::real`; `x::num=>A`; `y::num=>A`] THEN
    STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x::num=>A`; `y::num=>A`]) THEN
    ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
    REWRITE_TAC[LIMIT_METRIC] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `e::real` \<circ> CONJUNCT2) THEN
    ASM_REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP EVENTUALLY_HAPPENS) THEN
    REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN
    ASM_SIMP_TAC[MDIST_POS_LE; REAL_ARITH `0 \<le> x \<Longrightarrow> abs(0 - x) = x`];
    REWRITE_TAC[uniformly_continuous_map; \<subseteq>; FORALL_IN_IMAGE] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `e::real` THEN
    ONCE_REWRITE_TAC[TAUT `p \<Longrightarrow> q \<Longrightarrow> r \<longleftrightarrow> q \<Longrightarrow> \<not> r \<Longrightarrow> \<not> p`] THEN
    DISCH_TAC THEN REWRITE_TAC[NOT_EXISTS_THM] THEN
    DISCH_THEN(MP_TAC \<circ> GEN `n::num` \<circ> SPEC `inverse(Suc n)`) THEN
    REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
    REWRITE_TAC[NOT_FORALL_THM; NOT_IMP; SKOLEM_THM] THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `x::num=>A` THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `y::num=>A` THEN
    REWRITE_TAC[AND_FORALL_THM; REAL_NOT_LT] THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[NOT_EXISTS_THM] THEN CONJ_TAC THENL
     [ALL_TAC; ASM_MESON_TAC[MDIST_SYM; REAL_NOT_LT]] THEN
    MATCH_MP_TAC LIMIT_NULL_REAL_COMPARISON THEN
    EXISTS_TAC `\<lambda>n. inverse(Suc n)` THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY; LIMIT_NULL_REAL_HARMONIC_OFFSET] THEN
    EXISTS_TAC `0` THEN X_GEN_TAC `n::num` THEN DISCH_TAC THEN
    ASM_SIMP_TAC[REAL_ABS_INV; REAL_ARITH `abs(Suc n) = n + 1`;
      METRIC_ARITH `x \<in> M \<and> y \<in> M
                    \<Longrightarrow> abs(d x y) = d y x`] THEN
    ASM_SIMP_TAC[REAL_LT_IMP_LE]]);;

lemma uniformly_continuous_map_eq:
   "      (\<forall>x. x \<in> mspace m1 \<Longrightarrow> f x = g x) \<and> uniformly_continuous_map m1 m2 f
      \<Longrightarrow> uniformly_continuous_map m1 m2 g"
oops
  REWRITE_TAC[uniformly_continuous_map] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IMP_CONJ] THEN SIMP_TAC[]);;

lemma uniformly_continuous_map_from_submetric:
   "\<And>m1 m2 s f::A=>B.
        uniformly_continuous_map m1 m2 f
        \<Longrightarrow> uniformly_continuous_map (submetric1 s,m2) f"
oops
  REWRITE_TAC[uniformly_continuous_map; SUBMETRIC] THEN SET_TAC[]);;

lemma uniformly_continuous_map_from_submetric_mono:
   "           uniformly_continuous_map (submetric1 t,m2) f \<and> s \<subseteq> t
           \<Longrightarrow> uniformly_continuous_map (submetric1 s,m2) f"
oops
  MESON_TAC[UNIFORMLY_CONTINUOUS_MAP_FROM_SUBMETRIC; SUBMETRIC_SUBMETRIC;
            SET_RULE `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`]);;

lemma uniformly_continuous_map_into_submetric:
   "\<And>m1 m2 s f::A=>B.
        uniformly_continuous_map m1 (submetric2 s) f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> s \<and>
        uniformly_continuous_map m1 m2 f"
oops
  REWRITE_TAC[uniformly_continuous_map; SUBMETRIC] THEN SET_TAC[]);;

lemma uniformly_continuous_map_const:
   "        uniformly_continuous_map m1 m2 (\<lambda>x. c) \<longleftrightarrow>
        mspace m1 = {} \<or> c \<in> mspace m2"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_map] THEN
  ASM_CASES_TAC `mspace m1::A=>bool = {}` THEN
  ASM_REWRITE_TAC[IMAGE_CLAUSES; EMPTY_SUBSET; NOT_IN_EMPTY] THENL
   [MESON_TAC[]; ALL_TAC] THEN
  ASM_CASES_TAC `(c::B) \<in> mspace m2` THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  ASM_SIMP_TAC[MDIST_REFL] THEN MESON_TAC[]);;

lemma uniformly_continuous_map_real_const:
   "uniformly_continuous_map m real_euclidean_metric (\<lambda>x::A. c)"
oops
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_CONST; REAL_EUCLIDEAN_METRIC; IN_UNIV]);;

lemma uniformly_continuous_map_id:
   "uniformly_continuous_map m1 m1 (\<lambda>x. x)"
oops
  REWRITE_TAC[uniformly_continuous_map; IMAGE_ID; SUBSET_REFL] THEN
  MESON_TAC[]);;

lemma uniformly_continuous_map_compose:
   "\<And>m1 m2 f::A=>B g::B=>C.
    uniformly_continuous_map m1 m2 f \<and> uniformly_continuous_map m2 m3 g
    \<Longrightarrow> uniformly_continuous_map m1 m3 (g \<circ> f)"
oops
  REWRITE_TAC[uniformly_continuous_map; o_DEF; \<subseteq>; FORALL_IN_IMAGE] THEN
  REPEAT GEN_TAC THEN SIMP_TAC[CONJ_ASSOC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `e::real` THEN ASM_MESON_TAC[]);;

let cauchy_continuous_map = new_definition
 `cauchy_continuous_map m1 m2 f \<longleftrightarrow>
        \<forall>x. MCauchy m1 x \<Longrightarrow> MCauchy m2 (f \<circ> x)`;;

lemma cauchy_continuous_map_image:
   "\<And>m1 m2 f::A=>B.
        cauchy_continuous_map m1 m2 f
        \<Longrightarrow> image f (mspace m1) \<subseteq> mspace m2"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN
  X_GEN_TAC `a::A` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `(\<lambda>n. a):num=>A` \<circ>
    REWRITE_RULE[cauchy_continuous_map]) THEN
  ASM_REWRITE_TAC[o_DEF; CAUCHY_IN_CONST]);;

lemma cauchy_continuous_map_eq:
   "      (\<forall>x. x \<in> mspace m1 \<Longrightarrow> f x = g x) \<and> cauchy_continuous_map m1 m2 f
      \<Longrightarrow> cauchy_continuous_map m1 m2 g"
oops
  REWRITE_TAC[cauchy_continuous_map; MCauchy; o_DEF; IMP_CONJ] THEN
  SIMP_TAC[]);;

lemma cauchy_continuous_map_from_submetric:
   "\<And>m1 m2 s f::A=>B.
        cauchy_continuous_map m1 m2 f
        \<Longrightarrow> cauchy_continuous_map (submetric1 s,m2) f"
oops
  SIMP_TAC[cauchy_continuous_map; CAUCHY_IN_SUBMETRIC]);;

lemma cauchy_continuous_map_from_submetric_mono:
   "           cauchy_continuous_map (submetric1 t,m2) f \<and> s \<subseteq> t
           \<Longrightarrow> cauchy_continuous_map (submetric1 s,m2) f"
oops
  MESON_TAC[CAUCHY_CONTINUOUS_MAP_FROM_SUBMETRIC; SUBMETRIC_SUBMETRIC;
            SET_RULE `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`]);;

lemma cauchy_continuous_map_into_submetric:
   "\<And>m1 m2 s f::A=>B.
        cauchy_continuous_map m1 (submetric2 s) f \<longleftrightarrow>
        image f (mspace m1) \<subseteq> s \<and>
        cauchy_continuous_map m1 m2 f"
oops
  REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THENL
   [CONJ_TAC THENL
     [FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
      REWRITE_TAC[SUBMETRIC] THEN SET_TAC[];
      POP_ASSUM MP_TAC THEN
      SIMP_TAC[cauchy_continuous_map; CAUCHY_IN_SUBMETRIC; o_THM]];
    REPEAT(POP_ASSUM MP_TAC) THEN
    SIMP_TAC[cauchy_continuous_map; CAUCHY_IN_SUBMETRIC; o_THM] THEN
    REWRITE_TAC[MCauchy] THEN SET_TAC[]]);;

lemma cauchy_continuous_map_const:
   "        cauchy_continuous_map m1 m2 (\<lambda>x. c) \<longleftrightarrow>
        mspace m1 = {} \<or> c \<in> mspace m2"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[cauchy_continuous_map] THEN
  REWRITE_TAC[o_DEF; CAUCHY_IN_CONST] THEN
  ASM_CASES_TAC `(c::B) \<in> mspace m2` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THENL [ALL_TAC; SIMP_TAC[MCauchy; NOT_IN_EMPTY]] THEN
  GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `a::A` THEN DISCH_TAC THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `(\<lambda>n. a):num=>A`) THEN
  ASM_REWRITE_TAC[CAUCHY_IN_CONST]);;

lemma cauchy_continuous_map_real_const:
   "cauchy_continuous_map m real_euclidean_metric (\<lambda>x::A. c)"
oops
  REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_CONST; REAL_EUCLIDEAN_METRIC; IN_UNIV]);;

lemma cauchy_continuous_map_id:
   "cauchy_continuous_map m1 m1 (\<lambda>x. x)"
oops
  REWRITE_TAC[cauchy_continuous_map; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_compose:
   "\<And>m1 m2 f::A=>B g::B=>C.
    cauchy_continuous_map m1 m2 f \<and> cauchy_continuous_map m2 m3 g
    \<Longrightarrow> cauchy_continuous_map m1 m3 (g \<circ> f)"
oops
  REWRITE_TAC[cauchy_continuous_map; o_DEF; \<subseteq>; FORALL_IN_IMAGE] THEN
  REPEAT GEN_TAC THEN SIMP_TAC[CONJ_ASSOC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `e::real` THEN ASM_MESON_TAC[]);;

lemma lipschitz_imp_uniformly_continuous_map:
   "\<And>m1 m2 f::A=>B.
        lipschitz_continuous_map m1 m2 f
        \<Longrightarrow> uniformly_continuous_map m1 m2 f"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_POS; uniformly_continuous_map] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC
   (X_CHOOSE_THEN `B::real` STRIP_ASSUME_TAC)) THEN
  ASM_REWRITE_TAC[] THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  EXISTS_TAC `e / B::real` THEN
  ASM_SIMP_TAC[REAL_LT_RDIV_EQ; REAL_MUL_LZERO] THEN
  ASM_MESON_TAC[REAL_LET_TRANS; REAL_MUL_SYM]);;

lemma uniformly_imp_cauchy_continuous_map:
   "\<And>m1 m2 f::A=>B.
        uniformly_continuous_map m1 m2 f
        \<Longrightarrow> cauchy_continuous_map m1 m2 f"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[uniformly_continuous_map; cauchy_continuous_map] THEN
  STRIP_TAC THEN X_GEN_TAC `x::num=>A` THEN REWRITE_TAC[MCauchy] THEN
  STRIP_TAC THEN REWRITE_TAC[o_THM] THEN ASM SET_TAC[]);;

lemma locally_cauchy_continuous_map:
   "\<And>m1 m2 e f::A=>B.
        0 < e \<and>
        (\<forall>x. x \<in> mspace m1
             \<Longrightarrow> cauchy_continuous_map (submetric1 (mball x e),m2) f)
        \<Longrightarrow> cauchy_continuous_map m1 m2 f"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[cauchy_continuous_map] THEN
  X_GEN_TAC `x::num=>A` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [MCauchy]) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `e::real`)) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `M::num` THEN STRIP_TAC THEN
  MATCH_MP_TAC CAUCHY_IN_OFFSET THEN EXISTS_TAC `M::num` THEN CONJ_TAC THENL
   [X_GEN_TAC `n::num` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(x::num=>A) n`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
    ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; SUBMETRIC; SUBMETRIC; o_THM;
                 IN_INTER; CENTRE_IN_MBALL];
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `(x::num=>A) M`) THEN
    ASM_REWRITE_TAC[cauchy_continuous_map; o_DEF] THEN
    DISCH_THEN MATCH_MP_TAC THEN
    ASM_REWRITE_TAC[CAUCHY_IN_SUBMETRIC; IN_MBALL] THEN
    ASM_SIMP_TAC[LE_ADD; LE_REFL] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
    MATCH_MP_TAC CAUCHY_IN_SUBSEQUENCE THEN
    ASM_REWRITE_TAC[LT_ADD_LCANCEL]]);;

lemma cauchy_continuous_imp_continuous_map:
   "\<And>m1 m2 f::A=>B.
        cauchy_continuous_map m1 m2 f
        \<Longrightarrow> continuous_map (mtopology m1,mtopology m2) f"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF] THEN
  X_GEN_TAC `a::A` THEN REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN DISCH_TAC THEN
  REWRITE_TAC[LIMIT_ATPOINTOF_SEQUENTIALLY] THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `x::num=>A` THEN REWRITE_TAC[IN_DELETE; FORALL_AND_THM] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> SPEC
   `\<lambda>n. if even n then x(n div 2) else a::A` \<circ>
   REWRITE_RULE[cauchy_continuous_map]) THEN
  ASM_SIMP_TAC[o_DEF; COND_RAND; CAUCHY_IN_INTERLEAVING]);;

lemma uniformly_continuous_imp_continuous_map:
   "\<And>m1 m2 f::A=>B.
        uniformly_continuous_map m1 m2 f
        \<Longrightarrow> continuous_map (mtopology m1,mtopology m2) f"
oops
  MESON_TAC[UNIFORMLY_IMP_CAUCHY_CONTINUOUS_MAP;
            CAUCHY_CONTINUOUS_IMP_CONTINUOUS_MAP]);;

lemma lipschitz_continuous_imp_continuous_map:
   "\<And>m1 m2 f::A=>B.
        lipschitz_continuous_map m1 m2 f
        \<Longrightarrow> continuous_map (mtopology m1,mtopology m2) f"
oops
  SIMP_TAC[UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS_MAP;
           LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP]);;

lemma lipschitz_imp_cauchy_continuous_map:
   "\<And>m1 m2 f::A=>B.
        lipschitz_continuous_map m1 m2 f
        \<Longrightarrow> cauchy_continuous_map m1 m2 f"
oops
  SIMP_TAC[LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP;
           UNIFORMLY_IMP_CAUCHY_CONTINUOUS_MAP]);;

lemma continuous_imp_cauchy_continuous_map:
   "\<And>m1 m2 f::A=>B.
        mcomplete m1 \<and>
        continuous_map (mtopology m1,mtopology m2) f
        \<Longrightarrow> cauchy_continuous_map m1 m2 f"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[cauchy_continuous_map] THEN
  X_GEN_TAC `x::num=>A` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `x::num=>A` \<circ> REWRITE_RULE[mcomplete]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC `y::A` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP
   (REWRITE_RULE[IMP_CONJ] (ISPEC `sequentially` CONTINUOUS_MAP_LIMIT))) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`x::num=>A`; `y::A`]) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
        CONVERGENT_IMP_CAUCHY_IN)) THEN
  RULE_ASSUM_TAC(REWRITE_RULE
   [continuous_map; TOPSPACE_MTOPOLOGY; MCauchy]) THEN
  REWRITE_TAC[o_DEF] THEN ASM SET_TAC[]);;

lemma cauchy_imp_uniformly_continuous_map:
   "\<And>m1 m2 f::A=>B.
        mtotally_bounded1 (mspace m1) \<and>
        cauchy_continuous_map m1 m2 f
        \<Longrightarrow> uniformly_continuous_map m1 m2 f"
oops
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_SEQUENTIALLY_ALT] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC[] THEN
  MAP_EVERY X_GEN_TAC [`e::real`; `x::num=>A`; `y::num=>A`] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `x::num=>A` \<circ> CONJUNCT2 \<circ>
   REWRITE_RULE[TOTALLY_BOUNDED_IN_SEQUENTIALLY]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `r1::num=>num` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `(y::num=>A) \<circ> (r1::num=>num)` \<circ> CONJUNCT2 \<circ>
   REWRITE_RULE[TOTALLY_BOUNDED_IN_SEQUENTIALLY]) THEN
  ASM_REWRITE_TAC[o_THM; GSYM o_ASSOC; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `r2::num=>num` THEN STRIP_TAC THEN
  ABBREV_TAC `r = (r1::num=>num) \<circ> (r2::num=>num)` THEN
  SUBGOAL_THEN `\<forall>m n. m < n \<Longrightarrow> (r::num=>num) m < r n` ASSUME_TAC THENL
   [EXPAND_TAC "r" THEN REWRITE_TAC[o_DEF] THEN ASM_MESON_TAC[]; ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC \<circ>
   SPEC `\<lambda>n. if even n then (x \<circ> r) (n div 2):A
             else (y \<circ> (r::num=>num)) (n div 2)` \<circ>
   REWRITE_RULE[cauchy_continuous_map]) THEN
  ASM_REWRITE_TAC[CAUCHY_IN_INTERLEAVING_GEN; ETA_AX] THEN ANTS_TAC THENL
   [EXPAND_TAC "r" THEN REWRITE_TAC[o_ASSOC] THEN
    ASM_SIMP_TAC[CAUCHY_IN_SUBSEQUENCE] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `r::num=>num` \<circ>
      MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT] LIMIT_SUBSEQUENCE)) THEN
    ASM_REWRITE_TAC[GSYM o_ASSOC] THEN REWRITE_TAC[o_DEF];
    ONCE_REWRITE_TAC[o_DEF] THEN
    REWRITE_TAC[COND_RAND; CAUCHY_IN_INTERLEAVING_GEN] THEN
    DISCH_THEN(MP_TAC \<circ> CONJUNCT2 \<circ> CONJUNCT2) THEN
    REWRITE_TAC[LIMIT_NULL_REAL] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `e::real`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP EVENTUALLY_HAPPENS) THEN
    REWRITE_TAC[o_DEF; TRIVIAL_LIMIT_SEQUENTIALLY] THEN
    ASM_SIMP_TAC[real_abs; MDIST_POS_LE] THEN MESON_TAC[]]);;

lemma continuous_imp_uniformly_continuous_map:
   "\<And>m1 m2 f::A=>B.
        compact_space (mtopology m1) \<and>
        continuous_map (mtopology m1,mtopology m2) f
        \<Longrightarrow> uniformly_continuous_map m1 m2 f"
oops
  REWRITE_TAC[COMPACT_SPACE_EQ_MCOMPLETE_TOTALLY_BOUNDED_IN] THEN
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CAUCHY_IMP_UNIFORMLY_CONTINUOUS_MAP THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_IMP_CAUCHY_CONTINUOUS_MAP THEN
  ASM_REWRITE_TAC[]);;

lemma continuous_eq_cauchy_continuous_map:
   "\<And>m1 m2 f::A=>B.
        mcomplete m1
        \<Longrightarrow> (continuous_map (mtopology m1,mtopology m2) f \<longleftrightarrow>
             cauchy_continuous_map m1 m2 f)"
oops
  MESON_TAC[CONTINUOUS_IMP_CAUCHY_CONTINUOUS_MAP;
            CAUCHY_CONTINUOUS_IMP_CONTINUOUS_MAP]);;

lemma continuous_eq_uniformly_continuous_map:
   "\<And>m1 m2 f::A=>B.
        compact_space (mtopology m1)
        \<Longrightarrow> (continuous_map (mtopology m1,mtopology m2) f \<longleftrightarrow>
             uniformly_continuous_map m1 m2 f)"
oops
  MESON_TAC[CONTINUOUS_IMP_UNIFORMLY_CONTINUOUS_MAP;
            UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS_MAP]);;

lemma cauchy_eq_uniformly_continuous_map:
   "\<And>m1 m2 f::A=>B.
        mtotally_bounded1 (mspace m1)
        \<Longrightarrow> (cauchy_continuous_map m1 m2 f \<longleftrightarrow>
             uniformly_continuous_map m1 m2 f)"
oops
  MESON_TAC[CAUCHY_IMP_UNIFORMLY_CONTINUOUS_MAP;
            UNIFORMLY_IMP_CAUCHY_CONTINUOUS_MAP]);;

lemma lipschitz_continuous_map_projections:
 (`(\<forall>m1::A metric m2::B metric.
        lipschitz_continuous_map (prod_metric m1 m2,m1) fst) \<and>
   (\<forall>m1::A metric m2::B metric.
        lipschitz_continuous_map (prod_metric m1 m2,m2) snd)"
oops
  CONJ_TAC THEN REPEAT GEN_TAC THEN REWRITE_TAC[lipschitz_continuous_map] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; CONJUNCT1 PROD_METRIC] THEN
  SIMP_TAC[FORALL_PAIR_THM; IN_CROSS] THEN EXISTS_TAC `1` THEN
  REWRITE_TAC[REAL_MUL_LID; COMPONENT_LE_PROD_METRIC]);;

lemma lipschitz_continuous_map_pairwise:
   "\<And>m m1 m2 (f::A=>B#C).
        lipschitz_continuous_map m (prod_metric m1 m2) f \<longleftrightarrow>
        lipschitz_continuous_map m m1 (fst \<circ> f) \<and>
        lipschitz_continuous_map m m2 (snd \<circ> f)"
oops
  REWRITE_TAC[FORALL_AND_THM; TAUT `(p \<longleftrightarrow> q) \<longleftrightarrow> (p \<Longrightarrow> q) \<and> (q \<Longrightarrow> p)`] THEN
  CONJ_TAC THENL
   [MESON_TAC[LIPSCHITZ_CONTINUOUS_MAP_COMPOSE;
              LIPSCHITZ_CONTINUOUS_MAP_PROJECTIONS];
    REPLICATE_TAC 3 GEN_TAC THEN
    REWRITE_TAC[FORALL_PAIR_FUN_THM; o_DEF; ETA_AX] THEN
    MAP_EVERY X_GEN_TAC [`x::A=>B`; `y::A=>C`] THEN
    REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_POS] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; CONJUNCT1 PROD_METRIC] THEN
    DISCH_THEN(CONJUNCTS_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_SIMP_TAC[IN_CROSS; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `B::real` THEN STRIP_TAC THEN
    X_GEN_TAC `C::real` THEN STRIP_TAC THEN EXISTS_TAC `B + C::real` THEN
    ASM_SIMP_TAC[REAL_LT_ADD] THEN REPEAT STRIP_TAC THEN
    W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) PROD_METRIC_LE_COMPONENTS \<circ>
      lhand \<circ> snd) THEN
    ASM_SIMP_TAC[] THEN MATCH_MP_TAC(REAL_ARITH
     `y \<le> c * m \<and> z \<le> b * m \<Longrightarrow> x \<le> y + z \<Longrightarrow> x \<le> (b + c) * m`) THEN
    ASM_SIMP_TAC[]]);;

lemma uniformly_continuous_map_pairwise:
   "\<And>m m1 m2 (f::A=>B#C).
        uniformly_continuous_map m (prod_metric m1 m2) f \<longleftrightarrow>
        uniformly_continuous_map m m1 (fst \<circ> f) \<and>
        uniformly_continuous_map m m2 (snd \<circ> f)"
oops
  REWRITE_TAC[FORALL_AND_THM; TAUT `(p \<longleftrightarrow> q) \<longleftrightarrow> (p \<Longrightarrow> q) \<and> (q \<Longrightarrow> p)`] THEN
  CONJ_TAC THENL
   [MESON_TAC[UNIFORMLY_CONTINUOUS_MAP_COMPOSE;
              LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP;
              LIPSCHITZ_CONTINUOUS_MAP_PROJECTIONS];
    REPLICATE_TAC 3 GEN_TAC THEN
    REWRITE_TAC[FORALL_PAIR_FUN_THM; o_DEF; ETA_AX] THEN
    MAP_EVERY X_GEN_TAC [`x::A=>B`; `y::A=>C`] THEN
    REWRITE_TAC[uniformly_continuous_map] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; CONJUNCT1 PROD_METRIC] THEN
    DISCH_THEN(CONJUNCTS_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_SIMP_TAC[IN_CROSS; IMP_IMP] THEN DISCH_TAC THEN
    X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(CONJUNCTS_THEN(MP_TAC \<circ> SPEC `e / 2`)) THEN
    ASM_REWRITE_TAC[REAL_HALF; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `d1::real` THEN STRIP_TAC THEN
    X_GEN_TAC `d2::real` THEN STRIP_TAC THEN
    EXISTS_TAC `min d1 d2::real` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
    REPEAT STRIP_TAC THEN
    W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) PROD_METRIC_LE_COMPONENTS \<circ>
      lhand \<circ> snd) THEN
    ASM_SIMP_TAC[] THEN MATCH_MP_TAC(REAL_ARITH
     `x < e / 2 \<and> y < e / 2 \<Longrightarrow> z \<le> x + y \<Longrightarrow> z < e`) THEN
    ASM_SIMP_TAC[]]);;

lemma cauchy_continuous_map_pairwise:
   "\<And>m m1 m2 (f::A=>B#C).
        cauchy_continuous_map m (prod_metric m1 m2) f \<longleftrightarrow>
        cauchy_continuous_map m m1 (fst \<circ> f) \<and>
        cauchy_continuous_map m m2 (snd \<circ> f)"
oops
  REWRITE_TAC[cauchy_continuous_map; CAUCHY_IN_PROD_METRIC; o_ASSOC] THEN
  MESON_TAC[]);;

lemma lipschitz_continuous_map_paired:
   "\<And>m m1 m2 f (g::A=>C).
        lipschitz_continuous_map m (prod_metric m1 m2) (\<lambda>x. (f x, g x)) \<longleftrightarrow>
        lipschitz_continuous_map m m1 f \<and> lipschitz_continuous_map m m2 g"
oops
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma uniformly_continuous_map_paired:
   "\<And>m m1 m2 f (g::A=>C).
        uniformly_continuous_map m (prod_metric m1 m2) (\<lambda>x. (f x, g x)) \<longleftrightarrow>
        uniformly_continuous_map m m1 f \<and> uniformly_continuous_map m m2 g"
oops
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_paired:
   "\<And>m m1 m2 f (g::A=>C).
        cauchy_continuous_map m (prod_metric m1 m2) (\<lambda>x. (f x, g x)) \<longleftrightarrow>
        cauchy_continuous_map m m1 f \<and> cauchy_continuous_map m m2 g"
oops
  REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma mbounded_lipschitz_continuous_image:
   "\<And>m1 m2 f s.
        lipschitz_continuous_map m1 m2 f \<and> mbounded m1 s
        \<Longrightarrow> mbounded m2 (f ` s)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[MBOUNDED_ALT_POS; LIPSCHITZ_CONTINUOUS_MAP_POS] THEN
  REWRITE_TAC[IMP_CONJ; LEFT_IMP_EXISTS_THM] THEN DISCH_TAC THEN
  X_GEN_TAC `B::real` THEN DISCH_TAC THEN REWRITE_TAC[IMP_IMP] THEN
  STRIP_TAC THEN X_GEN_TAC `C::real` THEN STRIP_TAC THEN
  CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[FORALL_IN_IMAGE_2]] THEN
  EXISTS_TAC `B * C::real` THEN ASM_SIMP_TAC[REAL_LT_MUL] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
  TRANS_TAC REAL_LE_TRANS `B * d m1 (x::A,y)` THEN
  ASM_SIMP_TAC[REAL_LE_LMUL_EQ] THEN ASM SET_TAC[]);;

lemma mtotally_bounded_cauchy_continuous_image:
   "\<And>m1 m2 f s.
        cauchy_continuous_map m1 m2 f \<and> mtotally_bounded1 s
        \<Longrightarrow> mtotally_bounded2 (f ` s)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[TOTALLY_BOUNDED_IN_SEQUENTIALLY] THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
  CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[IN_IMAGE]] THEN
  X_GEN_TAC `y::num=>B` THEN REWRITE_TAC[SKOLEM_THM; FORALL_AND_THM]THEN
  DISCH_THEN(X_CHOOSE_THEN `x::num=>A` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::num=>A`) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `r::num=>num` THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [cauchy_continuous_map]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `(x::num=>A) \<circ> (r::num=>num)`) THEN
  ASM_REWRITE_TAC[] THEN ASM_REWRITE_TAC[o_DEF]);;

lemma lipschitz_coefficient_pos:
   "\<And>m m' f::A=>B k.
     (\<forall>x. x \<in> M \<Longrightarrow> f x \<in> mspace m') \<and>
     (\<forall>x y. x \<in> M \<and> y \<in> M
            \<Longrightarrow> d m' (f x,f y) \<le> k * d x y) \<and>
     (\<exists>x y. x \<in> M \<and> y \<in> M \<and> \<not> (f x = f y))
     \<Longrightarrow> 0 < k"
oops
  REPEAT GEN_TAC THEN INTRO_TAC "f k (@x y. x y fneq)" THEN
  CLAIM_TAC "neq" `\<not> (x::A = y)` THENL [HYP MESON_TAC "fneq" []; ALL_TAC] THEN
  TRANS_TAC REAL_LTE_TRANS `d m' (f x::B,f y) / d x::A y` THEN
  ASM_SIMP_TAC[REAL_LT_DIV; MDIST_POS_LT; REAL_LE_LDIV_EQ]);;

lemma lipschitz_continuous_map_metric:
   "        lipschitz_continuous_map
          (prod_metric m m,real_euclidean_metric)
          (d m)"
oops
  SIMP_TAC[lipschitz_continuous_map; CONJUNCT1 PROD_METRIC;
           REAL_EUCLIDEAN_METRIC] THEN
  GEN_TAC THEN REWRITE_TAC[FORALL_PAIR_THM; IN_CROSS; SUBSET_UNIV] THEN
  EXISTS_TAC `2` THEN
  MAP_EVERY X_GEN_TAC [`x1::A`; `y1::A`; `x2::A`; `y2::A`] THEN STRIP_TAC THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand) COMPONENT_LE_PROD_METRIC \<circ>
    rand \<circ> rand \<circ> snd) THEN
  MATCH_MP_TAC(REAL_ARITH
   `x \<le> y + z \<Longrightarrow> y \<le> p \<and> z \<le> p \<Longrightarrow> x \<le> 2 * p`) THEN
  REWRITE_TAC[REAL_ABS_BOUNDS] THEN CONJ_TAC THEN
  REPEAT(POP_ASSUM MP_TAC) THEN CONV_TAC METRIC_ARITH);;

lemma lipschitz_continuous_map_mdist:
   "\<And>m m' f g.
      lipschitz_continuous_map m m' f \<and>
      lipschitz_continuous_map m m' g
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric
             (\<lambda>x. d m' (f x,g x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric (m':B metric) m'` THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_METRIC] THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRED]);;

lemma uniformly_continuous_map_mdist:
   "\<And>m m' f g.
      uniformly_continuous_map m m' f \<and>
      uniformly_continuous_map m m' g
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric
             (\<lambda>x. d m' (f x,g x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric (m':B metric) m'` THEN
  SIMP_TAC[LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP;
           LIPSCHITZ_CONTINUOUS_MAP_METRIC] THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRED]);;

lemma cauchy_continuous_map_mdist:
   "\<And>m m' f g.
      cauchy_continuous_map m m' f \<and>
      cauchy_continuous_map m m' g
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric
             (\<lambda>x. d m' (f x,g x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric (m':B metric) m'` THEN
  SIMP_TAC[LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP;
           LIPSCHITZ_CONTINUOUS_MAP_METRIC] THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRED]);;

lemma continuous_map_metric:
   "        continuous_map (prod_topology mtopology mtopology,
                        euclideanreal)
                       (d m)"
oops
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC;
              GSYM MTOPOLOGY_PROD_METRIC] THEN
  GEN_TAC THEN MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_IMP_CONTINUOUS_MAP THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_METRIC]);;

lemma continuous_map_mdist_alt:
   "\<And>m f::A=>B#B.
        continuous_map X (prod_topology mtopology mtopology) f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. d m (f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  ASM_MESON_TAC[CONTINUOUS_MAP_METRIC; CONTINUOUS_MAP_COMPOSE]);;

lemma continuous_map_mdist:
   "\<And>X m f g::A=>B.
        continuous_map X mtopology f \<and>
        continuous_map X mtopology g
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. d (f x) g x)"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_topology (mtopology::B topology) mtopology` THEN
  REWRITE_TAC[CONTINUOUS_MAP_METRIC; CONTINUOUS_MAP_PAIRWISE] THEN
  ASM_REWRITE_TAC[o_DEF; ETA_AX]);;

lemma continuous_on_mdist:
   "a::A \<in> M
         \<Longrightarrow> continuous_map mtopology euclideanreal (\<lambda>x. d a x)"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_MAP_MDIST THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ID; CONTINUOUS_MAP_CONST] THEN
  ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY]);;

lemma lipschitz_continuous_map_real_left_multiplication:
   "lipschitz_continuous_map real_euclidean_metric real_euclidean_metric
         (\<lambda>x. c * x)"
oops
  GEN_TAC THEN REWRITE_TAC[lipschitz_continuous_map] THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV; SUBSET_UNIV] THEN
  REWRITE_TAC[GSYM REAL_SUB_LDISTRIB; REAL_ABS_MUL] THEN
  MESON_TAC[REAL_LE_REFL]);;

lemma lipschitz_continuous_map_real_right_multiplication:
   "lipschitz_continuous_map real_euclidean_metric real_euclidean_metric
         (\<lambda>x. x * c)"
oops
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LEFT_MULTIPLICATION]);;

lemma lipschitz_continuous_map_real_negation:
 (`lipschitz_continuous_map real_euclidean_metric real_euclidean_metric (--)"
oops
  GEN_REWRITE_TAC RAND_CONV [GSYM ETA_AX] THEN
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LEFT_MULTIPLICATION]);;

lemma lipschitz_continuous_map_real_absolute_value:
 (`lipschitz_continuous_map real_euclidean_metric real_euclidean_metric abs"
oops
  SIMP_TAC[lipschitz_continuous_map; REAL_EUCLIDEAN_METRIC; SUBSET_UNIV] THEN
  EXISTS_TAC `1` THEN REAL_ARITH_TAC);;

lemma lipschitz_continuous_map_real_addition:
 (`lipschitz_continuous_map
    (prod_metric real_euclidean_metric real_euclidean_metric,
     real_euclidean_metric)
    (\<lambda>(x,y). x + y)"
oops
  REWRITE_TAC[lipschitz_continuous_map; CONJUNCT1 PROD_METRIC] THEN
  REWRITE_TAC[FORALL_PAIR_THM; REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV; IN_CROSS] THEN
  EXISTS_TAC `2` THEN REPEAT GEN_TAC THEN
  REWRITE_TAC[REAL_ARITH `x \<le> 2 * y \<longleftrightarrow> x / 2 \<le> y`] THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand)
        COMPONENT_LE_PROD_METRIC \<circ> rand \<circ> snd) THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN REAL_ARITH_TAC);;

lemma lipschitz_continuous_map_real_subtraction:
 (`lipschitz_continuous_map
    (prod_metric real_euclidean_metric real_euclidean_metric,
     real_euclidean_metric)
    (\<lambda>(x,y). x - y)"
oops
  REWRITE_TAC[lipschitz_continuous_map; CONJUNCT1 PROD_METRIC] THEN
  REWRITE_TAC[FORALL_PAIR_THM; REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV; IN_CROSS] THEN
  EXISTS_TAC `2` THEN REPEAT GEN_TAC THEN
  REWRITE_TAC[REAL_ARITH `x \<le> 2 * y \<longleftrightarrow> x / 2 \<le> y`] THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand)
        COMPONENT_LE_PROD_METRIC \<circ> rand \<circ> snd) THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN REAL_ARITH_TAC);;

lemma lipschitz_continuous_map_real_maximum:
 (`lipschitz_continuous_map
    (prod_metric real_euclidean_metric real_euclidean_metric,
     real_euclidean_metric)
    (\<lambda>(x,y). max x y)"
oops
  REWRITE_TAC[lipschitz_continuous_map; CONJUNCT1 PROD_METRIC] THEN
  REWRITE_TAC[FORALL_PAIR_THM; REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV; IN_CROSS] THEN
  EXISTS_TAC `1` THEN REPEAT GEN_TAC THEN REWRITE_TAC[REAL_MUL_LID] THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand)
        COMPONENT_LE_PROD_METRIC \<circ> rand \<circ> snd) THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN REAL_ARITH_TAC);;

lemma lipschitz_continuous_map_real_minimum:
 (`lipschitz_continuous_map
    (prod_metric real_euclidean_metric real_euclidean_metric,
     real_euclidean_metric)
    (\<lambda>(x,y). min x y)"
oops
  REWRITE_TAC[lipschitz_continuous_map; CONJUNCT1 PROD_METRIC] THEN
  REWRITE_TAC[FORALL_PAIR_THM; REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV; IN_CROSS] THEN
  EXISTS_TAC `1` THEN REPEAT GEN_TAC THEN REWRITE_TAC[REAL_MUL_LID] THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand)
        COMPONENT_LE_PROD_METRIC \<circ> rand \<circ> snd) THEN
  REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN REAL_ARITH_TAC);;

lemma locally_lipschitz_continuous_map_real_multiplication:
   "mbounded (prod_metric real_euclidean_metric real_euclidean_metric) s
       \<Longrightarrow> lipschitz_continuous_map
            (submetric
              (prod_metric real_euclidean_metric real_euclidean_metric) s,
             real_euclidean_metric)
            (\<lambda>(x,y). x * y)"
oops
  GEN_TAC THEN REWRITE_TAC[MBOUNDED_PROD_METRIC] THEN
  REWRITE_TAC[MBOUNDED_REAL_EUCLIDEAN_METRIC; REAL_BOUNDED_POS] THEN
  REWRITE_TAC[IMP_CONJ; FORALL_IN_IMAGE; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `B::real` THEN REWRITE_TAC[FORALL_PAIR_THM] THEN
  REPEAT DISCH_TAC THEN X_GEN_TAC `C::real` THEN REPEAT DISCH_TAC THEN
  SIMP_TAC[lipschitz_continuous_map; REAL_EUCLIDEAN_METRIC; SUBSET_UNIV] THEN
  EXISTS_TAC `B + C::real` THEN
  REWRITE_TAC[FORALL_PAIR_THM; SUBMETRIC; IN_INTER; CONJUNCT1 PROD_METRIC] THEN
  MAP_EVERY X_GEN_TAC [`x1::real`; `y1::real`; `x2::real`; `y2::real`] THEN
  REWRITE_TAC[IN_CROSS; REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN STRIP_TAC THEN
  TRANS_TAC REAL_LE_TRANS
   `B * d y1 y2 +
    C * d x1 x2` THEN
  CONJ_TAC THENL
   [REWRITE_TAC[REAL_EUCLIDEAN_METRIC];
    MATCH_MP_TAC(REAL_ARITH
     `x \<le> b * d \<and> y \<le> c * d \<Longrightarrow> x + y \<le> (b + c) * d`) THEN
    ASM_SIMP_TAC[REAL_LE_LMUL_EQ; COMPONENT_LE_PROD_METRIC]] THEN
  ONCE_REWRITE_TAC[REAL_ARITH
   `x2 * y2 - x1 * y1::real = x2 * (y2 - y1) + y1 * (x2 - x1)`] THEN
  MATCH_MP_TAC(REAL_ARITH
   `abs x \<le> a \<and> abs y \<le> b \<Longrightarrow> abs(x + y) \<le> a + b`) THEN
  REWRITE_TAC[REAL_ABS_MUL] THEN CONJ_TAC THEN
  MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[REAL_ABS_POS] THEN
  ASM_MESON_TAC[]);;

lemma cauchy_continuous_map_real_multiplication:
 (`cauchy_continuous_map
    (prod_metric real_euclidean_metric real_euclidean_metric,
     real_euclidean_metric)
    (\<lambda>(x,y). x * y)"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LOCALLY_CAUCHY_CONTINUOUS_MAP THEN
  EXISTS_TAC `1` THEN REWRITE_TAC[REAL_LT_01] THEN
  GEN_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_MULTIPLICATION THEN
  REWRITE_TAC[MBOUNDED_MBALL]);;

lemma locally_lipschitz_continuous_map_real_inversion:
   "\<not> (0 \<in> euclideanreal closure_of s)
       \<Longrightarrow> lipschitz_continuous_map
             (submetric real_euclidean_metric s,real_euclidean_metric)
             inverse"
oops
  X_GEN_TAC `s::real=>bool` THEN
  REWRITE_TAC[CLOSURE_OF_INTERIOR_OF; IN_DIFF; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_UNIV; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_INTERIOR_OF_MBALL] THEN
  REWRITE_TAC[\<subseteq>; IN_MBALL; REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
  REWRITE_TAC[REAL_SUB_RZERO; REAL_NOT_LT; SET_RULE
   `(\<forall>x. P x \<Longrightarrow> x \<in> - s) \<longleftrightarrow> (\<forall>x. x \<in> s \<Longrightarrow> \<not> P x)`] THEN
  DISCH_THEN(X_CHOOSE_THEN `b::real` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[lipschitz_continuous_map; REAL_EUCLIDEAN_METRIC; SUBSET_UNIV;
              SUBMETRIC; INTER_UNIV] THEN
  EXISTS_TAC `inverse(b ^ 2):real` THEN
  MAP_EVERY X_GEN_TAC [`x::real`; `y::real`] THEN
  STRIP_TAC THEN
  ASM_CASES_TAC `x = 0` THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::real`) THEN ASM_REWRITE_TAC[] THEN
    ASM_REAL_ARITH_TAC;
    ALL_TAC] THEN
  ASM_CASES_TAC `y = 0` THENL
   [FIRST_X_ASSUM(MP_TAC \<circ> SPEC `y::real`) THEN ASM_REWRITE_TAC[] THEN
    ASM_REAL_ARITH_TAC;
    ALL_TAC] THEN
  ASM_SIMP_TAC[REAL_FIELD
   `(x \<noteq> 0) \<and> (y \<noteq> 0) \<Longrightarrow> inverse y - inverse x =-inverse(x * y) * (y - x)`] THEN
  REWRITE_TAC[REAL_ABS_MUL; REAL_ABS_NEG; REAL_ABS_INV] THEN
  MATCH_MP_TAC REAL_LE_RMUL THEN REWRITE_TAC[REAL_ABS_POS] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_SIMP_TAC[REAL_POW_LT] THEN
  REWRITE_TAC[REAL_POW_2] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
  ASM_SIMP_TAC[REAL_LT_IMP_LE]);;

lemma lipschitz_continuous_map_fst:
   "\<And>m m1 m2 f::A=>B#C.
        lipschitz_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> lipschitz_continuous_map m m1 (\<lambda>x. fst(f x))"
oops
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma lipschitz_continuous_map_snd:
   "\<And>m m1 m2 f::A=>B#C.
        lipschitz_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> lipschitz_continuous_map m m2 (\<lambda>x. snd(f x))"
oops
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma lipschitz_continuous_map_real_lmul:
   "\<And>m c f::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. c * f x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. c * f x) = (\<lambda>y. c * y) \<circ> (f::A=>real)`
  SUBST1_TAC THENL [REWRITE_TAC[FUN_EQ_THM; o_DEF]; ALL_TAC] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LEFT_MULTIPLICATION]);;

lemma lipschitz_continuous_map_real_rmul:
   "\<And>m c f::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x * c)"
oops
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LMUL]);;

lemma lipschitz_continuous_map_real_neg:
   "\<And>m f::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. --(f x))"
oops
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LMUL]);;

lemma lipschitz_continuous_map_real_abs:
   "\<And>m f::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. abs(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ABSOLUTE_VALUE]);;

lemma lipschitz_continuous_map_real_inv:
   "\<And>m f::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      \<not> (0 \<in> euclideanreal closure_of (image f (M)))
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. inverse(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
   `submetric real_euclidean_metric (image f (M::A=>bool))` THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_INTO_SUBMETRIC; SUBSET_REFL] THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_INVERSION THEN
  ASM_REWRITE_TAC[]);;

lemma lipschitz_continuous_map_real_add:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x + g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x + g x) = (\<lambda>(x,y). x + y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ADDITION] THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma lipschitz_continuous_map_real_sub:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x - g x)"
oops
  REWRITE_TAC[real_sub] THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ADD;
           LIPSCHITZ_CONTINUOUS_MAP_REAL_NEG]);;

lemma lipschitz_continuous_map_real_max:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric
            (\<lambda>x. max (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. max (f x) (g x)) = (\<lambda>(x,y). max x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MAXIMUM] THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma lipschitz_continuous_map_real_min:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric
            (\<lambda>x. min (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. min (f x) (g x)) = (\<lambda>(x,y). min x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MINIMUM] THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma lipschitz_continuous_map_real_mul:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g \<and>
      real_bounded (image f (M)) \<and> real_bounded (image g (M))
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x * g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x * g x) = (\<lambda>(x,y). x * y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC
   `submetric (prod_metric real_euclidean_metric real_euclidean_metric)
              (image (f::A=>real) (M) \<times> image g (M))` THEN
  ASM_REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX;
                  LIPSCHITZ_CONTINUOUS_MAP_INTO_SUBMETRIC] THEN
  SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_CROSS; FUN_IN_IMAGE] THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_MULTIPLICATION THEN
  ASM_REWRITE_TAC[MBOUNDED_CROSS; MBOUNDED_REAL_EUCLIDEAN_METRIC]);;

lemma lipschitz_continuous_map_real_div:
   "\<And>m f g::A=>real.
      lipschitz_continuous_map m real_euclidean_metric f \<and>
      lipschitz_continuous_map m real_euclidean_metric g \<and>
      real_bounded (image f (M)) \<and>
      \<not> (0 \<in> euclideanreal closure_of (image g (M)))
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x / g x)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[real_div] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_REAL_MUL THEN
  ASM_SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_INV] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> check (is_neg \<circ> concl)) THEN
  REWRITE_TAC[CLOSURE_OF_INTERIOR_OF; IN_DIFF; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_UNIV; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_INTERIOR_OF_MBALL] THEN
  REWRITE_TAC[\<subseteq>; IN_MBALL; REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
  REWRITE_TAC[REAL_SUB_RZERO; REAL_NOT_LT; SET_RULE
   `(\<forall>x. P x \<Longrightarrow> x \<in> - s) \<longleftrightarrow> (\<forall>x. x \<in> s \<Longrightarrow> \<not> P x)`] THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; FORALL_IN_IMAGE] THEN
  X_GEN_TAC `b::real` THEN STRIP_TAC THEN
  REWRITE_TAC[real_bounded; FORALL_IN_IMAGE; REAL_ABS_INV] THEN
  EXISTS_TAC `inverse b::real` THEN X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_SIMP_TAC[]);;

lemma lipschitz_continuous_map_sum:
   "\<And>m f::K=>A->real k.
      finite k \<and>
      (\<forall>i. i \<in> k
          \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric (\<lambda>x. f x i))
      \<Longrightarrow> lipschitz_continuous_map m real_euclidean_metric
                (\<lambda>x. sum k (f x))"
oops
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[IMP_CONJ] THEN
  REWRITE_TAC[IMP_CONJ] THEN
  MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  SIMP_TAC[SUM_CLAUSES; LIPSCHITZ_CONTINUOUS_MAP_CONST; REAL_EUCLIDEAN_METRIC;
    FORALL_IN_INSERT; LIPSCHITZ_CONTINUOUS_MAP_REAL_ADD; ETA_AX; IN_UNIV]);;

lemma uniformly_continuous_map_fst:
   "\<And>m m1 m2 f::A=>B#C.
        uniformly_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> uniformly_continuous_map m m1 (\<lambda>x. fst(f x))"
oops
  SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma uniformly_continuous_map_snd:
   "\<And>m m1 m2 f::A=>B#C.
        uniformly_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> uniformly_continuous_map m m2 (\<lambda>x. snd(f x))"
oops
  SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma uniformly_continuous_map_real_lmul:
   "\<And>m c f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. c * f x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. c * f x) = (\<lambda>y. c * y) \<circ> (f::A=>real)`
  SUBST1_TAC THENL [REWRITE_TAC[FUN_EQ_THM; o_DEF]; ALL_TAC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_LEFT_MULTIPLICATION;
               LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP]);;

lemma uniformly_continuous_map_real_rmul:
   "\<And>m c f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x * c)"
oops
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_REAL_LMUL]);;

lemma uniformly_continuous_map_real_neg:
   "\<And>m f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. --(f x))"
oops
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_REAL_LMUL]);;

lemma uniformly_continuous_map_real_abs:
   "\<And>m f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. abs(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ABSOLUTE_VALUE;
               LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP]);;

lemma uniformly_continuous_map_real_inv:
   "\<And>m f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      \<not> (0 \<in> euclideanreal closure_of (image f (M)))
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. inverse(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
   `submetric real_euclidean_metric (image f (M::A=>bool))` THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_INTO_SUBMETRIC; SUBSET_REFL] THEN
  MATCH_MP_TAC LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_INVERSION THEN
  ASM_REWRITE_TAC[]);;

lemma uniformly_continuous_map_real_add:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x + g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x + g x) = (\<lambda>(x,y). x + y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ADDITION;
           LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma uniformly_continuous_map_real_sub:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x - g x)"
oops
  REWRITE_TAC[real_sub] THEN
  SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_REAL_ADD;
           UNIFORMLY_CONTINUOUS_MAP_REAL_NEG]);;

lemma uniformly_continuous_map_real_max:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g
     \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric
            (\<lambda>x. max (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. max (f x) (g x)) = (\<lambda>(x,y). max x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MAXIMUM;
           LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma uniformly_continuous_map_real_min:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g
     \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric
            (\<lambda>x. min (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. min (f x) (g x)) = (\<lambda>(x,y). min x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MINIMUM;
           LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma uniformly_continuous_map_real_mul:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g \<and>
      real_bounded (image f (M)) \<and> real_bounded (image g (M))
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x * g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x * g x) = (\<lambda>(x,y). x * y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC
   `submetric (prod_metric real_euclidean_metric real_euclidean_metric)
              (image (f::A=>real) (M) \<times> image g (M))` THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX;
                  UNIFORMLY_CONTINUOUS_MAP_INTO_SUBMETRIC] THEN
  SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_CROSS; FUN_IN_IMAGE] THEN
  MATCH_MP_TAC LIPSCHITZ_IMP_UNIFORMLY_CONTINUOUS_MAP THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_MULTIPLICATION THEN
  ASM_REWRITE_TAC[MBOUNDED_CROSS; MBOUNDED_REAL_EUCLIDEAN_METRIC]);;

lemma uniformly_continuous_map_real_div:
   "\<And>m f g::A=>real.
      uniformly_continuous_map m real_euclidean_metric f \<and>
      uniformly_continuous_map m real_euclidean_metric g \<and>
      real_bounded (image f (M)) \<and>
      \<not> (0 \<in> euclideanreal closure_of (image g (M)))
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x / g x)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[real_div] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_REAL_MUL THEN
  ASM_SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_REAL_INV] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> check (is_neg \<circ> concl)) THEN
  REWRITE_TAC[CLOSURE_OF_INTERIOR_OF; IN_DIFF; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_UNIV; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_INTERIOR_OF_MBALL] THEN
  REWRITE_TAC[\<subseteq>; IN_MBALL; REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
  REWRITE_TAC[REAL_SUB_RZERO; REAL_NOT_LT; SET_RULE
   `(\<forall>x. P x \<Longrightarrow> x \<in> - s) \<longleftrightarrow> (\<forall>x. x \<in> s \<Longrightarrow> \<not> P x)`] THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; FORALL_IN_IMAGE] THEN
  X_GEN_TAC `b::real` THEN STRIP_TAC THEN
  REWRITE_TAC[real_bounded; FORALL_IN_IMAGE; REAL_ABS_INV] THEN
  EXISTS_TAC `inverse b::real` THEN X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_SIMP_TAC[]);;

lemma uniformly_continuous_map_sum:
   "\<And>m f::K=>A->real k.
      finite k \<and>
      (\<forall>i. i \<in> k
          \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. f x i))
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric
                (\<lambda>x. sum k (f x))"
oops
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[IMP_CONJ] THEN
  REWRITE_TAC[IMP_CONJ] THEN
  MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  SIMP_TAC[SUM_CLAUSES; UNIFORMLY_CONTINUOUS_MAP_CONST; REAL_EUCLIDEAN_METRIC;
    FORALL_IN_INSERT; UNIFORMLY_CONTINUOUS_MAP_REAL_ADD; ETA_AX; IN_UNIV]);;

lemma cauchy_continuous_map_fst:
   "\<And>m m1 m2 f::A=>B#C.
        cauchy_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> cauchy_continuous_map m m1 (\<lambda>x. fst(f x))"
oops
  SIMP_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma cauchy_continuous_map_snd:
   "\<And>m m1 m2 f::A=>B#C.
        cauchy_continuous_map m (prod_metric m1 m2) f
        \<Longrightarrow> cauchy_continuous_map m m2 (\<lambda>x. snd(f x))"
oops
  SIMP_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF]);;

lemma cauchy_continuous_map_real_inv:
   "\<And>m f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      \<not> (0 \<in> euclideanreal closure_of (image f (M)))
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. inverse(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN EXISTS_TAC
   `submetric real_euclidean_metric (image f (M::A=>bool))` THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_INTO_SUBMETRIC; SUBSET_REFL] THEN
  MATCH_MP_TAC LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP THEN
  MATCH_MP_TAC LOCALLY_LIPSCHITZ_CONTINUOUS_MAP_REAL_INVERSION THEN
  ASM_REWRITE_TAC[]);;

lemma cauchy_continuous_map_real_add:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x + g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x + g x) = (\<lambda>(x,y). x + y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ADDITION;
           LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_real_mul:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x * g x)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `(\<lambda>x. f x * g x) = (\<lambda>(x,y). x * y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC
   `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_REAL_MULTIPLICATION] THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_real_lmul:
   "\<And>m c f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. c * f x)"
oops
  SIMP_TAC[CAUCHY_CONTINUOUS_MAP_REAL_MUL; CAUCHY_CONTINUOUS_MAP_REAL_CONST]);;

lemma cauchy_continuous_map_real_rmul:
   "\<And>m c f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x * c)"
oops
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_REAL_LMUL]);;

lemma cauchy_continuous_map_real_pow:
   "\<And>m (f::A=>real) n.
        cauchy_continuous_map m real_euclidean_metric f
        \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x ^ n)"
oops
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  INDUCT_TAC THEN
  ASM_SIMP_TAC[real_pow; CAUCHY_CONTINUOUS_MAP_REAL_CONST;
               CAUCHY_CONTINUOUS_MAP_REAL_MUL]);;

lemma cauchy_continuous_map_real_neg:
   "\<And>m f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. --(f x))"
oops
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_REAL_LMUL]);;

lemma cauchy_continuous_map_real_abs:
   "\<And>m f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. abs(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_ABSOLUTE_VALUE;
               LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP]);;

lemma cauchy_continuous_map_real_sub:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x - g x)"
oops
  REWRITE_TAC[real_sub] THEN
  SIMP_TAC[CAUCHY_CONTINUOUS_MAP_REAL_ADD;
           CAUCHY_CONTINUOUS_MAP_REAL_NEG]);;

lemma cauchy_continuous_map_real_max:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g
    \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric
            (\<lambda>x. max (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. max (f x) (g x)) = (\<lambda>(x,y). max x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MAXIMUM;
           LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_real_min:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g
    \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric
            (\<lambda>x. min (f x) (g x))"
oops
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   `(\<lambda>x. min (f x) (g x)) = (\<lambda>(x,y). min x y) \<circ> (\<lambda>z. (f::A=>real) z,g z)`
  SUBST1_TAC THENL
   [REWRITE_TAC[FUN_EQ_THM; o_DEF; FORALL_PAIR_THM]; ALL_TAC] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `prod_metric real_euclidean_metric real_euclidean_metric` THEN
  SIMP_TAC[LIPSCHITZ_CONTINUOUS_MAP_REAL_MINIMUM;
           LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP] THEN
  ASM_REWRITE_TAC[CAUCHY_CONTINUOUS_MAP_PAIRWISE; o_DEF; ETA_AX]);;

lemma cauchy_continuous_map_real_div:
   "\<And>m f g::A=>real.
      cauchy_continuous_map m real_euclidean_metric f \<and>
      cauchy_continuous_map m real_euclidean_metric g \<and>
      \<not> (0 \<in> euclideanreal closure_of (image g (M)))
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x / g x)"
oops
  REPEAT STRIP_TAC THEN REWRITE_TAC[real_div] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_REAL_MUL THEN
  ASM_SIMP_TAC[CAUCHY_CONTINUOUS_MAP_REAL_INV] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> check (is_neg \<circ> concl)) THEN
  REWRITE_TAC[CLOSURE_OF_INTERIOR_OF; IN_DIFF; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_UNIV; GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_INTERIOR_OF_MBALL] THEN
  REWRITE_TAC[\<subseteq>; IN_MBALL; REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
  REWRITE_TAC[REAL_SUB_RZERO; REAL_NOT_LT; SET_RULE
   `(\<forall>x. P x \<Longrightarrow> x \<in> - s) \<longleftrightarrow> (\<forall>x. x \<in> s \<Longrightarrow> \<not> P x)`] THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; FORALL_IN_IMAGE] THEN
  X_GEN_TAC `b::real` THEN STRIP_TAC THEN
  REWRITE_TAC[real_bounded; FORALL_IN_IMAGE; REAL_ABS_INV] THEN
  EXISTS_TAC `inverse b::real` THEN X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_SIMP_TAC[]);;

lemma cauchy_continuous_map_sum:
   "\<And>m f::K=>A->real k.
      finite k \<and>
      (\<forall>i. i \<in> k
          \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. f x i))
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric
                (\<lambda>x. sum k (f x))"
oops
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[IMP_CONJ] THEN
  REWRITE_TAC[IMP_CONJ] THEN
  MATCH_MP_TAC FINITE_INDUCT_STRONG THEN
  SIMP_TAC[SUM_CLAUSES; CAUCHY_CONTINUOUS_MAP_REAL_CONST;
    FORALL_IN_INSERT; CAUCHY_CONTINUOUS_MAP_REAL_ADD; ETA_AX]);;

lemma uniformly_continuous_map_square_root:
 (`uniformly_continuous_map real_euclidean_metric real_euclidean_metric sqrt"
oops
  REWRITE_TAC[uniformly_continuous_map; REAL_EUCLIDEAN_METRIC] THEN
  REWRITE_TAC[IN_UNIV; SUBSET_UNIV] THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  EXISTS_TAC `e ^ 2 / 2` THEN ASM_SIMP_TAC[REAL_HALF; REAL_POW_LT] THEN
  MAP_EVERY X_GEN_TAC [`x::real`; `y::real`] THEN DISCH_TAC THEN
  TRANS_TAC REAL_LET_TRANS `sqrt(2 * abs(x - y))` THEN
  REWRITE_TAC[REAL_ABS_LE_SQRT] THEN MATCH_MP_TAC REAL_LT_LSQRT THEN
  ASM_REAL_ARITH_TAC);;

lemma continuous_map_square_root:
 (`continuous_map euclideanreal euclideanreal sqrt"
oops
  REWRITE_TAC[GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS_MAP THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_SQUARE_ROOT]);;

lemma uniformly_continuous_map_sqrt:
   "\<And>m f::A=>real.
      uniformly_continuous_map m real_euclidean_metric f
      \<Longrightarrow> uniformly_continuous_map m real_euclidean_metric (\<lambda>x. sqrt(f x))"
oops
   REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_REWRITE_TAC[UNIFORMLY_CONTINUOUS_MAP_SQUARE_ROOT]);;

lemma cauchy_continuous_map_sqrt:
   "\<And>m f::A=>real.
      cauchy_continuous_map m real_euclidean_metric f
      \<Longrightarrow> cauchy_continuous_map m real_euclidean_metric (\<lambda>x. sqrt(f x))"
oops
   REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `real_euclidean_metric` THEN
  ASM_SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_SQUARE_ROOT;
               UNIFORMLY_IMP_CAUCHY_CONTINUOUS_MAP]);;

lemma continuous_map_sqrt:
   "\<And>X f::A=>real.
        continuous_map X euclideanreal f
        \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. sqrt(f x))"
oops
  REPEAT STRIP_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `euclideanreal` THEN ASM_REWRITE_TAC[] THEN
  SIMP_TAC[UNIFORMLY_CONTINUOUS_MAP_SQUARE_ROOT; GSYM
           MTOPOLOGY_REAL_EUCLIDEAN_METRIC;
           UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS_MAP]);;

lemma isometry_imp_embedding_map:
   "\<And>m m' f.
        image f (M) \<subseteq> mspace m' \<and>
        (\<forall>x y. x \<in> M \<and> y \<in> M
               \<Longrightarrow> d m' (f x,f y) = d x y)
        \<Longrightarrow> embedding_map mtopology (mtopology m') f"
oops
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   `\<forall>x y. x \<in> M \<and> y \<in> M \<and> f x = f y \<Longrightarrow> x = y`
  MP_TAC THENL [ASM_MESON_TAC[MDIST_0]; ALL_TAC] THEN
  REWRITE_TAC[INJECTIVE_ON_LEFT_INVERSE; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::B=>A` THEN DISCH_TAC THEN
  REWRITE_TAC[embedding_map; HOMEOMORPHIC_MAP_MAPS] THEN
  EXISTS_TAC `g::B=>A` THEN
  ASM_REWRITE_TAC[homeomorphic_maps; TOPSPACE_MTOPOLOGY;
                  TOPSPACE_SUBTOPOLOGY; IN_INTER; IMP_CONJ_ALT] THEN
  ASM_SIMP_TAC[FORALL_IN_IMAGE] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  ASM_REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_MTOPOLOGY] THEN
  SIMP_TAC[FUN_IN_IMAGE; GSYM MTOPOLOGY_SUBMETRIC] THEN
  CONJ_TAC THEN MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_IMP_CONTINUOUS_MAP THEN
  ASM_SIMP_TAC[lipschitz_continuous_map; \<subseteq>; FORALL_IN_IMAGE;
               SUBMETRIC; IMP_CONJ; IN_INTER] THEN
  EXISTS_TAC `1` THEN
  REWRITE_TAC[RIGHT_FORALL_IMP_THM; FORALL_IN_IMAGE; REAL_MUL_LID] THEN
  ASM_SIMP_TAC[REAL_LE_REFL]);;

lemma isometry_imp_homeomorphic_map:
   "\<And>m m' f.
        image f (M) = mspace m' \<and>
        (\<forall>x y. x \<in> M \<and> y \<in> M
               \<Longrightarrow> d m' (f x,f y) = d x y)
        \<Longrightarrow> homeomorphic_map mtopology (mtopology m') f"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m::A metric`; `m':B metric`; `f::A=>B`]
        ISOMETRY_IMP_EMBEDDING_MAP) THEN
  ASM_REWRITE_TAC[SUBSET_REFL; embedding_map; TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY; SUBTOPOLOGY_TOPSPACE]);;


subsection\<open>Extending continuous maps "pointwise" in a regular space\<close>


lemma continuous_map_on_intermediate_closure_of:
   "\<And>X X' f::A=>B s t.
       regular_space X' \<and>
       t \<subseteq> X closure_of s \<and>
       (\<forall>x. x \<in> t \<Longrightarrow> limitin X' f (f x) (atin X x within s))
       \<Longrightarrow> continuous_map (subtopology X t,X') f"
oops
  REWRITE_TAC[GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `image f t \<subseteq> topspace X'` ASSUME_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[limitin]) THEN ASM SET_TAC[]; ALL_TAC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF; TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  X_GEN_TAC `a::A` THEN STRIP_TAC THEN ASM_SIMP_TAC[ATPOINTOF_SUBTOPOLOGY] THEN
  REWRITE_TAC[limitin] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `w::B=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [NEIGHBOURHOOD_BASE_OF]) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`w::B=>bool`; `f a`]) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_TOPSPACE; LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`v::B=>bool`; `c::B=>bool`] THEN STRIP_TAC THEN
  REWRITE_TAC[EVENTUALLY_ATPOINTOF; EVENTUALLY_WITHIN_IMP] THEN DISJ2_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `a::A`) THEN
  ANTS_TAC THENL [ASM_REWRITE_TAC[]; REWRITE_TAC[limitin]] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `v::B=>bool`)) THEN
  ASM_REWRITE_TAC[EVENTUALLY_ATPOINTOF; EVENTUALLY_WITHIN_IMP] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `u::A=>bool` THEN
  REWRITE_TAC[IMP_IMP] THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC `z::A` THEN REWRITE_TAC[IN_DELETE] THEN STRIP_TAC THEN
  SUBGOAL_THEN `z \<in> topspace X \<and> f z \<in> topspace X'`
  STRIP_ASSUME_TAC THENL
   [REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  SUBGOAL_THEN `\<not> (f z \<in> topspace X' - c)` MP_TAC THENL
   [REWRITE_TAC[IN_DIFF] THEN STRIP_TAC; ASM SET_TAC[]] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [limitin] \<circ> SPEC `z::A`) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `topspace X' - c::B=>bool`) THEN
  ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE; IN_DIFF] THEN
  ASM_REWRITE_TAC[EVENTUALLY_ATPOINTOF; EVENTUALLY_WITHIN_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN `u':A=>bool` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `(t::A=>bool) \<subseteq> X closure_of s` THEN
  REWRITE_TAC[closure_of; IN_ELIM_THM; \<subseteq>] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `z::A`) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `u \<inter> u':A=>bool`) THEN
  ASM_SIMP_TAC[OPEN_IN_INTER] THEN ASM SET_TAC[]);;

lemma continuous_map_on_intermediate_closure_of_eq:
   "\<And>X X' f::A=>B s t.
        regular_space X' \<and> s \<subseteq> t \<and> t \<subseteq> X closure_of s
        \<Longrightarrow> (continuous_map (subtopology X t,X') f \<longleftrightarrow>
             \<forall>x. x \<in> t \<Longrightarrow> limitin X' f (f x) (atin X x within s))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF; TOPSPACE_SUBTOPOLOGY] THEN
    MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `x::A` THEN
    ASM_CASES_TAC `(x::A) \<in> t` THEN ASM_SIMP_TAC[ATPOINTOF_SUBTOPOLOGY] THEN
    ASSUME_TAC(ISPECL [`X::A topology`; `s::A=>bool`]
      CLOSURE_OF_SUBSET_TOPSPACE) THEN
    ANTS_TAC THENL [ASM SET_TAC[]; ASM_MESON_TAC[LIMIT_WITHIN_SUBSET]];
    ASM_MESON_TAC[CONTINUOUS_MAP_ON_INTERMEDIATE_CLOSURE_OF]]);;

lemma continuous_map_extension_pointwise_alt:
   "\<And>top1 top2 f::A=>B s t.
        regular_space top2 \<and> s \<subseteq> t \<and> t \<subseteq> top1 closure_of s \<and>
        continuous_map (subtopology top1 s,top2) f \<and>
        (\<forall>x. x \<in> t - s \<Longrightarrow> \<exists>l. limitin top2 f l (atin top1 x within s))
        \<Longrightarrow> \<exists>g. continuous_map (subtopology top1 t,top2) g \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM
   (MP_TAC \<circ> GEN_REWRITE_RULE BINDER_CONV [RIGHT_IMP_EXISTS_THM]) THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM; IN_DIFF] THEN
  X_GEN_TAC `g::A=>B` THEN DISCH_TAC THEN
  EXISTS_TAC `\<lambda>x. if x \<in> s then f x else g x` THEN
  ASM_SIMP_TAC[CONTINUOUS_MAP_ON_INTERMEDIATE_CLOSURE_OF_EQ] THEN
  X_GEN_TAC `x::A` THEN DISCH_TAC THEN
  MATCH_MP_TAC LIMIT_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC `f::A=>B` THEN SIMP_TAC[ALWAYS_WITHIN_EVENTUALLY] THEN
  COND_CASES_TAC THEN
  ASM_SIMP_TAC[GSYM ATPOINTOF_SUBTOPOLOGY] THEN
  FIRST_ASSUM(MATCH_MP_TAC \<circ>
   GEN_REWRITE_RULE id [CONTINUOUS_MAP_ATPOINTOF]) THEN
  ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[closure_of]) THEN ASM SET_TAC[]);;

lemma continuous_map_extension_pointwise:
   "\<And>top1 top2 f::A=>B s t.
        regular_space top2 \<and> s \<subseteq> t \<and> t \<subseteq> top1 closure_of s \<and>
        (\<forall>x. x \<in> t
             \<Longrightarrow> \<exists>g. continuous_map (subtopology top1 (insert x s),top2) g \<and>
                     \<forall>x. x \<in> s \<Longrightarrow> g x = f x)
        \<Longrightarrow> \<exists>g. continuous_map (subtopology top1 t,top2) g \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_MAP_EXTENSION_POINTWISE_ALT THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_DIFF; IN_INTER] THEN
  CONJ_TAC THEN X_GEN_TAC `x::A` THEN STRIP_TAC THEN
  (SUBGOAL_THEN `(x::A) \<in> topspace top1` ASSUME_TAC THENL
    [RULE_ASSUM_TAC(SIMP_RULE[closure_of]) THEN ASM SET_TAC[]; ALL_TAC]) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `x::A`) THEN
  (ANTS_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[LEFT_IMP_EXISTS_THM]]) THEN
  X_GEN_TAC `g::A=>B` THEN REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (MP_TAC \<circ> SPEC `x::A`) ASSUME_TAC) THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_INSERT] THEN
  ASM_SIMP_TAC[ATPOINTOF_SUBTOPOLOGY; IN_INSERT] THEN
  STRIP_TAC THENL [ALL_TAC; EXISTS_TAC `(g::A=>B) x`] THEN
  MATCH_MP_TAC LIMIT_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC `(g::A=>B)` THEN ASM_SIMP_TAC[ALWAYS_WITHIN_EVENTUALLY] THEN
  MATCH_MP_TAC LIMIT_WITHIN_SUBSET THEN
  EXISTS_TAC `(x::A) insert s` THEN
  ASM_REWRITE_TAC[SET_RULE `s \<subseteq> insert x s`]);;


subsection\<open>Extending Cauchy continuous functions to the closure\<close>


lemma cauchy_continuous_map_extends_to_continuous_closure_of:
   "\<And>m1 m2 f s.
        mcomplete m2 \<and> cauchy_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> \<exists>g. continuous_map
                 (subtopology (mtopology m1) (mtopology m1 closure_of s),
                  mtopology m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  MATCH_MP_TAC(MESON[]
   `\<forall>m. ((\<forall>s. s \<subseteq> M \<Longrightarrow> P s) \<Longrightarrow> (\<forall>s. P s)) \<and>
        (\<forall>s. s \<subseteq> M \<Longrightarrow> P s)
        \<Longrightarrow> \<forall>s. P s`) THEN
  EXISTS_TAC `m1::A metric` THEN CONJ_TAC THENL
   [DISCH_TAC THEN X_GEN_TAC `s::A=>bool` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `mspace m1 \<inter> s::A=>bool`) THEN
    ASM_REWRITE_TAC[GSYM SUBMETRIC_SUBMETRIC; SUBMETRIC_MSPACE] THEN
    REWRITE_TAC[INTER_SUBSET; GSYM TOPSPACE_MTOPOLOGY] THEN
    REWRITE_TAC[GSYM CLOSURE_OF_RESTRICT; IN_INTER] THEN
    DISCH_THEN(X_CHOOSE_THEN `g::A=>B` STRIP_ASSUME_TAC) THEN EXISTS_TAC
     `\<lambda>x. if x \<in> topspace(mtopology m1) then (g::A=>B) x else f x` THEN
    ASM_SIMP_TAC[COND_ID] THEN MATCH_MP_TAC CONTINUOUS_MAP_EQ THEN
    EXISTS_TAC `g::A=>B` THEN ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER];
    ALL_TAC] THEN
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_MAP_EXTENSION_POINTWISE_ALT THEN
  REWRITE_TAC[REGULAR_SPACE_MTOPOLOGY; SUBSET_REFL] THEN
  ASM_SIMP_TAC[CLOSURE_OF_SUBSET; TOPSPACE_MTOPOLOGY] THEN
  ASM_SIMP_TAC[CAUCHY_CONTINUOUS_IMP_CONTINUOUS_MAP;
               GSYM MTOPOLOGY_SUBMETRIC; IN_DIFF] THEN
  X_GEN_TAC `a::A` THEN STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [CLOSURE_OF_SEQUENTIALLY]) THEN
  REWRITE_TAC[IN_ELIM_THM; IN_INTER; FORALL_AND_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC
   (X_CHOOSE_THEN `x::num=>A` STRIP_ASSUME_TAC)) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
      CONVERGENT_IMP_CAUCHY_IN)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN FIRST_ASSUM(MP_TAC \<circ>
    SPEC `x::num=>A` \<circ> REWRITE_RULE[cauchy_continuous_map]) THEN
  ASM_REWRITE_TAC[CAUCHY_IN_SUBMETRIC] THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `f \<circ> (x::num=>A)` \<circ>
    REWRITE_RULE[mcomplete]) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  X_GEN_TAC `l::B` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> CONJUNCT1 \<circ> REWRITE_RULE[limitin]) THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC[LIMIT_ATPOINTOF_SEQUENTIALLY_WITHIN] THEN
  X_GEN_TAC `y::num=>A` THEN
  REWRITE_TAC[IN_INTER; IN_DELETE; FORALL_AND_THM] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ>
   SPEC `\<lambda>n. if even n then x(n div 2):A else y(n div 2)` \<circ>
   REWRITE_RULE[cauchy_continuous_map]) THEN
  REWRITE_TAC[CAUCHY_IN_INTERLEAVING_GEN; o_DEF; COND_RAND] THEN
  ASM_REWRITE_TAC[SUBMETRIC; CAUCHY_IN_SUBMETRIC] THEN ANTS_TAC THENL
   [CONJ_TAC THENL [ASM_MESON_TAC[CONVERGENT_IMP_CAUCHY_IN]; ALL_TAC] THEN
    MAP_EVERY UNDISCH_TAC
     [`limitin (mtopology m1) y (a::A) sequentially`;
      `limitin (mtopology m1) x (a::A) sequentially`] THEN
    REWRITE_TAC[IMP_IMP] THEN
    GEN_REWRITE_TAC (LAND_CONV \<circ> BINOP_CONV) [LIMIT_METRIC_DIST_NULL] THEN
    ASM_REWRITE_TAC[EVENTUALLY_TRUE] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP LIMIT_REAL_ADD) THEN
    REWRITE_TAC[REAL_ADD_LID] THEN MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT]
      LIMIT_NULL_REAL_COMPARISON) THEN
    MATCH_MP_TAC ALWAYS_EVENTUALLY THEN REWRITE_TAC[] THEN GEN_TAC THEN
    MATCH_MP_TAC(METRIC_ARITH
      `a \<in> M \<and> x \<in> M \<and> y \<in> M
       \<Longrightarrow> abs(d x y) \<le> abs(d x a + d y a)`) THEN
    ASM_REWRITE_TAC[];
    DISCH_THEN(MP_TAC \<circ> CONJUNCT2 \<circ> CONJUNCT2) THEN
    GEN_REWRITE_TAC RAND_CONV [LIMIT_METRIC_DIST_NULL] THEN
    UNDISCH_TAC `limitin (mtopology m2) (f \<circ> x) l sequentially` THEN
    GEN_REWRITE_TAC LAND_CONV [LIMIT_METRIC_DIST_NULL] THEN
    SIMP_TAC[o_DEF] THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    REWRITE_TAC[IMP_IMP] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP LIMIT_REAL_ADD) THEN
    REWRITE_TAC[REAL_ADD_RID] THEN
    DISCH_THEN(fun th -> CONJ_TAC THEN MP_TAC th) THENL
     [DISCH_THEN(K ALL_TAC) THEN MATCH_MP_TAC ALWAYS_EVENTUALLY THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
      REWRITE_TAC[SUBMETRIC] THEN ASM SET_TAC[];
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT]
        LIMIT_NULL_REAL_COMPARISON) THEN
      MATCH_MP_TAC ALWAYS_EVENTUALLY THEN REWRITE_TAC[] THEN GEN_TAC THEN
      MATCH_MP_TAC(METRIC_ARITH
       `a \<in> M \<and> x \<in> M \<and> y \<in> M
        \<Longrightarrow> abs(d y a) \<le> abs(d x a + d x y)`) THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CAUCHY_CONTINUOUS_MAP_IMAGE) THEN
      REWRITE_TAC[SUBMETRIC] THEN ASM SET_TAC[]]]);;

lemma cauchy_continuous_map_extends_to_continuous_intermediate_closure_of:
   "\<And>m1 m2 f s t.
        mcomplete m2 \<and> cauchy_continuous_map (submetric1 s,m2) f \<and>
        t \<subseteq> mtopology m1 closure_of s
        \<Longrightarrow> \<exists>g. continuous_map(subtopology (mtopology m1) t,mtopology m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
        CAUCHY_CONTINUOUS_MAP_EXTENDS_TO_CONTINUOUS_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY_MONO]);;

lemma lipschitz_continuous_map_on_intermediate_closure:
   "\<And>m1 m2 f::A=>B s t.
        s \<subseteq> t \<and> t \<subseteq> (mtopology m1) closure_of s \<and>
        continuous_map (subtopology (mtopology m1) t,mtopology m2) f \<and>
        lipschitz_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> lipschitz_continuous_map (submetric1 t,m2) f"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[CLOSURE_OF_RESTRICT] THEN
  SUBGOAL_THEN `submetric1 (s::A=>bool) = submetric1 (mspace m1 \<inter> s)`
  SUBST1_TAC THENL
   [REWRITE_TAC[GSYM SUBMETRIC_SUBMETRIC; SUBMETRIC_MSPACE];
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC \<circ> SPEC `mspace m1::A=>bool` \<circ> MATCH_MP (SET_RULE
       `s \<subseteq> t \<Longrightarrow> \<forall>u. u \<inter> s \<subseteq> u \<and> u \<inter> s \<subseteq> t`))
     MP_TAC) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
    SPEC_TAC(`mspace m1 \<inter> (s::A=>bool)`,`s::A=>bool`)] THEN
  GEN_TAC THEN DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SUBGOAL_THEN `(t::A=>bool) \<subseteq> mspace m1` ASSUME_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[closure_of; TOPSPACE_MTOPOLOGY]) THEN
    ASM SET_TAC[];
    FIRST_ASSUM(MP_TAC \<circ> CONJUNCT1 \<circ> REWRITE_RULE[CONTINUOUS_MAP])] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[LIPSCHITZ_CONTINUOUS_MAP_POS] THEN
  ASM_SIMP_TAC[SUBMETRIC; SET_RULE `s \<subseteq> u \<Longrightarrow> s \<inter> u = s`;
               SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  DISCH_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `B::real` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL
   [`prod_topology (subtopology (mtopology m1) (t::A=>bool))
                   (subtopology (mtopology m1) (t::A=>bool))`;
    `\<lambda>z. d m2 (f (fst z),f(snd z)) \<le> B * d m1 (fst z,snd z)`;
    `s \<times> (s::A=>bool)`] FORALL_IN_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[CLOSURE_OF_CROSS; FORALL_PAIR_THM; IN_CROSS] THEN
  REWRITE_TAC[CLOSURE_OF_SUBTOPOLOGY] THEN ASM_SIMP_TAC[SET_RULE
   `s \<subseteq> t \<Longrightarrow> t \<inter> s = s \<and> s \<inter> t = s`] THEN
  ANTS_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LE] THEN REWRITE_TAC[SET_RULE
   `{x. x \<in> s \<and> 0 \<le> f x} = {x. x \<in> s \<and> f x \<in> {y. 0 \<le> y}}`] THEN
  MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
  EXISTS_TAC `euclideanreal` THEN REWRITE_TAC[GSYM REAL_CLOSED_IN] THEN
  REWRITE_TAC[REWRITE_RULE[real_ge] REAL_CLOSED_HALFSPACE_GE] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_REAL_LMUL THEN
    GEN_REWRITE_TAC (RAND_CONV \<circ> ABS_CONV \<circ> RAND_CONV) [GSYM PAIR];
    ALL_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_MDIST THENL
   [ALL_TAC;
    CONJ_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC `subtopology (mtopology m1) (t::A=>bool)`] THEN
  REPEAT CONJ_TAC THEN
  TRY(MATCH_MP_TAC CONTINUOUS_MAP_INTO_SUBTOPOLOGY THEN
      REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; IMAGE_FST_CROSS; IMAGE_SND_CROSS;
                  INTER_CROSS] THEN
      REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
      CONJ_TAC THENL [ALL_TAC; SET_TAC[]]) THEN
  ASM_REWRITE_TAC[GSYM SUBTOPOLOGY_CROSS] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
  REWRITE_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND]);;

lemma lipschitz_continuous_map_extends_to_closure_of:
   "\<And>m1 m2 f s.
        mcomplete m2 \<and> lipschitz_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> \<exists>g. lipschitz_continuous_map
                   (submetric1 (mtopology m1 closure_of s),m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
         CAUCHY_CONTINUOUS_MAP_EXTENDS_TO_CONTINUOUS_CLOSURE_OF) THEN
  ASM_SIMP_TAC[LIPSCHITZ_IMP_CAUCHY_CONTINUOUS_MAP] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::A=>B` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_ON_INTERMEDIATE_CLOSURE THEN
  EXISTS_TAC `mspace m1 \<inter> s::A=>bool` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CLOSURE_OF_SUBSET_INTER; GSYM TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[GSYM CLOSURE_OF_RESTRICT; SUBSET_REFL] THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY; GSYM SUBMETRIC_RESTRICT] THEN
  MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_MAP_EQ THEN EXISTS_TAC `f::A=>B` THEN
  ASM_SIMP_TAC[SUBMETRIC; IN_INTER]);;

lemma lipschitz_continuous_map_extends_to_intermediate_closure_of:
   "\<And>m1 m2 f s t.
        mcomplete m2 \<and>
        lipschitz_continuous_map (submetric1 s,m2) f \<and>
        t \<subseteq> mtopology m1 closure_of s
        \<Longrightarrow> \<exists>g. lipschitz_continuous_map (submetric1 t,m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
        LIPSCHITZ_CONTINUOUS_MAP_EXTENDS_TO_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[LIPSCHITZ_CONTINUOUS_MAP_FROM_SUBMETRIC_MONO]);;

lemma uniformly_continuous_map_on_intermediate_closure:
   "\<And>m1 m2 f::A=>B s t.
        s \<subseteq> t \<and> t \<subseteq> (mtopology m1) closure_of s \<and>
        continuous_map (subtopology (mtopology m1) t,mtopology m2) f \<and>
        uniformly_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> uniformly_continuous_map (submetric1 t,m2) f"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[CLOSURE_OF_RESTRICT] THEN
  SUBGOAL_THEN `submetric1 (s::A=>bool) = submetric1 (mspace m1 \<inter> s)`
  SUBST1_TAC THENL
   [REWRITE_TAC[GSYM SUBMETRIC_SUBMETRIC; SUBMETRIC_MSPACE];
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC \<circ> SPEC `mspace m1::A=>bool` \<circ> MATCH_MP (SET_RULE
       `s \<subseteq> t \<Longrightarrow> \<forall>u. u \<inter> s \<subseteq> u \<and> u \<inter> s \<subseteq> t`))
     MP_TAC) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
    SPEC_TAC(`mspace m1 \<inter> (s::A=>bool)`,`s::A=>bool`)] THEN
  GEN_TAC THEN DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SUBGOAL_THEN `(t::A=>bool) \<subseteq> mspace m1` ASSUME_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[closure_of; TOPSPACE_MTOPOLOGY]) THEN
    ASM SET_TAC[];
    FIRST_ASSUM(MP_TAC \<circ> CONJUNCT1 \<circ> REWRITE_RULE[CONTINUOUS_MAP])] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[uniformly_continuous_map] THEN
  ASM_SIMP_TAC[SUBMETRIC; SET_RULE `s \<subseteq> u \<Longrightarrow> s \<inter> u = s`;
               SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  DISCH_TAC THEN STRIP_TAC THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e / 2`) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `d::real` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL
   [`prod_topology (subtopology (mtopology m1) (t::A=>bool))
                   (subtopology (mtopology m1) (t::A=>bool))`;
    `\<lambda>z. d m1 (fst z,snd z) < d
         \<Longrightarrow> d m2 (f (fst z),f(snd z)) \<le> e / 2`;
    `s \<times> (s::A=>bool)`] FORALL_IN_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[CLOSURE_OF_CROSS; FORALL_PAIR_THM; IN_CROSS] THEN
  REWRITE_TAC[CLOSURE_OF_SUBTOPOLOGY] THEN ASM_SIMP_TAC[SET_RULE
   `s \<subseteq> t \<Longrightarrow> t \<inter> s = s \<and> s \<inter> t = s`] THEN ANTS_TAC THENL
   [ASM_SIMP_TAC[REAL_LT_IMP_LE];
    ASM_MESON_TAC[REAL_ARITH `0 < e \<and> x \<le> e / 2 \<Longrightarrow> x < e`]] THEN
  ONCE_REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LE] THEN
  REWRITE_TAC[SET_RULE
   `{x. x \<in> s \<and> (\<not> (0 \<le> f x) \<Longrightarrow> 0 \<le> g x)} =
    {x. x \<in> s \<and> g x \<in> {y. 0 \<le> y}} \<union>
    {x. x \<in> s \<and> f x \<in> {y. 0 \<le> y}}`] THEN
  MATCH_MP_TAC CLOSED_IN_UNION THEN CONJ_TAC THEN
  MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
  EXISTS_TAC `euclideanreal` THEN REWRITE_TAC[GSYM REAL_CLOSED_IN] THEN
  REWRITE_TAC[REWRITE_RULE[real_ge] REAL_CLOSED_HALFSPACE_GE] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
  REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_MDIST_ALT THEN
  REWRITE_TAC[CONTINUOUS_MAP_PAIRWISE; o_DEF; GSYM SUBTOPOLOGY_CROSS] THEN
  SIMP_TAC[CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND; ETA_AX;
           CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
  CONJ_TAC THEN GEN_REWRITE_TAC RAND_CONV [GSYM o_DEF] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `subtopology (mtopology m1) (t::A=>bool)` THEN
  ASM_SIMP_TAC[SUBTOPOLOGY_CROSS; CONTINUOUS_MAP_FST; CONTINUOUS_MAP_SND]);;

lemma uniformly_continuous_map_extends_to_closure_of:
   "\<And>m1 m2 f s.
        mcomplete m2 \<and> uniformly_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> \<exists>g. uniformly_continuous_map
                   (submetric1 (mtopology m1 closure_of s),m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
         CAUCHY_CONTINUOUS_MAP_EXTENDS_TO_CONTINUOUS_CLOSURE_OF) THEN
  ASM_SIMP_TAC[UNIFORMLY_IMP_CAUCHY_CONTINUOUS_MAP] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::A=>B` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_ON_INTERMEDIATE_CLOSURE THEN
  EXISTS_TAC `mspace m1 \<inter> s::A=>bool` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CLOSURE_OF_SUBSET_INTER; GSYM TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[GSYM CLOSURE_OF_RESTRICT; SUBSET_REFL] THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY; GSYM SUBMETRIC_RESTRICT] THEN
  MATCH_MP_TAC UNIFORMLY_CONTINUOUS_MAP_EQ THEN EXISTS_TAC `f::A=>B` THEN
  ASM_SIMP_TAC[SUBMETRIC; IN_INTER]);;

lemma uniformly_continuous_map_extends_to_intermediate_closure_of:
   "\<And>m1 m2 f s t.
        mcomplete m2 \<and>
        uniformly_continuous_map (submetric1 s,m2) f \<and>
        t \<subseteq> mtopology m1 closure_of s
        \<Longrightarrow> \<exists>g. uniformly_continuous_map (submetric1 t,m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
        UNIFORMLY_CONTINUOUS_MAP_EXTENDS_TO_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[UNIFORMLY_CONTINUOUS_MAP_FROM_SUBMETRIC_MONO]);;

lemma cauchy_continuous_map_on_intermediate_closure:
   "\<And>m1 m2 f::A=>B s t.
        s \<subseteq> t \<and> t \<subseteq> (mtopology m1) closure_of s \<and>
        continuous_map (subtopology (mtopology m1) t,mtopology m2) f \<and>
        cauchy_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> cauchy_continuous_map (submetric1 t,m2) f"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[CLOSURE_OF_RESTRICT] THEN
  SUBGOAL_THEN `submetric1 (s::A=>bool) = submetric1 (mspace m1 \<inter> s)`
  SUBST1_TAC THENL
   [REWRITE_TAC[GSYM SUBMETRIC_SUBMETRIC; SUBMETRIC_MSPACE];
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC \<circ> SPEC `mspace m1::A=>bool` \<circ> MATCH_MP (SET_RULE
       `s \<subseteq> t \<Longrightarrow> \<forall>u. u \<inter> s \<subseteq> u \<and> u \<inter> s \<subseteq> t`))
     MP_TAC) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
    SPEC_TAC(`mspace m1 \<inter> (s::A=>bool)`,`s::A=>bool`)] THEN
  GEN_TAC THEN DISCH_THEN(fun th -> STRIP_TAC THEN MP_TAC th) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SUBGOAL_THEN `(t::A=>bool) \<subseteq> mspace m1` ASSUME_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[closure_of; TOPSPACE_MTOPOLOGY]) THEN
    ASM SET_TAC[];
    DISCH_TAC] THEN
  REWRITE_TAC[cauchy_continuous_map; CAUCHY_IN_SUBMETRIC] THEN
  X_GEN_TAC `x::num=>A` THEN STRIP_TAC THEN
  SUBGOAL_THEN
   `\<forall>n. \<exists>y. y \<in> s \<and>
            d m1 (x n,y) < inverse(Suc n) \<and>
            d m2 (f(x n),f y) < inverse(Suc n)`
  MP_TAC THENL
   [X_GEN_TAC `n::num` THEN
    RULE_ASSUM_TAC(REWRITE_RULE[GSYM MTOPOLOGY_SUBMETRIC]) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [METRIC_CONTINUOUS_MAP]) THEN
    ASM_SIMP_TAC[SUBMETRIC; SET_RULE `s \<subseteq> u \<Longrightarrow> s \<inter> u = s`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`(x::num=>A) n`; `inverse(Suc n)`]) THEN
    ASM_REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
    DISCH_THEN(X_CHOOSE_THEN `d::real` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [METRIC_CLOSURE_OF]) THEN
    REWRITE_TAC[\<subseteq>; IN_ELIM_THM; IN_MBALL] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `(x::num=>A) n`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC \<circ> SPEC `min d (inverse(Suc n))`)) THEN
    ASM_SIMP_TAC[REAL_LT_MIN; REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
    MATCH_MP_TAC MONO_EXISTS THEN ASM SET_TAC[];
    REWRITE_TAC[SKOLEM_THM; FORALL_AND_THM; LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `y::num=>A` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [cauchy_continuous_map]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `y::num=>A`) THEN
  ASM_SIMP_TAC[CAUCHY_IN_SUBMETRIC; SUBMETRIC; SET_RULE
   `s \<subseteq> u \<Longrightarrow> s \<inter> u = s`] THEN
  ANTS_TAC THENL [UNDISCH_TAC `MCauchy m1 (x::num=>A)`; ALL_TAC] THEN
  ASM_REWRITE_TAC[MCauchy; o_THM] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> CONJUNCT1 \<circ> GEN_REWRITE_RULE id [continuous_map]) THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_MTOPOLOGY;
               SET_RULE `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`] THEN
  DISCH_TAC THEN TRY(CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
  X_GEN_TAC `e::real` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e / 2`) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_TAC `M::num`) THEN
  MP_TAC(SPEC `e / 4` ARCH_EVENTUALLY_INV1) THEN
  ASM_REWRITE_TAC[REAL_ARITH `0 < e / 4 \<longleftrightarrow> 0 < e`] THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
  DISCH_THEN(X_CHOOSE_TAC `N::num`) THEN EXISTS_TAC `MAX M N` THEN
  ASM_REWRITE_TAC[ARITH_RULE `MAX M N \<le> n \<longleftrightarrow> M \<le> n \<and> N \<le> n`] THEN
  MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`m::num`; `n::num`]) THEN
  ASM_REWRITE_TAC[] THENL
   [MATCH_MP_TAC(METRIC_ARITH
     `(x \<in> M \<and> x' \<in> M \<and> y \<in> M \<and> y' \<in> M) \<and>
      (d x y < e / 4 \<and> d x' y' < e / 4)
      \<Longrightarrow> d x x' < e / 2 \<Longrightarrow> d y y' < e`);
    MATCH_MP_TAC(METRIC_ARITH
     `(x \<in> M \<and> x' \<in> M \<and> y \<in> M \<and> y' \<in> M) \<and>
      (d x y < e / 4 \<and> d x' y' < e / 4)
      \<Longrightarrow> d y y' < e / 2 \<Longrightarrow> d x x' < e`)] THEN
  (CONJ_TAC THENL [ASM SET_TAC[]; ASM_MESON_TAC[REAL_LT_TRANS]]));;

lemma cauchy_continuous_map_extends_to_closure_of:
   "\<And>m1 m2 f s.
        mcomplete m2 \<and> cauchy_continuous_map (submetric1 s,m2) f
        \<Longrightarrow> \<exists>g. cauchy_continuous_map
                   (submetric1 (mtopology m1 closure_of s),m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT GEN_TAC THEN DISCH_TAC THEN FIRST_ASSUM(MP_TAC \<circ> MATCH_MP
    CAUCHY_CONTINUOUS_MAP_EXTENDS_TO_CONTINUOUS_CLOSURE_OF) THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::A=>B` THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_ON_INTERMEDIATE_CLOSURE THEN
  EXISTS_TAC `mspace m1 \<inter> s::A=>bool` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[CLOSURE_OF_SUBSET_INTER; GSYM TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[GSYM CLOSURE_OF_RESTRICT; SUBSET_REFL] THEN
  REWRITE_TAC[TOPSPACE_MTOPOLOGY; GSYM SUBMETRIC_RESTRICT] THEN
  MATCH_MP_TAC CAUCHY_CONTINUOUS_MAP_EQ THEN EXISTS_TAC `f::A=>B` THEN
  ASM_SIMP_TAC[SUBMETRIC; IN_INTER]);;

lemma cauchy_continuous_map_extends_to_intermediate_closure_of:
   "\<And>m1 m2 f s t.
        mcomplete m2 \<and>
        cauchy_continuous_map (submetric1 s,m2) f \<and>
        t \<subseteq> mtopology m1 closure_of s
        \<Longrightarrow> \<exists>g. cauchy_continuous_map (submetric1 t,m2) g \<and>
                \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m1::A metric`; `m2::B metric`; `f::A=>B`; `s::A=>bool`]
        CAUCHY_CONTINUOUS_MAP_EXTENDS_TO_CLOSURE_OF) THEN
  ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[CAUCHY_CONTINUOUS_MAP_FROM_SUBMETRIC_MONO]);;


subsection\<open>Lavrentiev extension etc\<close>


lemma convergent_eq_zero_oscillation_gen:
   "\<And>X m f s a.
        mcomplete \<and> image f (topspace X \<inter> s) \<subseteq> M
        \<Longrightarrow> ((\<exists>l. limitin mtopology f l (atin X a within s)) \<longleftrightarrow>
             \<not> (M = {}) \<and>
             (a \<in> topspace X
              \<Longrightarrow> \<forall>e. 0 < e
                      \<Longrightarrow> \<exists>u. openin X u \<and> a \<in> u \<and>
                              \<forall>x y. x \<in> (s \<inter> u) - {a} \<and>
                                    y \<in> (s \<inter> u) - {a}
                                    \<Longrightarrow> d (f x) f y < e))"
oops
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC `M::B=>bool = {}` THENL
   [ASM_REWRITE_TAC[LIMIT_METRIC; NOT_IN_EMPTY]; STRIP_TAC] THEN
  ASM_CASES_TAC `(a::A) \<in> topspace X` THENL
   [ASM_REWRITE_TAC[];
    ASM_SIMP_TAC[LIMIT_METRIC; EVENTUALLY_WITHIN_IMP;
                 EVENTUALLY_ATPOINTOF; NOT_IN_EMPTY] THEN
    ASM SET_TAC[]] THEN
  ASM_CASES_TAC `(a::A) \<in> X derived_set_of s` THENL
   [ALL_TAC;
    MATCH_MP_TAC(TAUT `p \<and> q \<Longrightarrow> (p \<longleftrightarrow> q)`) THEN CONJ_TAC THENL
     [ASM_MESON_TAC[MEMBER_NOT_EMPTY; TOPSPACE_MTOPOLOGY;
                    TRIVIAL_LIMIT_ATPOINTOF_WITHIN; LIMIT_TRIVIAL];
      REPEAT STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE (RAND_CONV \<circ> RAND_CONV)
       [derived_set_of]) THEN
      ASM_REWRITE_TAC[IN_ELIM_THM; NOT_FORALL_THM; NOT_IMP] THEN
      MATCH_MP_TAC MONO_EXISTS THEN SET_TAC[]]] THEN
  EQ_TAC THENL
   [REWRITE_TAC[LIMIT_METRIC; EVENTUALLY_WITHIN_IMP; EVENTUALLY_ATPOINTOF] THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM; IMP_IMP] THEN
    X_GEN_TAC `l::B` THEN STRIP_TAC THEN
    X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e / 2`) THEN
    ASM_REWRITE_TAC[REAL_HALF] THEN MATCH_MP_TAC MONO_EXISTS THEN
    X_GEN_TAC `u::A=>bool` THEN REWRITE_TAC[IN_DELETE; IN_INTER] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(fun th ->
      MP_TAC(SPEC `y::A` th) THEN MP_TAC(SPEC `x::A` th)) THEN
    ASM_REWRITE_TAC[] THEN UNDISCH_TAC `(l::B) \<in> M` THEN
    CONV_TAC METRIC_ARITH;
    DISCH_TAC] THEN
  FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [MCOMPLETE_FIP_SING]) THEN
  DISCH_THEN(MP_TAC \<circ> SPEC
   `{ mtopology closure_of (image f ((s \<inter> u) - {a})) |u|
      openin X u \<and> a \<in> u}`) THEN
  ANTS_TAC THENL
   [REWRITE_TAC[FORALL_IN_GSPEC; CLOSED_IN_CLOSURE_OF] THEN
    ONCE_REWRITE_TAC[SIMPLE_IMAGE_GEN] THEN
    REWRITE_TAC[FORALL_FINITE_SUBSET_IMAGE; RIGHT_EXISTS_AND_THM] THEN
    REWRITE_TAC[EXISTS_IN_IMAGE; EXISTS_IN_GSPEC] THEN CONJ_TAC THENL
     [X_GEN_TAC `e::real` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e::real`) THEN
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
      X_GEN_TAC `u::A=>bool` THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_DERIVED_SET_OF]) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `u::A=>bool`) THEN
      ASM_REWRITE_TAC[] THEN
      DISCH_THEN(X_CHOOSE_THEN `b::A` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC `f b` THEN MATCH_MP_TAC CLOSURE_OF_MINIMAL THEN
      REWRITE_TAC[CLOSED_IN_MCBALL; \<subseteq>; FORALL_IN_IMAGE] THEN
      REWRITE_TAC[IN_INTER; IN_DELETE; IN_MCBALL; CONJ_ASSOC] THEN
      GEN_TAC THEN STRIP_TAC THEN CONJ_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[\<subseteq>; IN_INTER; FORALL_IN_IMAGE]) THEN
        ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET];
        MATCH_MP_TAC REAL_LT_IMP_LE THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
        ASM_REWRITE_TAC[IN_INTER; IN_DELETE]];
      X_GEN_TAC `t:(A=>bool)->bool` THEN
      REWRITE_TAC[\<subseteq>; IN_ELIM_THM] THEN STRIP_TAC THEN
      ONCE_REWRITE_TAC[GSYM o_DEF] THEN REWRITE_TAC[IMAGE_o] THEN
      MATCH_MP_TAC(SET_RULE
       `\<forall>g. (\<forall>s. s \<in> t \<Longrightarrow> s \<subseteq> g s) \<and> (\<exists>x. x \<in> \<Inter> t)
             \<Longrightarrow> \<not> (\<Inter> (g ` t) = {})`) THEN
      CONJ_TAC THENL
       [REWRITE_TAC[FORALL_IN_IMAGE] THEN REPEAT STRIP_TAC THEN
        MATCH_MP_TAC CLOSURE_OF_SUBSET THEN
        REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[OPEN_IN_CLOSED_IN_EQ]) THEN
        ASM SET_TAC[];
        FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_DERIVED_SET_OF]) THEN
        DISCH_THEN(MP_TAC \<circ> SPEC
          `\<Inter> (topspace insert X t):A=>bool` \<circ> CONJUNCT2) THEN
        ASM_SIMP_TAC[OPEN_IN_INTERS; GSYM INTERS_INSERT; NOT_INSERT_EMPTY;
                     FINITE_INSERT; FORALL_IN_INSERT; OPEN_IN_TOPSPACE] THEN
        ANTS_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
        DISCH_THEN(X_CHOOSE_THEN `y::A` STRIP_ASSUME_TAC) THEN
        EXISTS_TAC `f y` THEN REWRITE_TAC[INTERS_IMAGE] THEN
        ASM SET_TAC[]]];
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `b::B` THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[LIMIT_METRIC] THEN X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e / 2`) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE `s = {a} \<Longrightarrow> a \<in> s`)) THEN
    REWRITE_TAC[INTERS_GSPEC; closure_of; IN_ELIM_THM] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `u::A=>bool`) THEN
    ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY; EXISTS_IN_IMAGE] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `mball m (b::B,e / 2)`) THEN
    ASM_SIMP_TAC[CENTRE_IN_MBALL; REAL_HALF; OPEN_IN_MBALL; IN_INTER] THEN
    REWRITE_TAC[IN_MBALL; LEFT_IMP_EXISTS_THM; IN_DELETE; IN_INTER] THEN
    X_GEN_TAC `x::A` THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[EVENTUALLY_WITHIN_IMP; EVENTUALLY_ATPOINTOF] THEN
    EXISTS_TAC `u::A=>bool` THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    X_GEN_TAC `y::A` THEN STRIP_TAC THEN DISCH_TAC THEN
    MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
     [RULE_ASSUM_TAC(REWRITE_RULE[\<subseteq>; IN_INTER; FORALL_IN_IMAGE]) THEN
      ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET];
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`x::A`; `y::A`]) THEN
      ASM_REWRITE_TAC[IN_INTER; IN_DELETE] THEN
      MAP_EVERY UNDISCH_TAC
       [`d b f x < e / 2`; `(b::B) \<in> M`;
        `f x \<in> M`] THEN
      CONV_TAC METRIC_ARITH]]);;

lemma gdelta_in_points_of_convergence_within:
   "\<And>X X' f s.
        completely_metrizable_space X' \<and>
        (continuous_map (subtopology X s,X') f \<or>
         t1_space X \<and> f ` s \<subseteq> topspace X')
        \<Longrightarrow> gdelta_in X
             {x \<in> topspace X.
                  \<exists>l. limitin X' f l (atin X x within s)}"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[FORALL_COMPLETELY_METRIZABLE_SPACE] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  SUBGOAL_THEN `image f (topspace X \<inter> s) \<subseteq> M`
  ASSUME_TAC THENL
   [FIRST_X_ASSUM DISJ_CASES_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    ASM_MESON_TAC[CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE; TOPSPACE_SUBTOPOLOGY;
                  TOPSPACE_MTOPOLOGY];
    ONCE_REWRITE_TAC[TAUT `p \<and> q \<longleftrightarrow> (p \<noteq>=> \<not> q)`] THEN
    ASM_SIMP_TAC[CONVERGENT_EQ_ZERO_OSCILLATION_GEN] THEN
    REWRITE_TAC[NOT_IMP]] THEN
  ASM_CASES_TAC `M::B=>bool = {}` THEN
  ASM_REWRITE_TAC[EMPTY_GSPEC; GDELTA_IN_EMPTY] THEN
  MATCH_MP_TAC(MESON[]
   `\<forall>s. gdelta_in X s \<and> t = s \<Longrightarrow> gdelta_in X t`) THEN
  FIRST_X_ASSUM(DISJ_CASES_THEN STRIP_ASSUME_TAC) THENL
   [EXISTS_TAC
     `topspace X \<inter>
      \<Inter> {\<Union> {u. openin X u \<and>
                          \<forall>x y. x \<in> (s \<inter> u) \<and>
                                y \<in> (s \<inter> u)
                                \<Longrightarrow> d (f x) f y < inverse(Suc n)}
              | n \<in> UNIV}`;
    EXISTS_TAC
     `topspace X \<inter>
      \<Inter> {\<Union> {u. openin X u \<and>
                          \<exists>b. b \<in> topspace X \<and>
                              \<forall>x y. x \<in> (s \<inter> u) - {b} \<and>
                                    y \<in> (s \<inter> u) - {b}
                                    \<Longrightarrow> d (f x) f y < inverse(Suc n)}
              | n \<in> UNIV}`] THEN
  (CONJ_TAC THENL
    [REWRITE_TAC[gdelta_in] THEN MATCH_MP_TAC RELATIVE_TO_INC THEN
     MATCH_MP_TAC COUNTABLE_INTERSECTION_OF_INTERS THEN
     ASM_SIMP_TAC[SIMPLE_IMAGE; COUNTABLE_IMAGE; NUM_COUNTABLE] THEN
     REWRITE_TAC[FORALL_IN_IMAGE; IN_UNIV] THEN GEN_TAC THEN
     MATCH_MP_TAC COUNTABLE_INTERSECTION_OF_INC THEN
     MATCH_MP_TAC OPEN_IN_UNIONS THEN SIMP_TAC[IN_ELIM_THM];
     ALL_TAC]) THEN
  GEN_REWRITE_TAC id [EXTENSION] THEN
  REWRITE_TAC[IN_INTER; INTERS_GSPEC; IN_ELIM_THM] THEN
  REWRITE_TAC[IN_UNIV; IN_UNIONS; IN_ELIM_THM] THEN
  X_GEN_TAC `a::A` THEN ASM_CASES_TAC `(a::A) \<in> topspace X` THEN
  ASM_REWRITE_TAC[] THEN
  W(MP_TAC \<circ> PART_MATCH (rand \<circ> rand) FORALL_POS_MONO_1_EQ \<circ> rand \<circ> snd) THEN
  (ANTS_TAC THENL
    [MESON_TAC[REAL_LT_TRANS]; DISCH_THEN(SUBST1_TAC \<circ> SYM)]) THEN
  REWRITE_TAC[IN_INTER; IN_DELETE; IN_ELIM_THM] THENL
   [EQ_TAC THENL [DISCH_TAC; MESON_TAC[]] THEN
    X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e::real`) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
    ASM_CASES_TAC `(a::A) \<in> s` THENL [ALL_TAC; ASM_MESON_TAC[]] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONTINUOUS_MAP_TO_METRIC]) THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `a::A`) THEN
    ASM_REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `e::real`) THEN
    ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; EXISTS_IN_GSPEC; IN_INTER] THEN
    REWRITE_TAC[IN_MBALL; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `v::A=>bool` THEN STRIP_TAC THEN
    EXISTS_TAC `u \<inter> v::A=>bool` THEN
    ASM_SIMP_TAC[OPEN_IN_INTER; IN_INTER] THEN
    MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
    ASM_CASES_TAC `x::A = a` THEN ASM_SIMP_TAC[] THEN
    ASM_CASES_TAC `y::A = a` THEN ASM_SIMP_TAC[] THEN
    ASM_MESON_TAC[MDIST_SYM];
    EQ_TAC THENL [ASM_METIS_TAC[]; DISCH_TAC] THEN
    X_GEN_TAC `e::real` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `e::real`) THEN
    ASM_REWRITE_TAC[RIGHT_AND_EXISTS_THM; LEFT_AND_EXISTS_THM;
                    LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `b::A`] THEN STRIP_TAC THEN
    ASM_CASES_TAC `b::A = a` THENL [ASM_MESON_TAC[]; ALL_TAC] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [t1_space]) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`a::A`; `b::A`]) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `v::A=>bool` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `u \<inter> v::A=>bool` THEN
    ASM_SIMP_TAC[OPEN_IN_INTER; IN_INTER] THEN ASM SET_TAC[]]);;

lemma lavrentiev_extension_gen:
   "\<And>X s X' f.
        s \<subseteq> topspace X \<and>
        completely_metrizable_space X' \<and>
        continuous_map(subtopology X s,X') f
        \<Longrightarrow> \<exists>u g. gdelta_in X u \<and>
                  s \<subseteq> u \<and>
                  continuous_map
                     (subtopology X (X closure_of s \<inter> u),X') g \<and>
                  \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT STRIP_TAC THEN
  EXISTS_TAC
   `{x \<in> topspace X.
         \<exists>l. limitin X' f l (atin X x within s)}` THEN
  REWRITE_TAC[INTER_SUBSET; RIGHT_EXISTS_AND_THM] THEN
  ASM_SIMP_TAC[GDELTA_IN_POINTS_OF_CONVERGENCE_WITHIN] THEN
  MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
   [REWRITE_TAC[\<subseteq>; IN_ELIM_THM] THEN X_GEN_TAC `x::A` THEN
    DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONTINUOUS_MAP_ATPOINTOF]) THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
    ASM_MESON_TAC[ATPOINTOF_SUBTOPOLOGY; \<subseteq>];
    DISCH_TAC THEN MATCH_MP_TAC CONTINUOUS_MAP_EXTENSION_POINTWISE_ALT THEN
    ASM_SIMP_TAC[INTER_SUBSET; METRIZABLE_IMP_REGULAR_SPACE;
                 COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE] THEN
    SIMP_TAC[IN_INTER; IN_ELIM_THM; IN_DIFF] THEN
    ASM_SIMP_TAC[SUBSET_INTER; CLOSURE_OF_SUBSET]]);;

lemma lavrentiev_extension:
   "\<And>X s X' f.
        s \<subseteq> topspace X \<and>
        (metrizable_space X \<or> topspace X \<subseteq> X closure_of s) \<and>
        completely_metrizable_space X' \<and>
        continuous_map(subtopology X s,X') f
        \<Longrightarrow> \<exists>u g. gdelta_in X u \<and>
                  s \<subseteq> u \<and>
                  u \<subseteq> X closure_of s \<and>
                  continuous_map(subtopology X u,X') g \<and>
                  \<forall>x. x \<in> s \<Longrightarrow> g x = f x"
oops
  REPEAT GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`; `X':B topology`; `f::A=>B`]
    LAVRENTIEV_EXTENSION_GEN) THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[SWAP_EXISTS_THM] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `g::A=>B` THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `X closure_of s \<inter> u::A=>bool` THEN
  ASM_SIMP_TAC[INTER_SUBSET; SUBSET_INTER; CLOSURE_OF_SUBSET] THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THENL
   [MATCH_MP_TAC GDELTA_IN_INTER THEN
    ASM_SIMP_TAC[CLOSED_IMP_GDELTA_IN; CLOSED_IN_CLOSURE_OF];
    FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (MESON[]
     `gdelta_in X s \<Longrightarrow> t = s \<Longrightarrow> gdelta_in X t`)) THEN
    REWRITE_TAC[SET_RULE `c \<inter> u = u \<longleftrightarrow> u \<subseteq> c`] THEN
    ASM_MESON_TAC[SUBSET_TRANS; GDELTA_IN_SUBSET]]);;


subsection\<open>"Capped" equivalent bounded metrics and general product metrics\<close>


let capped_metric = new_definition
 `capped_metric d (m::A metric) =
        if d \<le> 0 then m
        else metric(M,(\<lambda>(x,y). min d (d x y)))`;;

lemma capped_metric:
   "        mspace (capped_metric d m) = M \<and>
        d (capped_metric d m) =
           \<lambda>(x,y). if d \<le> 0 then d x y else min d (d x y)"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `d::real \<le> 0` THEN
  ASM_REWRITE_TAC[capped_metric; PAIRED_ETA_THM; ETA_AX] THEN
  REWRITE_TAC[capped_metric; mspace; d; GSYM PAIR_EQ] THEN
  REWRITE_TAC[GSYM(CONJUNCT2 metric_tybij)] THEN
  REWRITE_TAC[is_metric_space; GSYM mspace; GSYM d] THEN
  ASM_SIMP_TAC[REAL_ARITH `\<not> (d \<le> 0) \<Longrightarrow> (0 \<le> min d x \<longleftrightarrow> 0 \<le> x)`] THEN
  ASM_SIMP_TAC[MDIST_POS_LE; MDIST_0; REAL_ARITH
    `\<not> (d \<le> 0) \<and> 0 \<le> x  \<Longrightarrow> (min d x = 0 \<longleftrightarrow> x = 0)`] THEN
  CONJ_TAC THENL [MESON_TAC[MDIST_SYM]; REPEAT STRIP_TAC] THEN
  MATCH_MP_TAC(REAL_ARITH
   `\<not> (d \<le> 0) \<and> 0 \<le> y \<and> 0 \<le> z \<and> x \<le> y + z
    \<Longrightarrow> min d x \<le> min d y + min d z`) THEN
  ASM_MESON_TAC[MDIST_POS_LE; MDIST_TRIANGLE]);;

lemma mdist_capped:
   "0 < d \<Longrightarrow> d(capped_metric d m) (x,y) \<le> d"
oops
  SIMP_TAC[CAPPED_METRIC; GSYM REAL_NOT_LT] THEN REAL_ARITH_TAC);;

lemma mtopology_capped_metric:
   "mtopology(capped_metric d m) = mtopology"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `d \<le> 0` THENL
   [ASM_MESON_TAC[capped_metric];
    RULE_ASSUM_TAC(REWRITE_RULE[REAL_NOT_LE])] THEN
  REWRITE_TAC[TOPOLOGY_EQ] THEN
  X_GEN_TAC `s::A=>bool` THEN ASM_REWRITE_TAC[OPEN_IN_MTOPOLOGY] THEN
  ASM_CASES_TAC `(s::A=>bool) \<subseteq> M` THEN
  ASM_REWRITE_TAC[CAPPED_METRIC] THEN
  AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `a::A` THEN ASM_CASES_TAC `(a::A) \<in> s` THEN ASM_REWRITE_TAC[] THEN
  ASM_REWRITE_TAC[\<subseteq>; IN_MBALL] THEN
  ASM_CASES_TAC `(a::A) \<in> M` THENL
   [ASM_REWRITE_TAC[CAPPED_METRIC]; ASM SET_TAC[]] THEN
  EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN `r::real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `min (d / 2) r` THEN
  ASM_REWRITE_TAC[REAL_LT_MIN; REAL_HALF] THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[] THEN ASM_REAL_ARITH_TAC);;

lemma MCauchy_capped_metric:
   "\<And>d (m::A metric) x.
        MCauchy (capped_metric d m) x \<longleftrightarrow> MCauchy x"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `d \<le> 0` THENL
   [ASM_MESON_TAC[capped_metric]; ALL_TAC] THEN
  ASM_REWRITE_TAC[MCauchy; CAPPED_METRIC; REAL_MIN_LT] THEN
  ASM_MESON_TAC[REAL_ARITH `\<not> (d < min d e)`; REAL_LT_MIN; REAL_NOT_LE]);;

lemma mcomplete_capped_metric:
   "\<And>d (m::A metric). mcomplete(capped_metric d m) \<longleftrightarrow> mcomplete"
oops
  REWRITE_TAC[mcomplete; CAUCHY_IN_CAPPED_METRIC; MTOPOLOGY_CAPPED_METRIC]);;

lemma bounded_equivalent_metric:
   "        0 < d
        \<Longrightarrow> ?m'. mspace m' = M \<and>
                 mtopology m' = mtopology \<and>
                 \<forall>x y. d m' (x,y) < d"
oops
  REPEAT STRIP_TAC THEN EXISTS_TAC `capped_metric (d / 2) m::A metric` THEN
  ASM_REWRITE_TAC[MTOPOLOGY_CAPPED_METRIC; CAPPED_METRIC] THEN
  ASM_REAL_ARITH_TAC);;

lemma sup_metric_cartesian_product:
   "\<And>k (m::K-> Ametric) m'.
        metric(PiE k (mspace \<circ> m),
               \<lambda>(x,y). sup {d(m i) (x i,y i) | i \<in> k}) = m' \<and>
        (k \<noteq> {}) \<and>
        (\<exists>c. \<forall>i x y. i \<in> k \<and> x \<in> mspace(m i) \<and> y \<in> mspace(m i)
                      \<Longrightarrow> d(m i) (x,y) \<le> c)
        \<Longrightarrow> mspace m' = PiE k (mspace \<circ> m) \<and>
            d m' = (\<lambda>(x,y). sup {d(m i) (x i,y i) | i \<in> k}) \<and>
            \<forall>x y b. x \<in> PiE k (mspace \<circ> m) \<and>
                    y \<in> PiE k (mspace \<circ> m)
                    \<Longrightarrow> (d m' (x,y) \<le> b \<longleftrightarrow>
                         \<forall>i. i \<in> k \<Longrightarrow> d (m i) (x i,y i) \<le> b)"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  ABBREV_TAC `M = \<lambda>(x,y). sup {d(m i) (x i::A,y i) | (i::K) \<in> k}` THEN
  SUBGOAL_THEN
   `!x (y::K=>A) b.
        x \<in> PiE k (mspace \<circ> m) \<and>
        y \<in> PiE k (mspace \<circ> m)
        \<Longrightarrow> (M(x,y) \<le> b \<longleftrightarrow> \<forall>i. i \<in> k \<Longrightarrow> d (m i) (x i,y i) \<le> b)`
  ASSUME_TAC THENL
   [REWRITE_TAC[PiE; o_DEF; IN_ELIM_THM] THEN
    REPEAT STRIP_TAC THEN EXPAND_TAC "M" THEN REWRITE_TAC[] THEN
    W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) REAL_SUP_LE_EQ \<circ> lhand \<circ> snd) THEN
    REWRITE_TAC[FORALL_IN_GSPEC] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (MESON[]
   `m = m' \<Longrightarrow> M = mspace m' \<and> d m = d m'`)) THEN
  REWRITE_TAC[GSYM PAIR_EQ; mspace; d] THEN
  W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) (CONJUNCT2 metric_tybij) \<circ>
    lhand \<circ> lhand \<circ> snd) THEN
  DISCH_THEN(MP_TAC \<circ> fst \<circ> EQ_IMP_RULE) THEN ANTS_TAC THENL
   [ALL_TAC;
    DISCH_THEN SUBST1_TAC THEN DISCH_THEN(SUBST1_TAC \<circ> SYM) THEN
    ASM_REWRITE_TAC[GSYM d]] THEN
  REWRITE_TAC[is_metric_space] THEN
  MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN EXPAND_TAC "M" THEN REWRITE_TAC[] THEN
    MATCH_MP_TAC REAL_LE_SUP THEN
    ASM_SIMP_TAC[FORALL_IN_GSPEC; EXISTS_IN_GSPEC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM; o_THM]) THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC `c::real`) THEN EXISTS_TAC `c::real` THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    MATCH_MP_TAC MONO_EXISTS THEN ASM_SIMP_TAC[MDIST_POS_LE];
    DISCH_TAC] THEN
  REPEAT CONJ_TAC THENL
   [ASM_SIMP_TAC[GSYM REAL_LE_ANTISYM] THEN REPEAT GEN_TAC THEN
    DISCH_THEN(fun th ->
      SUBST1_TAC(MATCH_MP CARTESIAN_PRODUCT_EQ_MEMBERS_EQ th) THEN
      MP_TAC th) THEN
    REWRITE_TAC[PiE; o_THM; IN_ELIM_THM] THEN
    SIMP_TAC[METRIC_ARITH
     `x \<in> M \<and> y \<in> M \<Longrightarrow> (d x y \<le> 0 \<longleftrightarrow> x = y)`];
    REPEAT STRIP_TAC THEN EXPAND_TAC "M" THEN REWRITE_TAC[IN_ELIM_THM] THEN
    AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
     `(\<forall>i. i \<in> w \<Longrightarrow> f i = g i) \<Longrightarrow> {f i | i \<in> w} = {g i | i \<in> w}`) THEN
    RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM; o_THM]) THEN
    ASM_MESON_TAC[MDIST_SYM];
    MAP_EVERY X_GEN_TAC [`x::K=>A`; `y::K=>A`; `z::K=>A`] THEN
    ASM_SIMP_TAC[] THEN STRIP_TAC THEN X_GEN_TAC `i::K` THEN DISCH_TAC THEN
    TRANS_TAC REAL_LE_TRANS
      `d (m i) ((x::K=>A) i,y i) + d (m i) (y i,z i)` THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC MDIST_TRIANGLE THEN
      RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM; o_THM]) THEN
      ASM_SIMP_TAC[];
      MATCH_MP_TAC REAL_LE_ADD2 THEN EXPAND_TAC "M" THEN
      REWRITE_TAC[] THEN CONJ_TAC THEN MATCH_MP_TAC ELEMENT_LE_SUP THEN
      RULE_ASSUM_TAC(REWRITE_RULE[PiE; IN_ELIM_THM; o_THM]) THEN
      ASM SET_TAC[]]]);;

let (METRIZABLE_SPACE_PRODUCT_TOPOLOGY,
     COMPLETELY_METRIZABLE_SPACE_PRODUCT_TOPOLOGY) = (CONJ_PAIR \<circ> prove)
 (`(!(tops::K=>A topology) k.
        metrizable_space (product_topology k tops) \<longleftrightarrow>
        topspace (product_topology k tops) = {} \<or>
        countable {i. i \<in> k \<and> \<not> (\<exists>a. topspace(tops i) \<subseteq> {a})} \<and>
        \<forall>i. i \<in> k \<Longrightarrow> metrizable_space (tops i)) \<and>
   (!(tops::K=>A topology) k.
        completely_metrizable_space (product_topology k tops) \<longleftrightarrow>
        topspace (product_topology k tops) = {} \<or>
        countable {i. i \<in> k \<and> \<not> (\<exists>a. topspace(tops i) \<subseteq> {a})} \<and>
        \<forall>i. i \<in> k \<Longrightarrow> completely_metrizable_space (tops i))"
oops
  REWRITE_TAC[AND_FORALL_THM] THEN REPEAT GEN_TAC THEN
  MATCH_MP_TAC(TAUT
   `(n \<Longrightarrow> m) \<and> (t \<Longrightarrow> n) \<and> (m \<Longrightarrow> t \<or> m') \<and> (n \<Longrightarrow> t \<or> n') \<and>
    (\<not> t \<Longrightarrow> m \<and> m' \<Longrightarrow> c) \<and> (\<not> t \<Longrightarrow> c \<Longrightarrow> (m' \<Longrightarrow> m) \<and> (n' \<Longrightarrow> n))
    \<Longrightarrow> (m \<longleftrightarrow> t \<or> c \<and> m') \<and> (n \<longleftrightarrow> t \<or> c \<and> n')`) THEN
  REWRITE_TAC[COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE] THEN CONJ_TAC THENL
   [SIMP_TAC[GSYM SUBTOPOLOGY_EQ_DISCRETE_TOPOLOGY_EMPTY] THEN
    REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_DISCRETE_TOPOLOGY];
    GEN_REWRITE_TAC id [CONJ_ASSOC]] THEN
  CONJ_TAC THENL
   [CONJ_TAC THEN MATCH_MP_TAC TOPOLOGICAL_PROPERTY_OF_PRODUCT_COMPONENT THEN
    REWRITE_TAC[HOMEOMORPHIC_COMPLETELY_METRIZABLE_SPACE;
                HOMEOMORPHIC_METRIZABLE_SPACE] THEN
    ASM_SIMP_TAC[METRIZABLE_SPACE_SUBTOPOLOGY] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_CLOSED_IN THEN
    ASM_REWRITE_TAC[CLOSED_IN_CARTESIAN_PRODUCT] THEN
    DISJ2_TAC THEN REPEAT STRIP_TAC THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[CLOSED_IN_TOPSPACE] THEN
    FIRST_ASSUM(MP_TAC \<circ>
      MATCH_MP COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE) THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP METRIZABLE_IMP_T1_SPACE) THEN
    REWRITE_TAC[T1_SPACE_PRODUCT_TOPOLOGY] THEN
    REWRITE_TAC[T1_SPACE_CLOSED_IN_SING; RIGHT_IMP_FORALL_THM; IMP_IMP] THEN
    STRIP_TAC THENL [ASM SET_TAC[]; FIRST_X_ASSUM MATCH_MP_TAC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE
     [TOPSPACE_PRODUCT_TOPOLOGY; PiE; o_DEF; IN_ELIM_THM]) THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN ABBREV_TAC
     `l = {i::K | i \<in> k \<and> \<not> (\<exists>a::A. topspace(tops i) \<subseteq> {a})}` THEN
    SUBGOAL_THEN
     `\<forall>i::K. \<exists>p q::A.
        i \<in> l \<Longrightarrow> p \<in> topspace(tops i) \<and> q \<in> topspace(tops i) \<and> (p \<noteq> q)`
    MP_TAC THENL [EXPAND_TAC "l" THEN SET_TAC[]; ALL_TAC] THEN
    REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`a::K=>A`; `b::K=>A`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; o_DEF; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `z::K=>A` THEN DISCH_TAC THEN
    ABBREV_TAC `p::K=>A = \<lambda>i. if i \<in> l then a i else z i` THEN
    ABBREV_TAC `q::K=>K->A = \<lambda>i j. if j = i then b i else p j` THEN
    SUBGOAL_THEN
     `p \<in> topspace(product_topology k (tops::K=>A topology)) \<and>
      (\<forall>i::K. i \<in> l
             \<Longrightarrow> q i \<in> topspace(product_topology k (tops::K=>A topology)))`
    STRIP_ASSUME_TAC THENL
     [UNDISCH_TAC `(z::K=>A) \<in> PiE k (\<lambda>x. topspace(tops x))` THEN
      MAP_EVERY EXPAND_TAC ["q"; "p"] THEN
      REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; o_THM] THEN
      REWRITE_TAC[EXTENSIONAL; IN_ELIM_THM] THEN ASM SET_TAC[];
      ALL_TAC] THEN
    SUBGOAL_THEN
     `\<forall>u:(K=>A)->bool.
        openin (product_topology k tops) u \<and> p \<in> u
        \<Longrightarrow> finite {i::K | i \<in> l \<and> \<not> (q i \<in> u)}`
    ASSUME_TAC THENL
     [X_GEN_TAC `u:(K=>A)->bool` THEN
      DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
      REWRITE_TAC[OPEN_IN_PRODUCT_TOPOLOGY_ALT] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `p::K=>A`) THEN
      ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC `v::K=>A->bool` THEN
      DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] FINITE_SUBSET) THEN
      REWRITE_TAC[\<subseteq>; IN_ELIM_THM] THEN X_GEN_TAC `i::K` THEN
      MATCH_MP_TAC(TAUT
       `(l \<Longrightarrow> k) \<and> (k \<and> l \<Longrightarrow> p \<Longrightarrow> q) \<Longrightarrow> l \<and> \<not> q \<Longrightarrow> k \<and> \<not> p`) THEN
      CONJ_TAC THENL [ASM SET_TAC[]; REPEAT STRIP_TAC] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [\<subseteq>]) THEN
      EXPAND_TAC "q" THEN UNDISCH_TAC `(p::K=>A) \<in> PiE k v` THEN
      REWRITE_TAC[PiE; IN_ELIM_THM; EXTENSIONAL] THEN
      ASM SET_TAC[];
      ALL_TAC] THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [metrizable_space]) THEN
    DISCH_THEN(X_CHOOSE_TAC `m:(K=>A)metric`) THEN
    MATCH_MP_TAC COUNTABLE_SUBSET THEN
    EXISTS_TAC `\<Union> {{i. i \<in> l \<and>
                             \<not> ((q::K=>K->A) i \<in> mball m (p,inverse(Suc n)))} |
                        n \<in> UNIV}` THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC COUNTABLE_UNIONS THEN REWRITE_TAC[SIMPLE_IMAGE] THEN
      SIMP_TAC[COUNTABLE_IMAGE; NUM_COUNTABLE; FORALL_IN_IMAGE] THEN
      X_GEN_TAC `n::num` THEN DISCH_THEN(K ALL_TAC) THEN
      MATCH_MP_TAC FINITE_IMP_COUNTABLE THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      ASM_REWRITE_TAC[OPEN_IN_MBALL] THEN MATCH_MP_TAC CENTRE_IN_MBALL THEN
      REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
      ASM_MESON_TAC[TOPSPACE_MTOPOLOGY];
      REWRITE_TAC[\<subseteq>; UNIONS_GSPEC; IN_ELIM_THM; IN_UNIV] THEN
      X_GEN_TAC `i::K` THEN DISCH_TAC THEN MP_TAC(snd(EQ_IMP_RULE(ISPEC
       `d (m:(K=>A)metric) (p,q(i::K))` ARCH_EVENTUALLY_INV1))) THEN
      ANTS_TAC THENL
       [MATCH_MP_TAC MDIST_POS_LT THEN REPEAT
         (CONJ_TAC THENL [ASM_MESON_TAC[TOPSPACE_MTOPOLOGY]; ALL_TAC]) THEN
        DISCH_THEN(MP_TAC \<circ> C AP_THM `i::K`) THEN
        MAP_EVERY EXPAND_TAC ["q"; "p"] THEN REWRITE_TAC[] THEN
        ASM_SIMP_TAC[];
        DISCH_THEN(MP_TAC \<circ> MATCH_MP EVENTUALLY_HAPPENS_SEQUENTIALLY) THEN
        MATCH_MP_TAC MONO_EXISTS THEN
        ASM_REWRITE_TAC[IN_MBALL] THEN REAL_ARITH_TAC]];
    ALL_TAC] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  ASM_CASES_TAC `k::K=>bool = {}` THENL
   [ASM_REWRITE_TAC[NOT_IN_EMPTY; EMPTY_GSPEC; COUNTABLE_EMPTY] THEN
    REWRITE_TAC[PRODUCT_TOPOLOGY_EMPTY_DISCRETE;
                METRIZABLE_SPACE_DISCRETE_TOPOLOGY;
                COMPLETELY_METRIZABLE_SPACE_DISCRETE_TOPOLOGY];
    ALL_TAC] THEN
  REWRITE_TAC[metrizable_space; completely_metrizable_space] THEN
  GEN_REWRITE_TAC (BINOP_CONV \<circ> LAND_CONV \<circ> BINDER_CONV)
      [RIGHT_IMP_EXISTS_THM] THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM; AND_FORALL_THM] THEN
  X_GEN_TAC `m::K=>A metric` THEN ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN
  ASM_CASES_TAC `\<forall>i. i \<in> k \<Longrightarrow> mtopology(m i) = (tops::K=>A topology) i` THEN
  ASM_SIMP_TAC[] THENL [ALL_TAC; ASM_MESON_TAC[]] THEN MATCH_MP_TAC(MESON[]
   `\<forall>m. P m \<and> (Q \<Longrightarrow> C m) \<Longrightarrow> (\<exists>m. P m) \<and> (Q \<Longrightarrow> \<exists>m. C m \<and> P m)`) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id
   [COUNTABLE_AS_INJECTIVE_IMAGE_SUBSET]) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; INJECTIVE_ON_LEFT_INVERSE] THEN
  MAP_EVERY X_GEN_TAC [`nk::num=>K`; `c::num=>bool`] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (X_CHOOSE_TAC `kn::K=>num`)) THEN
  MP_TAC(ISPECL
   [`k::K=>bool`; `\<lambda>i. capped_metric (inverse((kn i) + 1)) ((m::K=>A metric) i)`]
   SUP_METRIC_CARTESIAN_PRODUCT) THEN
  REWRITE_TAC[o_DEF; CONJUNCT1(SPEC_ALL CAPPED_METRIC)] THEN
  MATCH_MP_TAC(MESON[]
   `Q \<and> (\<forall>m. P m \<Longrightarrow> R m)
    \<Longrightarrow> (\<forall>m. a = m \<and> Q \<Longrightarrow> P m) \<Longrightarrow> \<exists>m. R m`) THEN
  CONJ_TAC THENL
   [ASM_REWRITE_TAC[] THEN EXISTS_TAC `1::real` THEN
    REWRITE_TAC[CAPPED_METRIC; GSYM REAL_NOT_LT] THEN
    REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
    REWRITE_TAC[REAL_NOT_LT; REAL_MIN_LE] THEN REPEAT STRIP_TAC THEN
    DISJ1_TAC THEN MATCH_MP_TAC REAL_INV_LE_1 THEN REAL_ARITH_TAC;
    X_GEN_TAC `M:(K=>A)metric`] THEN
  SUBGOAL_THEN
   `PiE k (\<lambda>i. mspace (m i)) =
    topspace(product_topology k (tops::K=>A topology))`
  SUBST1_TAC THENL
   [REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; CARTESIAN_PRODUCT_EQ] THEN
    ASM_SIMP_TAC[GSYM TOPSPACE_MTOPOLOGY; o_THM];
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    DISCH_THEN(CONJUNCTS_THEN2 (ASSUME_TAC \<circ> SYM) ASSUME_TAC)] THEN
  MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
   [REWRITE_TAC[MTOPOLOGY_BASE; product_topology] THEN
    REWRITE_TAC[GSYM TOPSPACE_PRODUCT_TOPOLOGY_ALT] THEN
    REWRITE_TAC[PRODUCT_TOPOLOGY_BASE_ALT] THEN
    MATCH_MP_TAC TOPOLOGY_BASES_EQ THEN
    REWRITE_TAC[SET_RULE `GSPEC P x \<longleftrightarrow> x \<in> GSPEC P`] THEN
    REWRITE_TAC[EXISTS_IN_GSPEC; IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[FORALL_IN_GSPEC; GSYM CONJ_ASSOC; IN_MBALL] THEN CONJ_TAC THENL
     [MAP_EVERY X_GEN_TAC [`z::K=>A`; `r::real`] THEN STRIP_TAC THEN
      X_GEN_TAC `x::K=>A` THEN STRIP_TAC THEN
      SUBGOAL_THEN
       `(\<forall>i. i \<in> k \<Longrightarrow> (z::K=>A) i \<in> topspace(tops i)) \<and>
        (\<forall>i. i \<in> k \<Longrightarrow> (x::K=>A) i \<in> topspace(tops i))`
      STRIP_ASSUME_TAC THENL
       [MAP_EVERY UNDISCH_TAC
         [`(z::K=>A) \<in> mspace M`; `(x::K=>A) \<in> mspace M`] THEN
        ASM_SIMP_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE; o_DEF] THEN
        SET_TAC[];
        ALL_TAC] THEN
      SUBGOAL_THEN `\<exists>R. 0 < R \<and> d M (z::K=>A,x) < R \<and> R < r`
      STRIP_ASSUME_TAC THENL
       [ASM_MESON_TAC[REAL_LT_BETWEEN; REAL_LET_TRANS; MDIST_POS_LE];
        ALL_TAC] THEN
      EXISTS_TAC
       `\<lambda>i. if R \<le> inverse((kn i) + 1) then mball (m i) (z i,R)
            else topspace((tops::K=>A topology) i)` THEN
      REWRITE_TAC[] THEN REPEAT CONJ_TAC THENL
       [MP_TAC(ASSUME `0 < R`) THEN DISCH_THEN(MP_TAC \<circ>
          SPEC `1::real` \<circ> MATCH_MP REAL_ARCH) THEN
        DISCH_THEN(X_CHOOSE_TAC `n::num`) THEN
        MATCH_MP_TAC FINITE_SUBSET THEN
        EXISTS_TAC `image (nk::num=>K) (c \<inter> {0..n})` THEN
        SIMP_TAC[FINITE_IMAGE; FINITE_INTER; FINITE_NUMSEG] THEN
        REWRITE_TAC[\<subseteq>; IN_ELIM_THM; MESON[]
         `\<not> ((if p then x else y) = y) \<longleftrightarrow> p \<and> (x \<noteq> y)`] THEN
        FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
         `{i. i \<in> k \<and> P i} = nk ` c
          \<Longrightarrow> (\<forall>i. i \<in> k \<and> Q i \<Longrightarrow> P i) \<and>
              (\<forall>n. n \<in> c \<Longrightarrow> Q(nk n) \<Longrightarrow> n \<in> s)
              \<Longrightarrow> \<forall>i. i \<in> k \<and> Q i \<Longrightarrow> i \<in> image nk (c \<inter> s)`)) THEN
        CONJ_TAC THENL
         [X_GEN_TAC `i::K` THEN
          DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
          MATCH_MP_TAC(SET_RULE
           `\<forall>x. b \<subseteq> u \<and> x \<in> b
                \<Longrightarrow> P \<and> (b \<noteq> u) \<Longrightarrow> \<not> (\<exists>a. u \<subseteq> {a})`) THEN
          EXISTS_TAC `(z::K=>A) i` THEN CONJ_TAC THENL
           [REWRITE_TAC[\<subseteq>; IN_MBALL];
            MATCH_MP_TAC CENTRE_IN_MBALL] THEN
          ASM_MESON_TAC[TOPSPACE_MTOPOLOGY];
          X_GEN_TAC `m::num` THEN ASM_SIMP_TAC[IN_NUMSEG; LE_0] THEN
          DISCH_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
          GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
          REWRITE_TAC[NOT_LE; REAL_NOT_LE] THEN DISCH_TAC THEN
          REWRITE_TAC[REAL_ARITH `inverse x < y \<longleftrightarrow> 1 / x < y`] THEN
          ASM_SIMP_TAC[REAL_LT_LDIV_EQ; REAL_ARITH `0 < n + 1`] THEN
          FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REAL_ARITH
           `1 < n * r \<Longrightarrow> r * n < r * m \<Longrightarrow> 1 < r * m`)) THEN
          ASM_SIMP_TAC[REAL_LT_LMUL_EQ; REAL_OF_NUM_ADD; REAL_OF_NUM_LT] THEN
          ASM_ARITH_TAC];
        ASM_MESON_TAC[OPEN_IN_MBALL; OPEN_IN_TOPSPACE];
        SUBGOAL_THEN `(x::K=>A) \<in> PiE k (topspace \<circ> tops)`
        MP_TAC THENL [ASM_MESON_TAC[TOPSPACE_PRODUCT_TOPOLOGY]; ALL_TAC] THEN
        REWRITE_TAC[PiE; o_DEF; IN_ELIM_THM] THEN
        STRIP_TAC THEN ASM_REWRITE_TAC[] THEN X_GEN_TAC `i::K` THEN
        DISCH_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC[IN_MBALL] THEN
        REPEAT(CONJ_TAC THENL
         [ASM_MESON_TAC[TOPSPACE_MTOPOLOGY]; ALL_TAC]) THEN
        FIRST_X_ASSUM(MP_TAC \<circ> SPECL
         [`z::K=>A`; `x::K=>A`; `d M (z::K=>A,x)`]) THEN
        ANTS_TAC THENL [ASM_MESON_TAC[]; REWRITE_TAC[REAL_LE_REFL]] THEN
        DISCH_THEN(MP_TAC \<circ> SPEC `i::K`) THEN
        ASM_REWRITE_TAC[CAPPED_METRIC] THEN ASM_REAL_ARITH_TAC;
        REWRITE_TAC[\<subseteq>] THEN X_GEN_TAC `y::K=>A` THEN
        DISCH_THEN(LABEL_TAC "*") THEN
        SUBGOAL_THEN `(y::K=>A) \<in> mspace M` ASSUME_TAC THENL
         [ASM_REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY] THEN
          REMOVE_THEN "*" MP_TAC THEN REWRITE_TAC[PiE] THEN
          REWRITE_TAC[IN_ELIM_THM; o_THM] THEN
          MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
          MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `i::K` THEN
          ASM_CASES_TAC `(i::K) \<in> k` THEN ASM_REWRITE_TAC[] THEN
          COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_MBALL] THEN
          MATCH_MP_TAC(SET_RULE
           `s \<subseteq> t \<Longrightarrow> P \<and> x \<in> s \<and> Q \<Longrightarrow> x \<in> t`) THEN
          ASM_SIMP_TAC[GSYM TOPSPACE_MTOPOLOGY; SUBSET_REFL];
          ALL_TAC] THEN
        ASM_REWRITE_TAC[IN_MBALL] THEN
        TRANS_TAC REAL_LET_TRANS `R::real` THEN ASM_REWRITE_TAC[] THEN
        FIRST_X_ASSUM(MP_TAC \<circ> SPECL
         [`z::K=>A`; `y::K=>A`; `R::real`]) THEN
        ANTS_TAC THENL [ASM_MESON_TAC[]; DISCH_THEN SUBST1_TAC] THEN
        REWRITE_TAC[CAPPED_METRIC; REAL_ARITH `x \<le> 0 \<longleftrightarrow> \<not> (0 < x)`] THEN
        REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
        REWRITE_TAC[REAL_MIN_LE] THEN X_GEN_TAC `i::K` THEN DISCH_TAC THEN
        MATCH_MP_TAC(REAL_ARITH
         `(a \<le> b \<Longrightarrow> c \<le> d) \<Longrightarrow> b \<le> a \<or> c \<le> d`) THEN
        DISCH_TAC THEN REMOVE_THEN "*" MP_TAC THEN
        ASM_REWRITE_TAC[PiE; IN_ELIM_THM] THEN
        DISCH_THEN(MP_TAC \<circ> SPEC `i::K` \<circ> CONJUNCT2) THEN
        ASM_REWRITE_TAC[IN_MBALL] THEN REAL_ARITH_TAC];
      X_GEN_TAC `u::K=>A->bool` THEN STRIP_TAC THEN
      X_GEN_TAC `z::K=>A` THEN DISCH_TAC THEN
      SUBGOAL_THEN `(z::K=>A) \<in> mspace M` ASSUME_TAC THENL
       [UNDISCH_TAC `(z::K=>A) \<in> PiE k u` THEN
        ASM_REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE] THEN
        REWRITE_TAC[IN_ELIM_THM; o_THM] THEN
        ASM_MESON_TAC[OPEN_IN_SUBSET; \<subseteq>];
        EXISTS_TAC `z::K=>A` THEN ASM_SIMP_TAC[MDIST_REFL; CONJ_ASSOC]] THEN
      SUBGOAL_THEN
       `\<forall>i. \<exists>r. i \<in> k \<Longrightarrow> 0 < r \<and> mball (m i) ((z::K=>A) i,r) \<subseteq> u i`
      MP_TAC THENL
       [X_GEN_TAC `i::K` THEN REWRITE_TAC[RIGHT_EXISTS_IMP_THM] THEN
        DISCH_TAC THEN
        SUBGOAL_THEN `openin(mtopology(m i)) ((u::K=>A->bool) i)` MP_TAC THENL
         [ASM_MESON_TAC[]; REWRITE_TAC[OPEN_IN_MTOPOLOGY]] THEN
        DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MATCH_MP_TAC) THEN
        UNDISCH_TAC `(z::K=>A) \<in> PiE k u` THEN
        ASM_SIMP_TAC[PiE; IN_ELIM_THM];
        REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
      X_GEN_TAC `r::K=>real` THEN DISCH_TAC THEN
      SUBGOAL_THEN `\<exists>a::K. a \<in> k` STRIP_ASSUME_TAC THENL
       [ASM SET_TAC[]; ALL_TAC] THEN
      EXISTS_TAC
        `inf (image (\<lambda>i. min (r i) (inverse((kn i) + 1)))
                 (a insert {i. i \<in> k \<and>
                                \<not> (u i = topspace ((tops::K=>A topology) i))})) /
         2` THEN
      ASM_SIMP_TAC[REAL_LT_INF_FINITE; FINITE_INSERT; NOT_INSERT_EMPTY;
        REAL_HALF; FINITE_IMAGE; IMAGE_EQ_EMPTY; FORALL_IN_IMAGE] THEN
      REWRITE_TAC[REAL_LT_MIN; REAL_LT_INV_EQ] THEN
      REWRITE_TAC[REAL_ARITH `0 < n + 1`] THEN
      ASM_SIMP_TAC[FORALL_IN_INSERT; IN_ELIM_THM] THEN
      REWRITE_TAC[\<subseteq>; IN_MBALL] THEN X_GEN_TAC `x::K=>A` THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC \<circ> CONJUNCT2) THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP REAL_LT_IMP_LE) THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`z::K=>A`; `x::K=>A`]) THEN
      REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN
      ANTS_TAC THENL [ASM_MESON_TAC[]; ALL_TAC] THEN
      DISCH_THEN(fun th -> REWRITE_TAC[th]) THEN
      SUBGOAL_THEN `(x::K=>A) \<in> topspace(product_topology k tops)` MP_TAC THENL
       [ASM_MESON_TAC[]; REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY]] THEN
      REWRITE_TAC[PiE; o_THM; IN_ELIM_THM] THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
      ASM_REWRITE_TAC[IMP_IMP; AND_FORALL_THM] THEN
      MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `i::K` THEN
      ASM_CASES_TAC `(i::K) \<in> k` THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
      REWRITE_TAC[REAL_ARITH `x \<le> y / 2 \<longleftrightarrow> 2 * x \<le> y`] THEN
      ASM_SIMP_TAC[REAL_LE_INF_FINITE; FINITE_INSERT; NOT_INSERT_EMPTY;
        REAL_HALF; FINITE_IMAGE; IMAGE_EQ_EMPTY; FORALL_IN_IMAGE] THEN
      REWRITE_TAC[FORALL_IN_INSERT] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `i::K` \<circ> CONJUNCT2) THEN
      ASM_CASES_TAC `(u::K=>A->bool) i = topspace(tops i)` THEN
      ASM_REWRITE_TAC[IN_ELIM_THM] THEN
      REWRITE_TAC[CAPPED_METRIC; REAL_ARITH `x \<le> 0 \<longleftrightarrow> \<not> (0 < x)`] THEN
      REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP (REAL_ARITH
       `2 * min a b \<le> min c a \<Longrightarrow> 0 < a \<and> 0 < c \<Longrightarrow> b < c`)) THEN
      REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
      ASM_SIMP_TAC[] THEN DISCH_TAC THEN
      REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `i::K`)) THEN
      ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
      FIRST_X_ASSUM(MATCH_MP_TAC \<circ> GEN_REWRITE_RULE id [\<subseteq>]) THEN
      ASM_REWRITE_TAC[IN_MBALL] THEN
      CONJ_TAC THENL [ALL_TAC; ASM_MESON_TAC[TOPSPACE_MTOPOLOGY]] THEN
      UNDISCH_TAC `(z::K=>A) \<in> mspace M` THEN
      ASM_REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE] THEN
      REWRITE_TAC[IN_ELIM_THM; o_DEF] THEN
      ASM_MESON_TAC[TOPSPACE_MTOPOLOGY]];
    DISCH_TAC THEN REWRITE_TAC[mcomplete] THEN DISCH_THEN(LABEL_TAC "*") THEN
    X_GEN_TAC `x::num=>K->A` THEN ASM_REWRITE_TAC[MCauchy] THEN STRIP_TAC THEN
    ASM_REWRITE_TAC[LIMIT_COMPONENTWISE] THEN
    SUBGOAL_THEN
     `\<forall>i. \<exists>y. i \<in> k \<Longrightarrow> limitin (tops i) (\<lambda>n. (x::num=>K->A) n i) y sequentially`
    MP_TAC THENL
     [X_GEN_TAC `i::K` THEN ASM_CASES_TAC `(i::K) \<in> k` THEN
      ASM_REWRITE_TAC[] THEN REMOVE_THEN "*" (MP_TAC \<circ> SPEC `i::K`) THEN
      ASM_SIMP_TAC[] THEN DISCH_THEN MATCH_MP_TAC THEN
      REWRITE_TAC[MCauchy; GSYM TOPSPACE_MTOPOLOGY] THEN CONJ_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_PRODUCT_TOPOLOGY;
           PiE; IN_ELIM_THM; o_DEF]) THEN ASM_MESON_TAC[];
        X_GEN_TAC `e::real` THEN DISCH_TAC] THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `min e (inverse(&(kn(i::K)) + 1)) / 2`) THEN
      REWRITE_TAC[REAL_HALF; REAL_LT_MIN; REAL_LT_INV_EQ] THEN
      ANTS_TAC THENL [ASM_REAL_ARITH_TAC; MATCH_MP_TAC MONO_EXISTS] THEN
      X_GEN_TAC `N::num` THEN DISCH_TAC THEN
      MAP_EVERY X_GEN_TAC [`m::num`; `n::num`] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`m::num`; `n::num`]) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> MATCH_MP REAL_LT_IMP_LE) THEN
      ASM_SIMP_TAC[] THEN DISCH_THEN(MP_TAC \<circ> SPEC `i::K`) THEN
      ASM_REWRITE_TAC[CAPPED_METRIC; REAL_ARITH `x \<le> 0 \<longleftrightarrow> \<not> (0 < x)`] THEN
      REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`] THEN
      MATCH_MP_TAC(REAL_ARITH
        `0 < d \<and> 0 < e \<Longrightarrow> min d x \<le> min e d / 2 \<Longrightarrow> x < e`) THEN
      ASM_REWRITE_TAC[REAL_LT_INV_EQ; REAL_ARITH `0 < n + 1`];
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    X_GEN_TAC `y::K=>A` THEN DISCH_TAC THEN
    EXISTS_TAC `RESTRICTION k (y::K=>A)` THEN
    ASM_REWRITE_TAC[REWRITE_RULE[\<in>] RESTRICTION_IN_EXTENSIONAL] THEN
    SIMP_TAC[RESTRICTION; EVENTUALLY_TRUE] THEN ASM_REWRITE_TAC[]]);;


subsection\<open>A perfect set in common cases must have cardinality >= c\<close>


lemma card_ge_perfect_set:
   "
        (completely_metrizable_space X \<or>
         locally_compact_space X \<and> Hausdorff_space X) \<and>
        X derived_set_of s = s \<and> (s \<noteq> {})
        \<Longrightarrow> UNIV \<lesssim> s"
oops
  REWRITE_TAC[TAUT `(p \<or> q) \<and> r \<Longrightarrow> s \<longleftrightarrow>
                    (p \<Longrightarrow> r \<Longrightarrow> s) \<and> (q \<and> r \<Longrightarrow> s)`] THEN
  REWRITE_TAC[FORALL_AND_THM; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[GSYM FORALL_MCOMPLETE_TOPOLOGY] THEN
  REWRITE_TAC[RIGHT_IMP_FORALL_THM; IMP_IMP; GSYM CONJ_ASSOC] THEN
  CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN
    TRANS_TAC CARD_LE_TRANS `(:num=>bool)` THEN
    SIMP_TAC[CARD_EQ_REAL; CARD_EQ_IMP_LE] THEN
    SUBGOAL_THEN `(s::A=>bool) \<subseteq> M` ASSUME_TAC THENL
     [ASM_MESON_TAC[DERIVED_SET_OF_SUBSET_TOPSPACE; TOPSPACE_MTOPOLOGY];
      ALL_TAC] THEN
    SUBGOAL_THEN
     `\<forall>x e. x \<in> s \<and> 0 < e
            \<Longrightarrow> \<exists>y z d. y \<in> s \<and> z \<in> s \<and> 0 < d \<and> d < e / 2 \<and>
                        mcball y d \<subseteq> mcball x e \<and>
                        mcball z d \<subseteq> mcball x e \<and>
                        disjnt (mcball m (y::A,d)) (mcball z d)`
    MP_TAC THENL
     [REPEAT STRIP_TAC THEN
      MP_TAC(ISPECL [`m::A metric`; `s::A=>bool`]
          DERIVED_SET_OF_INFINITE_MBALL) THEN
      ASM_REWRITE_TAC[EXTENSION; IN_ELIM_THM] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC `e / 4`)) THEN
      ASM_REWRITE_TAC[infinite; REAL_ARITH `0 < e / 4 \<longleftrightarrow> 0 < e`] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `x::A` \<circ> MATCH_MP
       (MESON[FINITE_RULES; FINITE_SUBSET]
         `\<not> finite s \<Longrightarrow> \<forall>a b c. \<not> (s \<subseteq> {a,b,c})`)) THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP (SET_RULE
       `(\<forall>b c. \<not> (s \<subseteq> {a,b,c}))
        \<Longrightarrow> \<exists>b c. b \<in> s \<and> c \<in> s \<and> (c \<noteq> a) \<and> (b \<noteq> a) \<and> (b \<noteq> c)`)) THEN
      MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `l::A` THEN
      MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `r::A` THEN
      REWRITE_TAC[IN_INTER] THEN STRIP_TAC THEN
      EXISTS_TAC `d l::A r / 3` THEN
      REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_MBALL])) THEN
      UNDISCH_TAC `\<not> (l::A = r)` THEN
      REWRITE_TAC[disjnt; \<subseteq>; EXTENSION; IN_INTER; NOT_IN_EMPTY] THEN
      ASM_SIMP_TAC[IN_MCBALL] THEN UNDISCH_TAC `(x::A) \<in> M` THEN
      POP_ASSUM_LIST(K ALL_TAC) THEN
      REPEAT(DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC)) THEN
      ONCE_REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
       [REPEAT(POP_ASSUM MP_TAC) THEN CONV_TAC METRIC_ARITH; ALL_TAC] THEN
      REWRITE_TAC[AND_FORALL_THM] THEN X_GEN_TAC `y::A` THEN
      REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
       [ALL_TAC; REPEAT(POP_ASSUM MP_TAC) THEN CONV_TAC METRIC_ARITH] THEN
      REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC \<circ> SPEC `e::real` \<circ> MATCH_MP
        (REAL_ARITH `x \<le> y / 3 \<Longrightarrow> \<forall>e. y < e / 2 \<Longrightarrow> x < e / 6`)) THEN
      (ANTS_TAC THENL
        [REPEAT(POP_ASSUM MP_TAC) THEN CONV_TAC METRIC_ARITH; ALL_TAC])
      THENL
       [UNDISCH_TAC `d x::A l < e / 4`;
        UNDISCH_TAC `d x::A r < e / 4`] THEN
      MAP_EVERY UNDISCH_TAC
       [`(x::A) \<in> M`; `(y::A) \<in> M`;
        `(l::A) \<in> M`; `(r::A) \<in> M`] THEN
      CONV_TAC METRIC_ARITH;
      REWRITE_TAC[RIGHT_IMP_EXISTS_THM; SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC
     [`l::A=>real->A`; `r::A=>real->A`; `d::A=>real->real`] THEN
    DISCH_TAC THEN FIRST_X_ASSUM(X_CHOOSE_TAC `a::A` \<circ>
     REWRITE_RULE[GSYM MEMBER_NOT_EMPTY]) THEN
    SUBGOAL_THEN
      `\<forall>b. \<exists>xe. xe 0 = (a::A,1) \<and>
                \<forall>n. xe(Suc n) = (if b n then r else l) (fst(xe n)) (snd(xe n)),
                                d (fst(xe n)) (snd(xe n))`
    MP_TAC THENL
     [GEN_TAC THEN
      W(ACCEPT_TAC \<circ> prove_recursive_functions_exist num_RECURSION \<circ>
          snd \<circ> dest_exists \<circ> snd);
      REWRITE_TAC[EXISTS_PAIR_FUN_THM; PAIR_EQ] THEN
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM; FORALL_AND_THM]] THEN
    MAP_EVERY X_GEN_TAC
     [`x:(num=>bool)->num=>A`; `r:(num=>bool)->num=>real`] THEN
    STRIP_TAC THEN
    SUBGOAL_THEN `mcomplete (submetric s::A metric)` MP_TAC THENL
     [MATCH_MP_TAC CLOSED_IN_MCOMPLETE_IMP_MCOMPLETE THEN
      ASM_REWRITE_TAC[CLOSED_IN_CONTAINS_DERIVED_SET; TOPSPACE_MTOPOLOGY] THEN
      ASM SET_TAC[];
      REWRITE_TAC[MCOMPLETE_NEST_SING]] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP MONO_FORALL \<circ> GEN `b::num=>bool` \<circ>
      SPEC `\<lambda>n. mcball (submetric s)
                       ((x:(num=>bool)->num=>A) b n,r b n)`) THEN
    REWRITE_TAC[SKOLEM_THM] THEN
    SUBGOAL_THEN `(\<forall>b n. (x:(num=>bool)->num=>A) b n \<in> s) \<and>
                  (\<forall>b n. 0 < (r:(num=>bool)->num=>real) b n)`
    STRIP_ASSUME_TAC THENL
     [REWRITE_TAC[AND_FORALL_THM] THEN GEN_TAC THEN
      INDUCT_TAC THEN ASM_REWRITE_TAC[REAL_LT_01] THEN ASM_MESON_TAC[];
      ALL_TAC] THEN
    SUBGOAL_THEN `(\<forall>b n. (x:(num=>bool)->num=>A) b n \<in> M)`
    ASSUME_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
    ANTS_TAC THENL
     [X_GEN_TAC `b::num=>bool` THEN REWRITE_TAC[CLOSED_IN_MCBALL] THEN
      ASM_REWRITE_TAC[MCBALL_EQ_EMPTY; SUBMETRIC; IN_INTER] THEN
      ASM_SIMP_TAC[REAL_ARITH `0 < x \<Longrightarrow> \<not> (x < 0)`] THEN CONJ_TAC THENL
       [MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
        REPEAT(CONJ_TAC THENL [SET_TAC[]; ALL_TAC]) THEN
        ASM_REWRITE_TAC[MCBALL_SUBMETRIC_EQ] THEN ASM SET_TAC[];
        X_GEN_TAC `e::real` THEN DISCH_TAC THEN
        MP_TAC(ISPECL [`inverse 2`; `e::real`] REAL_ARCH_POW_INV) THEN
        ASM_REWRITE_TAC[REAL_POW_INV] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
        MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `n::num` THEN
        DISCH_TAC THEN EXISTS_TAC `(x:(num=>bool)->num=>A) b n` THEN
        MATCH_MP_TAC MCBALL_SUBSET_CONCENTRIC THEN
        TRANS_TAC REAL_LE_TRANS `inverse(2 ^ n)` THEN
        ASM_SIMP_TAC[REAL_LT_IMP_LE] THEN
        SPEC_TAC(`n::num`,`n::num`) THEN
        MATCH_MP_TAC num_INDUCTION THEN ASM_REWRITE_TAC[real_pow] THEN
        CONV_TAC REAL_RAT_REDUCE_CONV THEN REWRITE_TAC[REAL_INV_MUL] THEN
        GEN_TAC THEN MATCH_MP_TAC(REAL_ARITH
         `d < e / 2 \<Longrightarrow> e \<le> i \<Longrightarrow> d \<le> inverse 2 * i`) THEN
        ASM_SIMP_TAC[]];
      REWRITE_TAC[SKOLEM_THM; le_c; IN_UNIV] THEN
      MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `z:(num=>bool)->A` THEN
      SIMP_TAC[SUBMETRIC; IN_INTER; FORALL_AND_THM] THEN STRIP_TAC THEN
      MAP_EVERY X_GEN_TAC [`b::num=>bool`; `c::num=>bool`] THEN
      GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
      REWRITE_TAC[FUN_EQ_THM; NOT_FORALL_THM] THEN
      GEN_REWRITE_TAC LAND_CONV [num_WOP] THEN
      REWRITE_TAC[LEFT_IMP_EXISTS_THM; TAUT `\<not> (p \<longleftrightarrow> q) \<longleftrightarrow> p \<longleftrightarrow> \<not> q`] THEN
      X_GEN_TAC `n::num` THEN REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC \<circ>
        GEN_REWRITE_RULE (BINDER_CONV \<circ> LAND_CONV) [INTERS_GSPEC]) THEN
      DISCH_THEN(fun th ->
       MP_TAC(SPEC `c::num=>bool` th) THEN MP_TAC(SPEC `b::num=>bool` th)) THEN
      ASM_REWRITE_TAC[TAUT `p \<Longrightarrow> \<not> q \<longleftrightarrow> \<not> (p \<and> q)`] THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP (SET_RULE
       `s = {a} \<and> t = {a} \<Longrightarrow> a \<in> s \<inter> t`)) THEN
      REWRITE_TAC[IN_INTER; IN_ELIM_THM; AND_FORALL_THM] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `Suc n`) THEN ASM_REWRITE_TAC[COND_SWAP] THEN
      SUBGOAL_THEN
       `(x:(num=>bool)->num=>A) b n = x c n \<and>
        (r:(num=>bool)->num=>real) b n = r c n`
       (CONJUNCTS_THEN SUBST1_TAC)
      THENL
       [UNDISCH_TAC `\<forall>m::num. m < n \<Longrightarrow> (b m \<longleftrightarrow> c m)` THEN
        SPEC_TAC(`n::num`,`p::num`) THEN
        INDUCT_TAC THEN ASM_SIMP_TAC[LT_SUC_LE; LE_REFL; LT_IMP_LE];
        COND_CASES_TAC THEN ASM_REWRITE_TAC[MCBALL_SUBMETRIC_EQ; IN_INTER] THEN
        ASM SET_TAC[]]];
    SUBGOAL_THEN
     `\<forall>X::A topology.
          locally_compact_space X \<and> Hausdorff_space X \<and>
          X derived_set_of topspace X = topspace X \<and> \<not> (topspace X = {})
          \<Longrightarrow> UNIV \<lesssim> topspace X`
    ASSUME_TAC THENL
     [REPEAT STRIP_TAC;
      MAP_EVERY X_GEN_TAC [`X::A topology`; `s::A=>bool`] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> SPEC `subtopology X (s::A=>bool)`) THEN
      SUBGOAL_THEN `(s::A=>bool) \<subseteq> topspace X` ASSUME_TAC THENL
       [ASM_MESON_TAC[DERIVED_SET_OF_SUBSET_TOPSPACE]; ALL_TAC] THEN
      ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; HAUSDORFF_SPACE_SUBTOPOLOGY;
                   DERIVED_SET_OF_SUBTOPOLOGY; SET_RULE `s \<inter> s = s`;
                   SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
      DISCH_THEN MATCH_MP_TAC THEN
      MATCH_MP_TAC LOCALLY_COMPACT_SPACE_CLOSED_SUBSET THEN
      ASM_REWRITE_TAC[CLOSED_IN_CONTAINS_DERIVED_SET; SUBSET_REFL]] THEN
    TRANS_TAC CARD_LE_TRANS `(:num=>bool)` THEN
    SIMP_TAC[CARD_EQ_REAL; CARD_EQ_IMP_LE] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC `z::A`) THEN
    FIRST_ASSUM(MP_TAC \<circ> SPEC `z::A` \<circ> REWRITE_RULE[locally_compact_space]) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`u::A=>bool`; `k::A=>bool`] THEN STRIP_TAC THEN
    SUBGOAL_THEN `\<not> (u::A=>bool = {})` ASSUME_TAC THENL
     [ASM SET_TAC[];
      REPEAT(FIRST_X_ASSUM(K ALL_TAC \<circ> check (free_in `z::A`) \<circ> concl))] THEN
    SUBGOAL_THEN
     `\<forall>c. closedin X c \<and> c \<subseteq> k \<and> \<not> (X interior_of c = {})
          \<Longrightarrow> \<exists>d e. closedin X d \<and> d \<subseteq> k \<and>
                    \<not> (X interior_of d = {}) \<and>
                    closedin X e \<and> e \<subseteq> k \<and>
                    \<not> (X interior_of e = {}) \<and>
                    disjnt d e \<and> d \<subseteq> c \<and> e \<subseteq> (c::A=>bool)`
    MP_TAC THENL
     [REPEAT STRIP_TAC THEN
      UNDISCH_TAC `\<not> (X interior_of c::A=>bool = {})` THEN
      ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC `z::A` THEN DISCH_TAC THEN
      SUBGOAL_THEN `(z::A) \<in> topspace X` ASSUME_TAC THENL
       [ASM_MESON_TAC[\<subseteq>; INTERIOR_OF_SUBSET_TOPSPACE]; ALL_TAC] THEN
      MP_TAC(ISPECL [`X::A topology`; `topspace X::A=>bool`]
            DERIVED_SET_OF_INFINITE_OPEN_IN) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> AP_TERM `\<lambda>s. (z::A) \<in> s`) THEN
      ASM_REWRITE_TAC[IN_ELIM_THM] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `X interior_of c::A=>bool`) THEN
      ASM_SIMP_TAC[OPEN_IN_INTERIOR_OF; INTERIOR_OF_SUBSET_TOPSPACE;
                   SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP (MESON[infinite; FINITE_SING; FINITE_SUBSET]
        `infinite s \<Longrightarrow> \<forall>a. \<not> (s \<subseteq> {a})`)) THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP (SET_RULE
       `(\<forall>a. \<not> (s \<subseteq> {a})) \<Longrightarrow> \<exists>a b. a \<in> s \<and> b \<in> s \<and> (a \<noteq> b)`)) THEN
      REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
      MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
      SUBGOAL_THEN `(x::A) \<in> topspace X \<and> y \<in> topspace X`
      STRIP_ASSUME_TAC THENL
       [ASM_MESON_TAC[\<subseteq>; INTERIOR_OF_SUBSET_TOPSPACE]; ALL_TAC] THEN
      FIRST_ASSUM(MP_TAC \<circ> SPECL [`x::A`; `y::A`] \<circ>
        REWRITE_RULE[Hausdorff_space]) THEN
      ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
      MAP_EVERY X_GEN_TAC [`v::A=>bool`; `w::A=>bool`] THEN STRIP_TAC THEN
      MP_TAC(ISPEC `X::A topology`
        LOCALLY_COMPACT_HAUSDORFF_IMP_REGULAR_SPACE) THEN
      ASM_REWRITE_TAC[GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN] THEN
      REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN DISCH_THEN(fun th ->
        MP_TAC(SPECL [`X interior_of c \<inter> w::A=>bool`; `y::A`] th) THEN
        MP_TAC(SPECL [`X interior_of c \<inter> v::A=>bool`; `x::A`] th)) THEN
      ASM_SIMP_TAC[IN_INTER; OPEN_IN_INTER; OPEN_IN_INTERIOR_OF] THEN
      REWRITE_TAC[LEFT_IMP_EXISTS_THM; SUBSET_INTER] THEN
      MAP_EVERY X_GEN_TAC [`m::A=>bool`; `d::A=>bool`] THEN STRIP_TAC THEN
      MAP_EVERY X_GEN_TAC [`n::A=>bool`; `e::A=>bool`] THEN STRIP_TAC THEN
      MAP_EVERY EXISTS_TAC [`d::A=>bool`; `e::A=>bool`] THEN
      ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[TAUT
       `p \<and> q \<and> r \<and> s \<and> t \<longleftrightarrow> (q \<and> s) \<and> p \<and> r \<and> t`] THEN
      CONJ_TAC THENL
       [CONJ_TAC THENL [EXISTS_TAC `x::A`; EXISTS_TAC `y::A`] THEN
        REWRITE_TAC[interior_of; IN_ELIM_THM] THEN ASM_MESON_TAC[];
        MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`] INTERIOR_OF_SUBSET) THEN
        ASM SET_TAC[]];
      ALL_TAC] THEN
    REWRITE_TAC[RIGHT_IMP_EXISTS_THM; SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`l:(A=>bool)->A=>bool`; `r:(A=>bool)->A=>bool`] THEN
    DISCH_TAC THEN
    SUBGOAL_THEN
     `\<forall>b. \<exists>d::num=>A->bool.
          d 0 = k \<and>
          (\<forall>n. d(Suc n) = (if b n then r else l) (d n))`
    MP_TAC THENL
     [GEN_TAC THEN
      W(ACCEPT_TAC \<circ> prove_recursive_functions_exist num_RECURSION \<circ>
          snd \<circ> dest_exists \<circ> snd);
      REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM; FORALL_AND_THM]] THEN
    X_GEN_TAC `d:(num=>bool)->num=>A->bool` THEN STRIP_TAC THEN
    SUBGOAL_THEN
     `\<forall>b n. closedin X (d b n) \<and> d b n \<subseteq> k \<and>
            \<not> (X interior_of ((d:(num=>bool)->num=>A->bool) b n) = {})`
    MP_TAC THENL
     [GEN_TAC THEN INDUCT_TAC THENL
       [ASM_SIMP_TAC[SUBSET_REFL; COMPACT_IN_IMP_CLOSED_IN] THEN
        FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
         `(u \<noteq> {}) \<Longrightarrow> u \<subseteq> i \<Longrightarrow> (i \<noteq> {})`)) THEN
        ASM_SIMP_TAC[INTERIOR_OF_MAXIMAL_EQ];
        ASM_REWRITE_TAC[] THEN COND_CASES_TAC THEN ASM_SIMP_TAC[]];
      REWRITE_TAC[FORALL_AND_THM] THEN STRIP_TAC] THEN
    SUBGOAL_THEN
     `\<forall>b. \<not> (\<Inter> {(d:(num=>bool)->num=>A->bool) b n | n \<in> UNIV} = {})`
    MP_TAC THENL
     [X_GEN_TAC `b::num=>bool` THEN MATCH_MP_TAC COMPACT_SPACE_IMP_NEST THEN
      EXISTS_TAC `subtopology X (k::A=>bool)` THEN
      ASM_SIMP_TAC[CLOSED_IN_SUBSET_TOPSPACE; COMPACT_SPACE_SUBTOPOLOGY] THEN
      CONJ_TAC THENL [ASM_MESON_TAC[INTERIOR_OF_EMPTY]; ALL_TAC] THEN
      MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
      REPEAT(CONJ_TAC THENL [SET_TAC[]; ALL_TAC]) THEN
      ASM_SIMP_TAC[] THEN GEN_TAC THEN COND_CASES_TAC THEN
      ASM_SIMP_TAC[];
      REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; SKOLEM_THM; LEFT_IMP_EXISTS_THM]] THEN
    X_GEN_TAC `x:(num=>bool)->A` THEN
    REWRITE_TAC[INTERS_GSPEC; IN_ELIM_THM; IN_UNIV] THEN DISCH_TAC THEN
    REWRITE_TAC[le_c; IN_UNIV] THEN EXISTS_TAC `x:(num=>bool)->A` THEN
    CONJ_TAC THENL [ASM_MESON_TAC[CLOSED_IN_SUBSET; \<subseteq>]; ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`b::num=>bool`; `c::num=>bool`] THEN
    GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
    REWRITE_TAC[FUN_EQ_THM; NOT_FORALL_THM] THEN
    GEN_REWRITE_TAC LAND_CONV [num_WOP] THEN
    REWRITE_TAC[LEFT_IMP_EXISTS_THM; TAUT `\<not> (p \<longleftrightarrow> q) \<longleftrightarrow> p \<longleftrightarrow> \<not> q`] THEN
    X_GEN_TAC `n::num` THEN REPEAT STRIP_TAC THEN
    SUBGOAL_THEN
     `disjnt ((d:(num=>bool)->num=>A->bool) b (Suc n)) (d c (Suc n))`
    MP_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    ASM_SIMP_TAC[COND_SWAP] THEN
    SUBGOAL_THEN `(d:(num=>bool)->num=>A->bool) b n = d c n` SUBST1_TAC THENL
     [ALL_TAC; ASM_MESON_TAC[DISJOINT_SYM]] THEN
    UNDISCH_TAC `\<forall>m::num. m < n \<Longrightarrow> (b m \<longleftrightarrow> c m)` THEN
    SPEC_TAC(`n::num`,`p::num`) THEN
    INDUCT_TAC THEN ASM_SIMP_TAC[LT_SUC_LE; LE_REFL; LT_IMP_LE]]);;


subsection\<open>Euclidean space and n-spheres, as subtopologies of infinite product R^N\<close>


let euclidean_space = new_definition
 `euclidean_space n = subtopology (product_topology UNIV (\<lambda>i. euclideanreal))
                         {x. \<forall>i. (i \<notin> 1..n) \<Longrightarrow> x i = 0}`;;

lemma topspace_euclidean_space:
   "topspace(euclidean_space n) = {x. \<forall>i. (i \<notin> 1..n) \<Longrightarrow> x i = 0}"
oops
  REWRITE_TAC[euclidean_space; TOPSPACE_SUBTOPOLOGY;
              TOPSPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[o_DEF; TOPSPACE_EUCLIDEANREAL; CARTESIAN_PRODUCT_UNIV] THEN
  REWRITE_TAC[INTER_UNIV]);;

lemma nonempty_euclidean_space:
   "\<not> (topspace(euclidean_space n) = {})"
oops
  GEN_TAC THEN REWRITE_TAC[TOPSPACE_EUCLIDEAN_SPACE] THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; IN_ELIM_THM] THEN
  EXISTS_TAC `(\<lambda>i. 0):num=>real` THEN REWRITE_TAC[]);;

lemma subset_euclidean_space:
   "topspace(euclidean_space m) \<subseteq> topspace(euclidean_space n) \<longleftrightarrow>
         m \<le> n"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SPACE; \<subseteq>; IN_ELIM_THM; IN_NUMSEG] THEN
  EQ_TAC THENL [ALL_TAC; MESON_TAC[LE_TRANS]] THEN
  GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
  REWRITE_TAC[NOT_LE] THEN DISCH_TAC THEN
  DISCH_THEN(MP_TAC \<circ> SPEC `(\<lambda>i. if i = m then 1 else 0):num=>real`) THEN
  REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
    ASM_ARITH_TAC;
    DISCH_THEN(MP_TAC \<circ> SPEC `m::num`) THEN
    REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN ASM_ARITH_TAC]);;

lemma closedin_euclidean_space:
   "closedin (product_topology UNIV (\<lambda>i. euclideanreal))
                 (topspace(euclidean_space n))"
oops
  GEN_TAC THEN
  SUBGOAL_THEN
   `topspace(euclidean_space n) =
    \<Inter> {{x. x \<in> topspace(product_topology UNIV (\<lambda>i. euclideanreal)) \<and>
                 x i \<in> {0}}
            | (i \<notin> 1..n)}`
  SUBST1_TAC THENL
   [REWRITE_TAC[TOPSPACE_EUCLIDEAN_SPACE; INTERS_GSPEC; IN_ELIM_THM] THEN
    REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; o_DEF] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; CARTESIAN_PRODUCT_UNIV] THEN
    SET_TAC[];
    MATCH_MP_TAC CLOSED_IN_INTERS THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
    REWRITE_TAC[SET_RULE `\<not> ({f x | P x} = {}) \<longleftrightarrow> \<exists>x. P x`; IN_NUMSEG] THEN
    REPEAT STRIP_TAC THENL [EXISTS_TAC `0` THEN ARITH_TAC; ALL_TAC] THEN
    MATCH_MP_TAC CLOSED_IN_CONTINUOUS_MAP_PREIMAGE THEN
    EXISTS_TAC `euclideanreal` THEN
    SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV] THEN
    REWRITE_TAC[GSYM REAL_CLOSED_IN; REAL_CLOSED_SING]]);;

lemma completely_metrizable_euclidean_space:
   "completely_metrizable_space(euclidean_space n)"
oops
  GEN_TAC THEN REWRITE_TAC[euclidean_space] THEN
  MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_CLOSED_IN THEN
  REWRITE_TAC[GSYM TOPSPACE_EUCLIDEAN_SPACE; CLOSED_IN_EUCLIDEAN_SPACE] THEN
  REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[COUNTABLE_SUBSET_NUM]);;

lemma metrizable_euclidean_space:
   "metrizable_space(euclidean_space n)"
oops
  SIMP_TAC[COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE;
           COMPLETELY_METRIZABLE_EUCLIDEAN_SPACE]);;

lemma continuous_map_componentwise_euclidean_space:
   "\<And>X (f::A=>num->real) n.
        continuous_map X (euclidean_space n)
                       (\<lambda>x i. if 1 \<le> i \<and> i \<le> n then f x i else 0) \<longleftrightarrow>
   \<forall>i. 1 \<le> i \<and> i \<le> n \<Longrightarrow> continuous_map X euclideanreal (\<lambda>x. f x i)"
oops
  REWRITE_TAC[euclidean_space; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM; IN_NUMSEG] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN
  EQ_TAC THEN MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `i::num` THEN
  ASM_CASES_TAC `1 \<le> i \<and> i \<le> n` THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST]);;

lemma continuous_map_euclidean_space_add:
   "\<And>f g::A=>num->real.
        continuous_map X (euclidean_space n) f \<and>
        continuous_map X (euclidean_space n) g
        \<Longrightarrow> continuous_map X (euclidean_space n) (\<lambda>x i. f x i + g x i)"
oops
  REWRITE_TAC[euclidean_space; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM; REAL_ADD_LID] THEN
  REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN
  SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; EXTENSIONAL_UNIV]);;

lemma continuous_map_euclidean_space_sub:
   "\<And>f g::A=>num->real.
        continuous_map X (euclidean_space n) f \<and>
        continuous_map X (euclidean_space n) g
        \<Longrightarrow> continuous_map X (euclidean_space n) (\<lambda>x i. f x i - g x i)"
oops
  REWRITE_TAC[euclidean_space; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM; REAL_SUB_RZERO] THEN
  REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN
  SIMP_TAC[CONTINUOUS_MAP_REAL_SUB; EXTENSIONAL_UNIV]);;

lemma homeomorphic_euclidean_space_product_topology:
   "euclidean_space n homeomorphic_space
       product_topology {1..n} (\<lambda>i. euclideanreal)"
oops
  GEN_TAC THEN REWRITE_TAC[homeomorphic_space; homeomorphic_maps] THEN
  EXISTS_TAC `\<lambda>f::num=>real. RESTRICTION {1..n} f` THEN
  EXISTS_TAC `\<lambda>(f::num=>real) i. if i \<in> 1..n then f i else 0` THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SPACE; TOPSPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[PiE; o_THM; TOPSPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[IN_ELIM_THM; EXTENSION; euclidean_space] THEN
  REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; RESTRICTION_IN_EXTENSIONAL] THEN
    SIMP_TAC[RESTRICTION; CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV];
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
    SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM] THEN
    REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_UNIV] THEN
    CONJ_TAC THENL [MESON_TAC[\<in>; EXTENSIONAL_UNIV; IN_UNIV]; ALL_TAC] THEN
    X_GEN_TAC `i::num` THEN ASM_CASES_TAC `i \<in> 1..n` THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION];
    REPEAT STRIP_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
    SIMP_TAC[RESTRICTION] THEN ASM_MESON_TAC[];
    REWRITE_TAC[EXTENSIONAL; FUN_EQ_THM; IN_UNIV; IN_ELIM_THM] THEN
    REWRITE_TAC[RESTRICTION] THEN MESON_TAC[]]);;

lemma contractible_euclidean_space:
   "contractible_space(euclidean_space n)"
oops
  GEN_TAC THEN
  MP_TAC(SPEC `n::num` HOMEOMORPHIC_EUCLIDEAN_SPACE_PRODUCT_TOPOLOGY) THEN
  DISCH_THEN(SUBST1_TAC \<circ> MATCH_MP HOMEOMORPHIC_SPACE_CONTRACTIBILITY) THEN
  REWRITE_TAC[CONTRACTIBLE_SPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[CONTRACTIBLE_SPACE_EUCLIDEANREAL]);;

lemma path_connected_euclidean_space:
   "path_connected_space(euclidean_space n)"
oops
  SIMP_TAC[CONTRACTIBLE_IMP_PATH_CONNECTED_SPACE;
           CONTRACTIBLE_EUCLIDEAN_SPACE]);;

lemma connected_euclidean_space:
   "connected_space(euclidean_space n)"
oops
  SIMP_TAC[PATH_CONNECTED_EUCLIDEAN_SPACE;
           PATH_CONNECTED_IMP_CONNECTED_SPACE]);;

lemma locally_compact_euclidean_space:
   "locally_compact_space(euclidean_space n)"
oops
  X_GEN_TAC `n::num` THEN
  MP_TAC(SPEC `n::num` HOMEOMORPHIC_EUCLIDEAN_SPACE_PRODUCT_TOPOLOGY) THEN
  DISCH_THEN(SUBST1_TAC \<circ> MATCH_MP HOMEOMORPHIC_LOCALLY_COMPACT_SPACE) THEN
  REWRITE_TAC[LOCALLY_COMPACT_SPACE_PRODUCT_TOPOLOGY] THEN
  DISJ2_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_SPACE_EUCLIDEANREAL] THEN
  SIMP_TAC[FINITE_NUMSEG; FINITE_RESTRICT]);;

lemma locally_path_connected_euclidean_space:
   "locally_path_connected_space(euclidean_space n)"
oops
  X_GEN_TAC `n::num` THEN
  MP_TAC(SPEC `n::num` HOMEOMORPHIC_EUCLIDEAN_SPACE_PRODUCT_TOPOLOGY) THEN
  DISCH_THEN(SUBST1_TAC \<circ>
    MATCH_MP HOMEOMORPHIC_LOCALLY_PATH_CONNECTED_SPACE) THEN
  REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE_PRODUCT_TOPOLOGY] THEN
  DISJ2_TAC THEN REWRITE_TAC[LOCALLY_PATH_CONNECTED_SPACE_EUCLIDEANREAL] THEN
  SIMP_TAC[FINITE_NUMSEG; FINITE_RESTRICT]);;

lemma locally_connected_euclidean_space:
   "locally_connected_space(euclidean_space n)"
oops
  SIMP_TAC[LOCALLY_PATH_CONNECTED_EUCLIDEAN_SPACE;
           LOCALLY_PATH_CONNECTED_IMP_LOCALLY_CONNECTED_SPACE]);;

lemma Hausdorff_euclidean_space:
   "Hausdorff_space (euclidean_space n)"
oops
  GEN_TAC THEN REWRITE_TAC[euclidean_space] THEN
  MATCH_MP_TAC HAUSDORFF_SPACE_SUBTOPOLOGY THEN
  REWRITE_TAC[HAUSDORFF_SPACE_PRODUCT_TOPOLOGY;
              HAUSDORFF_SPACE_EUCLIDEANREAL]);;

lemma compact_euclidean_space:
   "compact_space(euclidean_space n) \<longleftrightarrow> n = 0"
oops
  X_GEN_TAC `n::num` THEN
  MP_TAC(SPEC `n::num` HOMEOMORPHIC_EUCLIDEAN_SPACE_PRODUCT_TOPOLOGY) THEN
  DISCH_THEN(SUBST1_TAC \<circ> MATCH_MP HOMEOMORPHIC_COMPACT_SPACE) THEN
  REWRITE_TAC[COMPACT_SPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; CARTESIAN_PRODUCT_EQ_EMPTY] THEN
  REWRITE_TAC[NOT_COMPACT_SPACE_EUCLIDEANREAL] THEN
  REWRITE_TAC[o_DEF; TOPSPACE_EUCLIDEANREAL; UNIV_NOT_EMPTY] THEN
  REWRITE_TAC[GSYM NOT_EXISTS_THM; MEMBER_NOT_EMPTY] THEN
  REWRITE_TAC[NUMSEG_EMPTY] THEN ARITH_TAC);;

let nsphere = new_definition
 `nsphere n = subtopology (euclidean_space (Suc n))
                          { x | sum(1..n+1) (\<lambda>i. x i ^ 2) = 1 }`;;

lemma nsphere:
   "nsphere n = subtopology (product_topology UNIV (\<lambda>i. euclideanreal))
                               {x. sum(1..n+1) (\<lambda>i. x i ^ 2) = 1 \<and>
                                    \<forall>i. (i \<notin> 1..n+1) \<Longrightarrow> x i = 0}"
oops
  REWRITE_TAC[nsphere; euclidean_space; SUBTOPOLOGY_SUBTOPOLOGY] THEN
  GEN_TAC THEN AP_TERM_TAC THEN SET_TAC[]);;

lemma nonempty_nsphere:
   "\<not> (topspace(nsphere n) = {})"
oops
  GEN_TAC THEN REWRITE_TAC[nsphere; GSYM MEMBER_NOT_EMPTY] THEN
  EXISTS_TAC `(\<lambda>n. if n = 1 then 1 else 0):num=>real` THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEAN_SPACE] THEN
  REWRITE_TAC[IN_INTER; IN_ELIM_THM] THEN CONJ_TAC THENL
   [GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_NUMSEG] THEN ARITH_TAC;
    ONCE_REWRITE_TAC[COND_RAND] THEN ONCE_REWRITE_TAC[COND_RATOR] THEN
    CONV_TAC REAL_RAT_REDUCE_CONV THEN REWRITE_TAC[SUM_DELTA] THEN
    REWRITE_TAC[IN_NUMSEG; ARITH_RULE `1 \<le> 1 \<and> 1 \<le> n + 1`]]);;

lemma subtopology_nsphere_equator:
   "subtopology (nsphere (Suc n)) {x. x(n+2) = 0} = nsphere n"
oops
  GEN_TAC THEN
  REWRITE_TAC[NSPHERE; SUBTOPOLOGY_SUBTOPOLOGY] THEN AP_TERM_TAC THEN
  GEN_REWRITE_TAC id [EXTENSION] THEN X_GEN_TAC `x::num=>real` THEN
  REWRITE_TAC[IN_INTER; IN_ELIM_THM; GSYM CONJ_ASSOC] THEN
  REWRITE_TAC[ARITH_RULE `(Suc n) + 1 = Suc(Suc n)`; SUM_CLAUSES_NUMSEG] THEN
  REWRITE_TAC[ARITH_RULE `1 \<le> Suc n`; NUMSEG_CLAUSES] THEN
  REWRITE_TAC[ARITH_RULE `Suc(Suc n) = n + 2`; IN_INSERT; IN_NUMSEG] THEN
  ASM_CASES_TAC `(x::num=>real)(n + 2) = 0` THENL
   [ALL_TAC; ASM_MESON_TAC[ARITH_RULE `\<not> (n + 2 \<le> n + 1)`]] THEN
  ASM_REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
  REWRITE_TAC[REAL_ADD_RID] THEN ASM_MESON_TAC[]);;

lemma continuous_map_nsphere_reflection:
   "continuous_map (nsphere n,nsphere n)
                        (\<lambda>x i. if i = k then-x i else x i)"
oops
  REPEAT GEN_TAC THEN REWRITE_TAC[NSPHERE; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM] THEN CONJ_TAC THENL
   [X_GEN_TAC `i::num` THEN MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    ASM_CASES_TAC `i::num = k` THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_NEG; CONTINUOUS_MAP_PRODUCT_PROJECTION;
                 IN_UNIV];
    ONCE_REWRITE_TAC[COND_RAND] THEN ONCE_REWRITE_TAC[COND_RATOR] THEN
    REWRITE_TAC[REAL_NEG_EQ_0; REAL_ARITH `(-x::real) ^ 2 = x ^ 2`] THEN
    SIMP_TAC[COND_ID; TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM]]);;

lemma contractible_space_upper_hemisphere:
   "k \<in> 1..n+1
         \<Longrightarrow> contractible_space(subtopology (nsphere n) {x. x k >= 0})"
oops
  REPEAT STRIP_TAC THEN
  ABBREV_TAC `p::num=>real = \<lambda>i. if i = k then 1 else 0` THEN
  REWRITE_TAC[contractible_space] THEN EXISTS_TAC `p::num=>real` THEN
  SUBGOAL_THEN `p \<in> topspace(nsphere n)` ASSUME_TAC THENL
   [EXPAND_TAC "p" THEN REWRITE_TAC[NSPHERE; TOPSPACE_SUBTOPOLOGY] THEN
    REWRITE_TAC[IN_INTER; TOPSPACE_PRODUCT_TOPOLOGY; IN_ELIM_THM; o_DEF] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; CARTESIAN_PRODUCT_UNIV; IN_UNIV] THEN
    CONJ_TAC THENL [ALL_TAC; ASM_MESON_TAC[]] THEN
    REWRITE_TAC[COND_RAND; COND_RATOR] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
    ASM_REWRITE_TAC[SUM_DELTA];
    ALL_TAC] THEN
  SIMP_TAC[HOMOTOPIC_WITH] THEN
  EXISTS_TAC `(\<lambda>x i. x i / sqrt(sum(1..n+1) (\<lambda>j. x j ^ 2))) \<circ>
              (\<lambda>(t,q) i. (1 - t) * q i + t * p i)` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE;
    UNDISCH_TAC `p \<in> topspace(nsphere n)` THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; NSPHERE; o_THM] THEN
    REWRITE_TAC[REAL_SUB_REFL; REAL_MUL_LID; REAL_MUL_LZERO; REAL_SUB_RZERO;
                REAL_ADD_LID; REAL_ADD_RID; IN_INTER; IN_ELIM_THM] THEN
    SIMP_TAC[SQRT_1; REAL_DIV_1; ETA_AX]] THEN
  EXISTS_TAC `subtopology (euclidean_space (Suc n))
               {x. x k >= 0 \<and> \<not> (\<forall>i. i \<in> 1..n+1 \<Longrightarrow> x i = 0)}` THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; euclidean_space] THEN
  REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN REPEAT CONJ_TAC THENL
   [X_GEN_TAC `i::num` THEN REWRITE_TAC[LAMBDA_PAIR] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_ADD THEN CONJ_TAC THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_MUL THEN
    REWRITE_TAC[CONTINUOUS_MAP_OF_FST; CONTINUOUS_MAP_OF_SND] THEN
    SIMP_TAC[GSYM SUBTOPOLOGY_CROSS; CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_FST] THEN
    REPEAT CONJ_TAC THEN DISJ2_TAC THEN
    MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    SIMP_TAC[CONTINUOUS_MAP_REAL_SUB; CONTINUOUS_MAP_REAL_CONST;
             CONTINUOUS_MAP_ID] THEN
    REWRITE_TAC[NSPHERE] THEN MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY THEN
    SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY; NSPHERE;
                FORALL_PAIR_THM; TOPSPACE_PROD_TOPOLOGY; IN_CROSS;
                IN_INTER; IN_ELIM_THM] THEN
    EXPAND_TAC "p" THEN SIMP_TAC[REAL_MUL_RZERO; REAL_ADD_LID; REAL_ENTIRE] THEN
    ASM_MESON_TAC[];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_PROD_TOPOLOGY] THEN
    REWRITE_TAC[FORALL_PAIR_THM; IN_CROSS; TOPSPACE_SUBTOPOLOGY] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL; IN_INTER; IN_UNIV] THEN
    MAP_EVERY X_GEN_TAC [`t::real`; `x::num=>real`] THEN
    REWRITE_TAC[IN_REAL_INTERVAL; IN_ELIM_THM] THEN STRIP_TAC THEN
    REWRITE_TAC[real_ge] THEN CONJ_TAC THENL
     [EXPAND_TAC "p" THEN REWRITE_TAC[REAL_MUL_RID] THEN
      MATCH_MP_TAC REAL_LE_ADD THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC REAL_LE_MUL THEN ASM_REAL_ARITH_TAC;
      ASM_CASES_TAC `t = 0` THENL
       [ASM_REWRITE_TAC[REAL_SUB_RZERO; REAL_MUL_LID; REAL_MUL_LZERO] THEN
        REWRITE_TAC[REAL_ADD_RID] THEN DISCH_TAC THEN
        UNDISCH_TAC `x \<in> topspace(nsphere n)` THEN
        ASM_SIMP_TAC[NSPHERE; TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM] THEN
        CONV_TAC REAL_RAT_REDUCE_CONV THEN REWRITE_TAC[SUM_0] THEN
        CONV_TAC REAL_RAT_REDUCE_CONV;
        DISCH_THEN(MP_TAC \<circ> SPEC `k::num`) THEN ASM_REWRITE_TAC[] THEN
        EXPAND_TAC "p" THEN REWRITE_TAC[] THEN MATCH_MP_TAC(REAL_ARITH
          `0 \<le> x \<and> 0 \<le> t \<and> (t \<noteq> 0) \<Longrightarrow> \<not> (x + t * 1 = 0)`) THEN
        ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_MUL THEN
        ASM_REAL_ARITH_TAC]];
      ALL_TAC;
      REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY] THEN
      REWRITE_TAC[IN_INTER; IN_ELIM_THM; real_ge] THEN
      REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_DIV THEN
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC SQRT_POS_LE THEN
      MATCH_MP_TAC SUM_POS_LE_NUMSEG THEN
      REWRITE_TAC[REAL_LE_POW_2]] THEN
  REWRITE_TAC[NSPHERE; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN CONJ_TAC THENL
   [REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN
    X_GEN_TAC `i::num` THEN MATCH_MP_TAC CONTINUOUS_MAP_REAL_DIV THEN
    SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV] THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC CONTINUOUS_MAP_SQRT THEN
      MATCH_MP_TAC CONTINUOUS_MAP_SUM THEN
      REWRITE_TAC[FINITE_NUMSEG; IN_NUMSEG] THEN
      REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_MAP_REAL_POW THEN
      REPEAT(MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY) THEN
      SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV];
      REWRITE_TAC[SQRT_EQ_0; TOPSPACE_SUBTOPOLOGY; IN_INTER; IN_ELIM_THM]];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY] THEN
    SIMP_TAC[IN_INTER; IN_ELIM_THM; real_ge; IN_NUMSEG] THEN
    REWRITE_TAC[real_div; REAL_MUL_LZERO; REAL_POW_MUL; SUM_RMUL] THEN
    REWRITE_TAC[REAL_POW_INV; GSYM real_div] THEN
    SIMP_TAC[SQRT_POW_2; SUM_POS_LE_NUMSEG; REAL_LE_POW_2] THEN
    REWRITE_TAC[REAL_DIV_EQ_1]] THEN
  REWRITE_TAC[IMP_CONJ; CONTRAPOS_THM] THEN
  GEN_TAC THEN REPLICATE_TAC 3 DISCH_TAC THEN REWRITE_TAC[IN_NUMSEG] THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ_ALT]
    SUM_POS_EQ_0_NUMSEG)) THEN
  SIMP_TAC[REAL_POW_EQ_0; REAL_LE_POW_2; ARITH]);;

lemma contractible_space_lower_hemisphere:
   "k \<in> 1..n+1
         \<Longrightarrow> contractible_space(subtopology (nsphere n) {x. x k \<le> 0})"
oops
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC \<circ> MATCH_MP CONTRACTIBLE_SPACE_UPPER_HEMISPHERE) THEN
  MATCH_MP_TAC EQ_IMP THEN MATCH_MP_TAC HOMEOMORPHIC_SPACE_CONTRACTIBILITY THEN
  REWRITE_TAC[homeomorphic_space] THEN
  REPEAT(EXISTS_TAC `\<lambda>(x::num=>real) i. if i = k then --(x i) else x i`) THEN
  REWRITE_TAC[homeomorphic_maps; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  SIMP_TAC[CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
           CONTINUOUS_MAP_NSPHERE_REFLECTION] THEN
  REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_ELIM_THM; REAL_NEG_NEG;
              TOPSPACE_SUBTOPOLOGY; IN_INTER] THEN
  REWRITE_TAC[FUN_EQ_THM] THEN REPEAT STRIP_TAC THEN
  TRY COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ASM_REAL_ARITH_TAC);;

lemma nullhomotopic_nonsurjective_sphere_map:
   "continuous_map(nsphere p,nsphere p) f \<and>
         \<not> (image f (topspace(nsphere p)) = topspace(nsphere p))
         \<Longrightarrow> \<exists>a. homotopic_with (\<lambda>x. True) (nsphere p,nsphere p) f (\<lambda>x. a)"
oops
  SIMP_TAC[IMP_CONJ; CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE; SET_RULE
            `s \<subseteq> t \<Longrightarrow> ((s \<noteq> t) \<longleftrightarrow> \<exists>a. a \<in> t \<and> (a \<notin> s))`] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN `a::num=>real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `(\<lambda>i. --(a i)):num=>real` THEN SIMP_TAC[HOMOTOPIC_WITH] THEN
  EXISTS_TAC
   `(\<lambda>x i. x i / sqrt(sum(1..p+1) (\<lambda>j. x j ^ 2))) \<circ>
    (\<lambda>(t,x) i. (1 - t) * f(x::num=>real) i - t * a i)` THEN
  REWRITE_TAC[o_THM; REAL_ARITH
   `(1 - 1) * x - 1 * a =-a \<and> (1 - 0) * x - 0 * a = x`] THEN
  MP_TAC(ASSUME `a \<in> topspace(nsphere p)`) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
  REWRITE_TAC[NSPHERE; TOPSPACE_SUBTOPOLOGY; \<subseteq>] THEN
  REWRITE_TAC[GSYM NSPHERE; IN_ELIM_THM; IN_INTER; FORALL_IN_IMAGE] THEN
  SIMP_TAC[REAL_ARITH `(-x::real) ^ 2 = x ^ 2`] THEN
  DISCH_THEN(K ALL_TAC) THEN DISCH_THEN(STRIP_ASSUME_TAC \<circ> CONJUNCT2) THEN
  REWRITE_TAC[SQRT_1; REAL_DIV_1; ETA_AX] THEN
  MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
  EXISTS_TAC `subtopology (euclidean_space(Suc p)) (UNIV DELETE (\<lambda>i. 0))` THEN
  REWRITE_TAC[euclidean_space; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE_UNIV] THEN REPEAT CONJ_TAC THENL
   [X_GEN_TAC `i::num` THEN REWRITE_TAC[LAMBDA_PAIR] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN CONJ_TAC THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_MUL THEN
    REWRITE_TAC[CONTINUOUS_MAP_OF_FST; CONTINUOUS_MAP_OF_SND] THEN
    SIMP_TAC[GSYM SUBTOPOLOGY_CROSS; nsphere; CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_FST] THEN
    REPEAT CONJ_TAC THEN DISJ2_TAC THEN
    SIMP_TAC[CONTINUOUS_MAP_REAL_SUB; CONTINUOUS_MAP_REAL_CONST;
             CONTINUOUS_MAP_ID; CONTINUOUS_MAP_FROM_SUBTOPOLOGY] THEN
    REWRITE_TAC[GSYM nsphere] THEN
    SUBGOAL_THEN `(\<lambda>x::num=>real. f x i) = (\<lambda>y::num=>real. y i) \<circ> f`
    SUBST1_TAC THENL [REWRITE_TAC[o_DEF]; ALL_TAC] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC `nsphere p` THEN ASM_REWRITE_TAC[] THEN
    SIMP_TAC[NSPHERE; CONTINUOUS_MAP_FROM_SUBTOPOLOGY;
             CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV];
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
    GEN_REWRITE_TAC (LAND_CONV \<circ> RAND_CONV \<circ> RAND_CONV) [NSPHERE] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY;
                FORALL_PAIR_THM; IN_CROSS; TOPSPACE_PROD_TOPOLOGY] THEN
    ASM_SIMP_TAC[IN_ELIM_THM; IN_INTER] THEN
    REPEAT STRIP_TAC THEN REAL_ARITH_TAC;
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; FORALL_PAIR_THM] THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; IN_CROSS] THEN
    MAP_EVERY X_GEN_TAC [`t::real`; `b::num=>real`] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
    REWRITE_TAC[IN_UNIV; IN_REAL_INTERVAL; IN_DELETE] THEN
    STRIP_TAC THEN REWRITE_TAC[FUN_EQ_THM; REAL_SUB_0] THEN
    GEN_REWRITE_TAC RAND_CONV [GSYM FUN_EQ_THM] THEN
    MATCH_MP_TAC(MESON[]
     `(a = b \<Longrightarrow> t = 1 / 2) \<and> (t = 1 / 2 \<Longrightarrow> (a \<noteq> b))
      \<Longrightarrow> (a \<noteq> b)`) THEN
    CONJ_TAC THENL
     [DISCH_THEN(MP_TAC \<circ> AP_TERM `\<lambda>x. sum(1..p+1) (\<lambda>i. x i ^ 2)`) THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
      GEN_REWRITE_TAC (LAND_CONV \<circ> RAND_CONV \<circ> RAND_CONV) [NSPHERE] THEN
      REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY;
                  FORALL_PAIR_THM; IN_CROSS; TOPSPACE_PROD_TOPOLOGY] THEN
      ASM_SIMP_TAC[IN_ELIM_THM; IN_INTER; REAL_POW_MUL; SUM_LMUL] THEN
      DISCH_TAC THEN CONV_TAC REAL_RING;
      DISCH_THEN SUBST1_TAC THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
      REWRITE_TAC[FUN_EQ_THM; REAL_ARITH
       `1 / 2 * x = 1 / 2 * y \<longleftrightarrow> x = y`] THEN
      GEN_REWRITE_TAC RAND_CONV [GSYM FUN_EQ_THM] THEN
      REWRITE_TAC[ETA_AX] THEN ASM SET_TAC[]];
    REWRITE_TAC[NSPHERE; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
    CONJ_TAC THENL
     [REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE; IN_UNIV] THEN
      REWRITE_TAC[EXTENSIONAL_UNIV; \<in>; \<subseteq>] THEN
      X_GEN_TAC `k::num` THEN MATCH_MP_TAC CONTINUOUS_MAP_REAL_DIV THEN
      REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
       [CONJ_TAC THEN REPEAT(MATCH_MP_TAC CONTINUOUS_MAP_FROM_SUBTOPOLOGY) THEN
        SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION; IN_UNIV] THEN
        MATCH_MP_TAC CONTINUOUS_MAP_SQRT THEN
        MATCH_MP_TAC CONTINUOUS_MAP_SUM THEN
        SIMP_TAC[CONTINUOUS_MAP_REAL_POW; CONTINUOUS_MAP_PRODUCT_PROJECTION;
                 IN_UNIV; FINITE_NUMSEG];
        ALL_TAC];
      ALL_TAC] THEN
    SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; TOPSPACE_SUBTOPOLOGY; IN_INTER;
             IN_ELIM_THM; IN_DELETE; IN_UNIV; real_div; REAL_POW_MUL;
             REAL_MUL_LZERO; SUM_RMUL; REAL_POW_INV; SQRT_POW_2;
             SUM_POS_LE_NUMSEG; REAL_LE_POW_2; SQRT_EQ_0] THEN
    X_GEN_TAC `x::num=>real` THEN STRIP_TAC THEN
    REWRITE_TAC[GSYM real_div ] THEN TRY(MATCH_MP_TAC REAL_DIV_REFL) THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ_ALT]
        SUM_POS_EQ_0_NUMSEG)) THEN
    REWRITE_TAC[REAL_LE_POW_2; GSYM IN_NUMSEG; REAL_POW_EQ_0] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV [FUN_EQ_THM]) THEN
    ASM_MESON_TAC[\<in>]]);;


subsection\<open>Contractions\<close>


lemma contraction_imp_unique_fixpoint:
   "\<And>m (f::A=>A) k x y.
     k < 1 \<and>
     (\<forall>x. x \<in> M \<Longrightarrow> f x \<in> M) \<and>
     (\<forall>x y. x \<in> M \<and> y \<in> M
            \<Longrightarrow> d (f x) f y \<le> k * d x y) \<and>
     x \<in> M \<and> y \<in> M \<and> f x = x \<and> f y = y
     \<Longrightarrow> x = y"
oops
  INTRO_TAC "!m f k x y; k f le x y xeq yeq" THEN
  ASM_CASES_TAC `x::A = y` THENL [POP_ASSUM ACCEPT_TAC; ALL_TAC] THEN
  REMOVE_THEN "le" (MP_TAC \<circ> SPECL[`x::A`;`y::A`]) THEN ASM_REWRITE_TAC[] THEN
  CUT_TAC `0 < (1 - k) * d x::A y::A` THENL
  [REAL_ARITH_TAC;
   MATCH_MP_TAC REAL_LT_MUL THEN ASM_SIMP_TAC[MDIST_POS_LT] THEN
   ASM_REAL_ARITH_TAC]);;


(* Banach Fixed-Point Theorem (aka, Contraction Mapping Principle).          *)


lemma banach_fixpoint_thm:
   "\<And>m f::A=>A k.
     \<not> (M = {}) \<and>
     mcomplete \<and>
     (\<forall>x. x \<in> M \<Longrightarrow> f x \<in> M) \<and>
     k < 1 \<and>
     (\<forall>x y. x \<in> M \<and> y \<in> M
            \<Longrightarrow> d (f x) f y \<le> k * d x y)
     \<Longrightarrow> (?\<forall>x. x \<in> M \<and> f x = x)"
oops
  INTRO_TAC "!m f k; ne compl 4 k1 contr" THEN REMOVE_THEN "ne" MP_TAC THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN INTRO_TAC "@a. aINm" THEN
  REWRITE_TAC[EXISTS_UNIQUE_THM] THEN CONJ_TAC THENL
  [ALL_TAC;
   REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTRACTION_IMP_UNIQUE_FIXPOINT THEN
   ASM_MESON_TAC[]] THEN
  ASM_CASES_TAC `\<forall>x::A. x \<in> M \<Longrightarrow> f x::A = f a` THENL
  [ASM_MESON_TAC[]; POP_ASSUM (LABEL_TAC "nonsing")] THEN
  CLAIM_TAC "kpos" `0 < k` THENL
  [MATCH_MP_TAC (ISPECL [`m::A metric`; `m::A metric`; `f::A=>A`]
     LIPSCHITZ_COEFFICIENT_POS) THEN
   ASM_SIMP_TAC[] THEN ASM_MESON_TAC[];
   ALL_TAC] THEN
  CLAIM_TAC "fINm" `\<forall>n::num. (ITER n f (a::A)) \<in> M` THENL
  [LABEL_INDUCT_TAC THEN ASM_SIMP_TAC[ITER]; ALL_TAC] THEN
  ASM_CASES_TAC `f a = a::A` THENL
  [ASM_MESON_TAC[]; POP_ASSUM (LABEL_TAC "aneq")] THEN
  CUT_TAC `MCauchy (m::A metric) (\<lambda>n. ITER n f (a::A))` THENL
  [DISCH_THEN (fun cauchy -> HYP_TAC "compl : @l. lim"
    (C MATCH_MP cauchy \<circ> REWRITE_RULE[mcomplete])) THEN
   EXISTS_TAC `l::A` THEN CONJ_TAC THENL
   [ASM_MESON_TAC [LIMIT_IN_MSPACE]; ALL_TAC] THEN
   MATCH_MP_TAC
     (ISPECL [`sequentially`; `m::A metric`; `(\<lambda>n. ITER n f a::A)`]
             LIMIT_METRIC_UNIQUE) THEN
   ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN
   MATCH_MP_TAC LIMIT_SEQUENTIALLY_OFFSET_REV THEN
   EXISTS_TAC `1` THEN REWRITE_TAC[GSYM ADD1] THEN
   SUBGOAL_THEN `(\<lambda>i. ITER (Suc i) f (a::A)) = f \<circ> (\<lambda>i. ITER i f a)`
     SUBST1_TAC THENL [REWRITE_TAC[FUN_EQ_THM; o_THM; ITER]; ALL_TAC] THEN
   MATCH_MP_TAC CONTINUOUS_MAP_LIMIT THEN
   EXISTS_TAC `mtopology (m::A metric)` THEN ASM_REWRITE_TAC[] THEN
   MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_IMP_CONTINUOUS_MAP THEN
   ASM_REWRITE_TAC[lipschitz_continuous_map; \<subseteq>; FORALL_IN_IMAGE] THEN
   EXISTS_TAC `k::real` THEN ASM_REWRITE_TAC[];
   ALL_TAC] THEN
  CLAIM_TAC "k1'" `0 < 1 - k` THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
  ASM_SIMP_TAC[MCauchy] THEN INTRO_TAC "!e; e" THEN
  CLAIM_TAC "@N. N" `\<exists>N. k ^ N < ((1 - k) * e) / d a::A f a` THENL
  [MATCH_MP_TAC REAL_ARCH_POW_INV THEN
   ASM_SIMP_TAC[REAL_LT_DIV; MDIST_POS_LT; REAL_LT_MUL];
   EXISTS_TAC `N::num`] THEN
  MATCH_MP_TAC WLOG_LT THEN ASM_SIMP_TAC[MDIST_REFL] THEN CONJ_TAC THENL
  [HYP MESON_TAC "fINm" [MDIST_SYM]; ALL_TAC] THEN
  INTRO_TAC "!n n'; lt; le le'" THEN
  TRANS_TAC REAL_LET_TRANS
    `sum (n..n'-1) (\<lambda>i. d m (ITER i f a::A, ITER (Suc i) f a))` THEN
  CONJ_TAC THENL
  [REMOVE_THEN "lt" MP_TAC THEN SPEC_TAC (`n':num`,`n':num`) THEN
   LABEL_INDUCT_TAC THENL [REWRITE_TAC[LT]; REWRITE_TAC[LT_SUC_LE]] THEN
   INTRO_TAC "nle" THEN HYP_TAC "nle : nlt | neq" (REWRITE_RULE[LE_LT]) THENL
   [ALL_TAC;
    POP_ASSUM SUBST_ALL_TAC THEN
    REWRITE_TAC[ITER;
      ARITH_RULE `Suc n'' - 1 = n''`; SUM_SING_NUMSEG; REAL_LE_REFL]] THEN
   USE_THEN "nlt" (HYP_TAC "ind_n'" \<circ> C MATCH_MP) THEN REWRITE_TAC[ITER] THEN
   TRANS_TAC REAL_LE_TRANS
     `d ITER n f a::A ITER n'' f a +
      d m (ITER n'' f a,f (ITER n'' f a))` THEN
   ASM_SIMP_TAC[MDIST_TRIANGLE] THEN
   SUBGOAL_THEN `Suc n'' - 1 = Suc (n'' - 1)` SUBST1_TAC THENL
   [ASM_ARITH_TAC; ASM_SIMP_TAC[SUM_CLAUSES_NUMSEG]] THEN
   SUBGOAL_THEN `Suc (n'' - 1) = n''` SUBST1_TAC THENL
   [ASM_ARITH_TAC; ASM_SIMP_TAC[LT_IMP_LE; REAL_LE_RADD]] THEN
   REMOVE_THEN "ind_n'" (ACCEPT_TAC \<circ> REWRITE_RULE[ITER]);
   ALL_TAC] THEN
  TRANS_TAC REAL_LET_TRANS
     `sum (n..n'-1) (\<lambda>i. d a::A f a * k ^ i)` THEN CONJ_TAC THENL
  [MATCH_MP_TAC SUM_LE_NUMSEG THEN
   CUT_TAC `\<forall>i. d m (ITER i f a,ITER (Suc i) f a) \<le>
                d a::A f a * k ^ i` THENL
   [SIMP_TAC[ITER]; ALL_TAC] THEN
   LABEL_INDUCT_TAC THENL
   [REWRITE_TAC[ITER; real_pow; REAL_MUL_RID; REAL_LE_REFL];
    HYP_TAC "ind_i" (REWRITE_RULE[ITER]) THEN
    TRANS_TAC REAL_LE_TRANS `k * d m (ITER i f a::A, f (ITER i f a))` THEN
    ASM_SIMP_TAC[real_pow; REAL_LE_LMUL_EQ; ITER;
      REAL_ARITH `\<forall>x. x * k * k ^ i = k * x * k ^ i`]];
   ALL_TAC] THEN
  REWRITE_TAC[SUM_LMUL; SUM_GP] THEN
  HYP SIMP_TAC "lt" [ARITH_RULE `n < n' \<Longrightarrow> \<not> (n' - 1 < n)`] THEN
  HYP SIMP_TAC "k1" [REAL_ARITH `k < 1 \<Longrightarrow> (k \<noteq> 1)`] THEN
  USE_THEN "lt" (SUBST1_TAC \<circ>
    MATCH_MP (ARITH_RULE `n < n' \<Longrightarrow> Suc (n' - 1) = n'`)) THEN
  SUBGOAL_THEN `k ^ n - k ^ n' = k ^ n * (1 - k ^ (n' - n))`
    SUBST1_TAC THENL
  [REWRITE_TAC[REAL_SUB_LDISTRIB; REAL_MUL_RID; GSYM REAL_POW_ADD] THEN
   HYP SIMP_TAC "lt" [ARITH_RULE `n < n' \<Longrightarrow> n + n' - n = n':num`];
   (SUBST1_TAC \<circ> REAL_ARITH)
     `d a::A f a * (k ^ n * (1 - k ^ (n' - n))) / (1 - k) =
      ((k ^ n * (1 - k ^ (n' - n))) / (1 - k)) * d a f a`] THEN
  ASM_SIMP_TAC[GSYM REAL_LT_RDIV_EQ; MDIST_POS_LT; REAL_LT_LDIV_EQ] THEN
  TRANS_TAC REAL_LET_TRANS `k ^ n` THEN CONJ_TAC THENL
  [ONCE_REWRITE_TAC[GSYM REAL_SUB_LE] THEN
   REWRITE_TAC[GSYM REAL_POW_ADD;
     REAL_ARITH `k ^ n - k ^ n * (1 - k ^ (n' - n)) =
                 k ^ n * k ^ (n' - n)`] THEN
   HYP SIMP_TAC "lt" [ARITH_RULE `n < n' \<Longrightarrow> n + n' - n = n':num`] THEN
   HYP SIMP_TAC "kpos" [REAL_POW_LE; REAL_LT_IMP_LE];
   TRANS_TAC REAL_LET_TRANS `k ^ N` THEN
   ASM_SIMP_TAC[REAL_POW_MONO_INV; REAL_LT_IMP_LE;
     REAL_ARITH `e / d a::A f a * (1 - k) =
                 ((1 - k) * e) / d a f a`]]);;


subsection\<open>Metric space of bounded functions\<close>


let funspace = new_definition
  `funspace s m =
   metric ({f::A=>B | (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> M) \<and>
                     f \<in> EXTENSIONAL s \<and>
                     mbounded (f ` s)},
           (\<lambda>(f,g). if s = {} then 0 else
                    sup {d (f x) g x | x | x \<in> s}))`;;

let FUNSPACE = (REWRITE_RULE[GSYM FORALL_AND_THM] \<circ> prove)
   "     mspace (funspace s m) =
       {f::A=>B | (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> M) \<and>
                 f \<in> EXTENSIONAL s \<and>
                 mbounded (f ` s)} \<and>
     (\<forall>f g. d (funspace s m) (f,g) =
              if s = {} then 0 else
              sup {d (f x) g x | x | x \<in> s})"
oops
  REPEAT GEN_TAC THEN MAP_EVERY LABEL_ABBREV_TAC
    [`fspace = {f::A=>B | (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> M) \<and>
                         f \<in> EXTENSIONAL s \<and>
                         mbounded (f ` s)}`;
     `fdist =
        \<lambda>(f,g). if s = {} then 0 else
                sup {d (f x)::B g x | x | x::A \<in> s}`] THEN
  CUT_TAC `mspace (funspace s m) = fspace:(A=>B)->bool \<and>
           d (funspace s m:(A=>B)metric) = fdist` THENL
  [EXPAND_TAC "fdist" THEN DISCH_THEN (fun th -> REWRITE_TAC[th]);
   ASM_REWRITE_TAC[funspace] THEN MATCH_MP_TAC METRIC] THEN
  ASM_CASES_TAC `s::A=>bool = {}` THENL
  [POP_ASSUM SUBST_ALL_TAC THEN MAP_EVERY EXPAND_TAC ["fspace"; "fdist"] THEN
   SIMP_TAC[is_metric_space; NOT_IN_EMPTY; IN_EXTENSIONAL; IMAGE_CLAUSES;
     MBOUNDED_EMPTY; IN_ELIM_THM; REAL_LE_REFL; REAL_ADD_LID; FUN_EQ_THM];
   POP_ASSUM (LABEL_TAC "nempty")] THEN
  REMOVE_THEN "nempty" (fun th ->
    RULE_ASSUM_TAC(REWRITE_RULE[th]) THEN LABEL_TAC "nempty" th) THEN
  CLAIM_TAC "wd ext bound"
    `(\<forall>f x::A. f \<in> fspace \<and> x \<in> s \<Longrightarrow> f x::B \<in> M) \<and>
     (\<forall>f. f \<in> fspace \<Longrightarrow> f \<in> EXTENSIONAL s) \<and>
     (\<forall>f. f \<in> fspace
          \<Longrightarrow> (\<exists>c b. c \<in> M \<and>
                     (\<forall>x. x \<in> s \<Longrightarrow> d c f x \<le> b)))` THENL
  [EXPAND_TAC "fspace" THEN
   ASM_SIMP_TAC[IN_ELIM_THM; MBOUNDED; IMAGE_EQ_EMPTY] THEN SET_TAC[];
   ALL_TAC] THEN
  CLAIM_TAC "bound2"
    `\<forall>f g::A=>B. f \<in> fspace \<and> g \<in> fspace
                \<Longrightarrow> (\<exists>b. \<forall>x. x \<in> s \<Longrightarrow> d (f x) g x \<le> b)` THENL
  [REMOVE_THEN "fspace" (SUBST_ALL_TAC \<circ> GSYM) THEN
   REWRITE_TAC[IN_ELIM_THM] THEN REPEAT STRIP_TAC THEN
   CUT_TAC `mbounded (image f s \<union> g ` s)` THENL
   [REWRITE_TAC[MBOUNDED_ALT; \<subseteq>; IN_UNION] THEN
    STRIP_TAC THEN EXISTS_TAC `b::real` THEN ASM SET_TAC [];
    ASM_REWRITE_TAC[MBOUNDED_UNION]];
   ALL_TAC] THEN
  HYP_TAC "nempty -> @a. a" (REWRITE_RULE[GSYM MEMBER_NOT_EMPTY]) THEN
  REWRITE_TAC[is_metric_space] THEN CONJ_TAC THENL
  [INTRO_TAC "![f] [g]; f  g" THEN EXPAND_TAC "fdist" THEN
   REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_SUP THEN
   CLAIM_TAC "@b. b" `\<exists>b. \<forall>x::A. x \<in> s \<Longrightarrow> d (f x)::B g x \<le> b` THENL
   [HYP SIMP_TAC "bound2 f g" [];
    ALL_TAC] THEN
    MAP_EVERY EXISTS_TAC [`b::real`; `d m (f(a::A):B,g a)`] THEN
    REWRITE_TAC[IN_ELIM_THM] THEN HYP SIMP_TAC "wd f g a" [MDIST_POS_LE] THEN
    HYP MESON_TAC "a b" [];
    ALL_TAC] THEN
  CONJ_TAC THENL
  [INTRO_TAC "![f] [g]; f  g" THEN EXPAND_TAC "fdist" THEN
   REWRITE_TAC[] THEN EQ_TAC THENL
   [INTRO_TAC "sup0" THEN MATCH_MP_TAC (SPEC `s::A=>bool` EXTENSIONAL_EQ) THEN
    HYP SIMP_TAC "f g ext" [] THEN INTRO_TAC "!x; x" THEN
    REFUTE_THEN (LABEL_TAC "neq") THEN
    CUT_TAC
      `0 < d m (f (x::A):B, g x) \<and>
       d (f x) g x \<le> sup {d (f x) g x | x \<in> s}` THENL
    [HYP REWRITE_TAC "sup0" [] THEN REAL_ARITH_TAC; ALL_TAC] THEN
    HYP SIMP_TAC "wd f g x neq" [MDIST_POS_LT] THEN
    MATCH_MP_TAC REAL_LE_SUP THEN
    CLAIM_TAC "@B. B" `\<exists>b. \<forall>x::A. x \<in> s \<Longrightarrow> d (f x)::B g x \<le> b` THENL
    [HYP SIMP_TAC "bound2 f g" []; ALL_TAC] THEN
    MAP_EVERY EXISTS_TAC [`B::real`; `d m (f (x::A):B,g x)`] THEN
    REWRITE_TAC[IN_ELIM_THM; IN_UNIV; REAL_LE_REFL] THEN
    HYP MESON_TAC "B x" [];
    DISCH_THEN (SUBST1_TAC \<circ> GSYM) THEN
    SUBGOAL_THEN `{d (f x)::B f x | x::A \<in> s} = {0}`
      (fun th -> REWRITE_TAC[th; SUP_SING]) THEN
    REWRITE_TAC[EXTENSION; IN_ELIM_THM; NOT_IN_EMPTY; IN_UNIV; IN_INSERT] THEN
    HYP MESON_TAC "wd f a" [MDIST_REFL]];
   ALL_TAC] THEN
  CONJ_TAC THENL
  [INTRO_TAC "![f] [g]; f g" THEN EXPAND_TAC "fdist" THEN REWRITE_TAC[] THEN
   AP_TERM_TAC THEN REWRITE_TAC[EXTENSION; IN_ELIM_THM] THEN
   HYP MESON_TAC "wd f g" [MDIST_SYM];
   ALL_TAC] THEN
  INTRO_TAC "![f] [g] [h]; f g h" THEN EXPAND_TAC "fdist" THEN
  REWRITE_TAC[] THEN MATCH_MP_TAC REAL_SUP_LE THEN CONJ_TAC THENL
  [REWRITE_TAC[EXTENSION; IN_ELIM_THM; NOT_IN_EMPTY; IN_UNIV] THEN
   HYP MESON_TAC "a" [];
   ALL_TAC] THEN
  FIX_TAC "[d]" THEN REWRITE_TAC [IN_ELIM_THM; IN_UNIV] THEN
  INTRO_TAC "@x. x d" THEN POP_ASSUM SUBST1_TAC THEN
  CUT_TAC
    `d m (f (x::A):B,h x) \<le> d (f x) g x + d (g x) h x \<and>
     d (f x) g x \<le> fdist (f,g) \<and>
     d (g x) h x \<le> fdist (g,h)` THEN
  EXPAND_TAC "fdist" THEN REWRITE_TAC[] THENL [REAL_ARITH_TAC; ALL_TAC] THEN
  HYP SIMP_TAC "wd f g h x" [MDIST_TRIANGLE] THEN
  CONJ_TAC THEN MATCH_MP_TAC REAL_LE_SUP THENL
  [CLAIM_TAC "@B. B" `\<exists>b. \<forall>x::A. x \<in> s \<Longrightarrow> d (f x)::B g x \<le> b` THENL
   [HYP SIMP_TAC "bound2 f g" [];
    MAP_EVERY EXISTS_TAC [`B::real`; `d m (f(x::A):B,g x)`]] THEN
   REWRITE_TAC[IN_ELIM_THM; IN_UNIV; REAL_LE_REFL] THEN HYP MESON_TAC "B x" [];
   CLAIM_TAC "@B. B" `\<exists>b. \<forall>x::A. x \<in> s \<Longrightarrow> d (g x)::B h x \<le> b` THENL
   [HYP SIMP_TAC "bound2 g h" []; ALL_TAC] THEN
   MAP_EVERY EXISTS_TAC [`B::real`; `d m (g(x::A):B,h x)`] THEN
   REWRITE_TAC[IN_ELIM_THM; IN_UNIV; REAL_LE_REFL] THEN
   HYP MESON_TAC "B x" []]);;

lemma funspace_imp_welldefined:
   "\<And>s m f::A=>B x. f \<in> mspace (funspace s m) \<and> x \<in> s \<Longrightarrow> f x \<in> M"
oops
  SIMP_TAC[FUNSPACE; IN_ELIM_THM]);;

lemma funspace_imp_extensional:
   "\<And>s m f::A=>B. f \<in> mspace (funspace s m) \<Longrightarrow> f \<in> EXTENSIONAL s"
oops
  SIMP_TAC[FUNSPACE; IN_ELIM_THM]);;

lemma funspace_imp_bounded_image:
   "\<And>s m f::A=>B. f \<in> mspace (funspace s m) \<Longrightarrow> mbounded (f ` s)"
oops
  SIMP_TAC[FUNSPACE; IN_ELIM_THM]);;

lemma funspace_imp_bounded:
   "\<And>s m f::A=>B. f \<in> mspace (funspace s m)
                \<Longrightarrow> s = {} \<or> (\<exists>c b. \<forall>x. x \<in> s \<Longrightarrow> d c f x \<le> b)"
oops
  REPEAT GEN_TAC THEN
  REWRITE_TAC[FUNSPACE; MBOUNDED; IMAGE_EQ_EMPTY; IN_ELIM_THM] THEN
  ASM_CASES_TAC `s::A=>bool = {}` THEN ASM_REWRITE_TAC[] THEN ASM SET_TAC[]);;

lemma funspace_imp_bounded2:
   "\<And>s m f g::A=>B. f \<in> mspace (funspace s m) \<and> g \<in> mspace (funspace s m)
                  \<Longrightarrow> (\<exists>b. \<forall>x. x \<in> s \<Longrightarrow> d (f x) g x \<le> b)"
oops
  REWRITE_TAC[FUNSPACE; IN_ELIM_THM] THEN REPEAT STRIP_TAC THEN
  CUT_TAC `mbounded (image f s \<union> g ` s)` THENL
  [REWRITE_TAC[MBOUNDED_ALT; \<subseteq>; IN_UNION] THEN
   STRIP_TAC THEN EXISTS_TAC `b::real` THEN ASM SET_TAC [];
   ASM_REWRITE_TAC[MBOUNDED_UNION]]);;

lemma funspace_mdist_le:
   "\<And>s m f g::A=>B a.
     (s \<noteq> {}) \<and>
     f \<in> mspace (funspace s m) \<and>
     g \<in> mspace (funspace s m)
     \<Longrightarrow> (d (funspace s m) (f,g) \<le> a \<longleftrightarrow>
          \<forall>x. x \<in> s \<Longrightarrow> d (f x) g x \<le> a)"
oops
  INTRO_TAC "! *; ne f g" THEN
  HYP (DESTRUCT_TAC "@b. b" \<circ>
    MATCH_MP FUNSPACE_IMP_BOUNDED2 \<circ> CONJ_LIST) "f g" [] THEN
  ASM_REWRITE_TAC[FUNSPACE] THEN
  MP_TAC (ISPECL [`{d (f x)::B g x | x::A \<in> s}`; `a::real`]
    REAL_SUP_LE_EQ) THEN
  ANTS_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[IN_ELIM_THM]] THEN
  MESON_TAC[]);;

lemma mcomplete_funspace:
   "\<And>s::A=>bool m::B metric. mcomplete \<Longrightarrow> mcomplete (funspace s m)"
oops
  REWRITE_TAC[mcomplete] THEN INTRO_TAC "!s m; cpl; ![f]; cy" THEN
  ASM_CASES_TAC `s::A=>bool = {}` THENL
  [POP_ASSUM SUBST_ALL_TAC THEN EXISTS_TAC `\<lambda>x::A. undefined::B` THEN
   REMOVE_THEN "cy" MP_TAC THEN
   SIMP_TAC[MCauchy; LIMIT_METRIC_SEQUENTIALLY; FUNSPACE; NOT_IN_EMPTY;
     IN_ELIM_THM; IN_EXTENSIONAL; IMAGE_CLAUSES; MBOUNDED_EMPTY];
   POP_ASSUM (LABEL_TAC "nempty")] THEN
  LABEL_ABBREV_TAC
    `g (x::A) = if x \<in> s
               then @y. limitin mtopology (\<lambda>n::num. f n x) y sequentially
               else undefined::B` THEN
  EXISTS_TAC `g::A=>B` THEN USE_THEN "cy" MP_TAC THEN
  HYP REWRITE_TAC "nempty"
    [MCauchy; FUNSPACE; IN_ELIM_THM; FORALL_AND_THM] THEN
  INTRO_TAC "(fwd fext fbd) cy'" THEN
  ASM_REWRITE_TAC[LIMIT_METRIC_SEQUENTIALLY; FUNSPACE; IN_ELIM_THM] THEN
  CLAIM_TAC "gext" `g::A=>B \<in> EXTENSIONAL s` THENL
  [REMOVE_THEN "g" (fun th -> SIMP_TAC[IN_EXTENSIONAL; GSYM th]);
   HYP REWRITE_TAC "gext" []] THEN
  CLAIM_TAC "bd2"
     `!n n'. \<exists>b. \<forall>x::A. x \<in> s \<Longrightarrow> d m (f (n::num) x::B, f n' x) \<le> b` THENL
  [REPEAT GEN_TAC THEN MATCH_MP_TAC FUNSPACE_IMP_BOUNDED2 THEN
   ASM_REWRITE_TAC[FUNSPACE; IN_ELIM_THM; ETA_AX];
   ALL_TAC] THEN
  CLAIM_TAC "sup"
    `!n n':num x0::A. x0 \<in> s
                     \<Longrightarrow> d f n x0::B f n' x0 \<le>
                         sup {d f n x f n' x | x \<in> s}` THENL
  [INTRO_TAC "!n n' x0; x0" THEN MATCH_MP_TAC REAL_LE_SUP THEN
   REMOVE_THEN "bd2" (DESTRUCT_TAC "@b. b" \<circ> SPECL[`n::num`;`n':num`]) THEN
   MAP_EVERY EXISTS_TAC
     [`b::real`; `d m (f (n::num) (x0::A):B, f n' x0)`] THEN
   REWRITE_TAC[IN_ELIM_THM] THEN CONJ_TAC THENL
   [HYP MESON_TAC "x0" []; REWRITE_TAC[REAL_LE_REFL]] THEN
   INTRO_TAC "![d]; @y. y d" THEN REMOVE_THEN "d" SUBST1_TAC THEN
   HYP SIMP_TAC "b y" [];
   ALL_TAC] THEN
  CLAIM_TAC "pcy" `\<forall>x::A. x \<in> s \<Longrightarrow> MCauchy (\<lambda>n. f n x::B)` THENL
  [INTRO_TAC "!x; x" THEN REWRITE_TAC[MCauchy] THEN
   HYP SIMP_TAC "fwd x" [] THEN INTRO_TAC "!e; e" THEN
   USE_THEN "e" (HYP_TAC "cy': @N.N" \<circ> C MATCH_MP) THEN EXISTS_TAC `N::num` THEN
   REPEAT GEN_TAC THEN DISCH_THEN (HYP_TAC "N" \<circ> C MATCH_MP) THEN
   TRANS_TAC REAL_LET_TRANS
     `sup {d m (f (n::num) x::B,f n' x) | x::A \<in> s}` THEN
   HYP REWRITE_TAC "N" [] THEN HYP SIMP_TAC "sup x" [];
   ALL_TAC] THEN
  CLAIM_TAC "glim"
    `\<forall>x::A. x \<in> s
           \<Longrightarrow> limitin mtopology (\<lambda>n. f n x::B) (g x) sequentially` THENL
  [INTRO_TAC "!x; x" THEN
   REMOVE_THEN "g" (fun th -> ASM_REWRITE_TAC[GSYM th]) THEN
   SELECT_ELIM_TAC THEN HYP SIMP_TAC "cpl pcy x" [];
   ALL_TAC] THEN
  CLAIM_TAC "gwd" `\<forall>x::A. x \<in> s \<Longrightarrow> g x::B \<in> M` THENL
  [INTRO_TAC "!x; x" THEN
   MATCH_MP_TAC (ISPECL[`sequentially`] LIMIT_IN_MSPACE) THEN
   EXISTS_TAC `\<lambda>n::num. f n (x::A):B` THEN HYP SIMP_TAC "glim x" [];
   HYP REWRITE_TAC "gwd" []] THEN
  CLAIM_TAC "unif"
    `\<forall>e>0.  \<exists>N::num. \<forall>x::A n. x \<in> s \<and> N \<le> n
                    \<Longrightarrow> d f n x::B g x < e` THENL
  [INTRO_TAC "!e; e" THEN REMOVE_THEN "cy'" (MP_TAC \<circ> SPEC `e / 2`) THEN
   HYP REWRITE_TAC "e" [REAL_HALF] THEN INTRO_TAC "@N. N" THEN
   EXISTS_TAC `N::num` THEN INTRO_TAC "!x n; x n" THEN
   USE_THEN "x" (HYP_TAC "glim" \<circ> C MATCH_MP) THEN
   HYP_TAC "glim: gx glim" (REWRITE_RULE[LIMIT_METRIC_SEQUENTIALLY]) THEN
   REMOVE_THEN "glim" (MP_TAC \<circ> SPEC `e / 2`) THEN
   HYP REWRITE_TAC "e" [REAL_HALF] THEN
   HYP SIMP_TAC "fwd x" [] THEN INTRO_TAC "@N'. N'" THEN
   TRANS_TAC REAL_LET_TRANS
     `d m (f n (x::A):B, f (MAX N N') x) +
      d m (f (MAX N N') x, g x)` THEN
   HYP SIMP_TAC "fwd x gwd" [MDIST_TRIANGLE] THEN
   TRANS_TAC REAL_LTE_TRANS `e / 2 + e / 2` THEN CONJ_TAC THENL
   [MATCH_MP_TAC REAL_LT_ADD2; REWRITE_TAC[REAL_HALF; REAL_LE_REFL]] THEN
   CONJ_TAC THENL [ALL_TAC; REMOVE_THEN "N'" MATCH_MP_TAC THEN ARITH_TAC] THEN
   TRANS_TAC REAL_LET_TRANS
     `sup {d m (f n x::B,f (MAX N N') x) | x::A \<in> s}` THEN
   HYP SIMP_TAC "N n" [ARITH_RULE `N \<le> MAX N N'`] THEN
   HYP SIMP_TAC "sup x" [];
   ALL_TAC] THEN
  CONJ_TAC THENL
  [HYP_TAC "cy': @N. N" (C MATCH_MP REAL_LT_01) THEN
   USE_THEN "fbd" (MP_TAC \<circ> REWRITE_RULE[MBOUNDED] \<circ> SPEC `N::num`) THEN
   HYP REWRITE_TAC "nempty" [mbounded; IMAGE_EQ_EMPTY] THEN
   INTRO_TAC "Nwd (@c b. c Nbd)" THEN
   MAP_EVERY EXISTS_TAC [`c::B`; `b + 1`] THEN
   REWRITE_TAC[\<subseteq>; IN_IMAGE; IN_MCBALL] THEN
   INTRO_TAC "![y]; (@x. y x)" THEN REMOVE_THEN "y" SUBST1_TAC THEN
   HYP SIMP_TAC "x gwd c" [] THEN TRANS_TAC REAL_LE_TRANS
     `d m (c::B, f (N::num) (x::A)) + d f N x g x` THEN
   HYP SIMP_TAC "c fwd gwd x" [MDIST_TRIANGLE] THEN
   MATCH_MP_TAC REAL_LE_ADD2 THEN CONJ_TAC THENL
   [REMOVE_THEN "Nbd" MATCH_MP_TAC THEN REWRITE_TAC[IN_IMAGE] THEN
    HYP MESON_TAC "x" [];
    REFUTE_THEN (LABEL_TAC "contra" \<circ> REWRITE_RULE[REAL_NOT_LE])] THEN
   CLAIM_TAC "@a. a1 a2"
     `\<exists>a. 1 < a \<and> a < d m (f (N::num) (x::A), g x::B)` THENL
   [EXISTS_TAC `(1 + d m (f (N::num) (x::A), g x::B)) / 2` THEN
    REMOVE_THEN "contra" MP_TAC THEN REAL_ARITH_TAC;
    USE_THEN "x" (HYP_TAC "glim" \<circ> C MATCH_MP)] THEN
   REMOVE_THEN "glim" (MP_TAC \<circ> REWRITE_RULE[LIMIT_METRIC_SEQUENTIALLY]) THEN
   HYP SIMP_TAC "gwd x" [] THEN DISCH_THEN (MP_TAC \<circ> SPEC `a - 1`) THEN
   ANTS_TAC THENL [REMOVE_THEN "a1" MP_TAC THEN REAL_ARITH_TAC; ALL_TAC] THEN
   HYP SIMP_TAC "fwd x" [] THEN INTRO_TAC "@N'. N'" THEN
   CUT_TAC `d m (f (N::num) (x::A), g x::B) < a` THENL
   [REMOVE_THEN "a2" MP_TAC THEN REAL_ARITH_TAC; ALL_TAC] THEN
   TRANS_TAC REAL_LET_TRANS
     `d m (f N (x::A),f (MAX N N') x::B) + d m (f (MAX N N') x,g x)` THEN
   HYP SIMP_TAC "fwd gwd x" [MDIST_TRIANGLE] THEN
   SUBST1_TAC (REAL_ARITH `a = 1 + (a - 1)`) THEN
   MATCH_MP_TAC REAL_LT_ADD2 THEN CONJ_TAC THENL
   [ALL_TAC; REMOVE_THEN "N'" MATCH_MP_TAC THEN ARITH_TAC] THEN
   TRANS_TAC REAL_LET_TRANS
     `sup {d m (f N x::B,f (MAX N N') x) | x::A \<in> s}` THEN
   CONJ_TAC THENL
   [HYP SIMP_TAC "sup x" []; REMOVE_THEN "N" MATCH_MP_TAC THEN ARITH_TAC];
   ALL_TAC] THEN
  INTRO_TAC "!e; e" THEN REMOVE_THEN "unif" (MP_TAC \<circ> SPEC `e / 2`) THEN
  HYP REWRITE_TAC "e" [REAL_HALF] THEN INTRO_TAC "@N. N" THEN
  EXISTS_TAC `N::num` THEN INTRO_TAC "!n; n" THEN
  TRANS_TAC REAL_LET_TRANS `e / 2` THEN CONJ_TAC THENL
  [ALL_TAC; REMOVE_THEN "e" MP_TAC THEN REAL_ARITH_TAC] THEN
  MATCH_MP_TAC REAL_SUP_LE THEN REWRITE_TAC[IN_ELIM_THM] THEN CONJ_TAC THENL
  [HYP SET_TAC "nempty" []; HYP MESON_TAC "N n" [REAL_LT_IMP_LE]]);;


subsection\<open>Metric space of continuous bounded functions\<close>


let cfunspace = new_definition
  `cfunspace X m =
   submetric (funspace (topspace X) m)
     {f::A=>B | continuous_map X mtopology f}`;;

let CFUNSPACE = (REWRITE_RULE[GSYM FORALL_AND_THM] \<circ> prove)
 (`(\<forall>X m.
      mspace (cfunspace X m) =
      {f::A=>B | (\<forall>x. x \<in> topspace X \<Longrightarrow> f x \<in> M) \<and>
                f \<in> EXTENSIONAL (topspace X) \<and>
                mbounded (f ` (topspace X)) \<and>
                continuous_map X mtopology f}) \<and>
     (\<forall>f g::A=>B.
        d (cfunspace X m) (f,g) =
        if topspace X = {} then 0 else
        sup {d (f x) g x | x \<in> topspace X})"
oops
  REWRITE_TAC[cfunspace; SUBMETRIC; FUNSPACE] THEN SET_TAC[]);;

lemma cfunspace_subset_funspace:
   "     mspace (cfunspace X m) \<subseteq> mspace (funspace (topspace X) m)"
oops
  SIMP_TAC[\<subseteq>; FUNSPACE; CFUNSPACE; IN_ELIM_THM]);;

lemma mdist_cfunspace_eq_mdist_funspace:
   "\<And>X m f g::A=>B.
     d (cfunspace X m) (f,g) = d (funspace (topspace X) m) (f,g)"
oops
  REWRITE_TAC[FUNSPACE; CFUNSPACE]);;

lemma cfunspace_mdist_le:
   "\<And>X m f g::A=>B a.
     \<not> (topspace X = {}) \<and>
     f \<in> mspace (cfunspace X m) \<and>
     g \<in> mspace (cfunspace X m)
     \<Longrightarrow> (d (cfunspace X m) (f,g) \<le> a \<longleftrightarrow>
          \<forall>x. x \<in> topspace X \<Longrightarrow> d (f x) g x \<le> a)"
oops
  INTRO_TAC "! *; ne f g" THEN
  REWRITE_TAC[MDIST_CFUNSPACE_EQ_MDIST_FUNSPACE] THEN
  MATCH_MP_TAC FUNSPACE_MDIST_LE THEN
  ASM_SIMP_TAC[REWRITE_RULE[\<subseteq>] CFUNSPACE_SUBSET_FUNSPACE]);;

lemma cfunspace_imp_bounded2:
   "\<And>X m f g::A=>B.
     f \<in> mspace (cfunspace X m) \<and> g \<in> mspace (cfunspace X m)
     \<Longrightarrow> (\<exists>b. \<forall>x. x \<in> topspace X \<Longrightarrow> d (f x) g x \<le> b)"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC FUNSPACE_IMP_BOUNDED2 THEN
  ASM SET_TAC [CFUNSPACE_SUBSET_FUNSPACE]);;

lemma cfunspace_mdist_lt:
   "\<And>X m f g::A=>B a x.
     compactin X (topspace X) \<and>
     f \<in> mspace (cfunspace X m) \<and> g \<in> mspace (cfunspace X m) \<and>
     d (cfunspace X m) (f, g) < a \<and>
     x \<in> topspace X
     \<Longrightarrow> d (f x) g x < a"
oops
  REPEAT GEN_TAC THEN ASM_CASES_TAC `topspace (X::A topology) = {}` THEN
  ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN INTRO_TAC "cpt f g lt x" THEN
  REMOVE_THEN "lt" MP_TAC THEN ASM_REWRITE_TAC[CFUNSPACE] THEN
  INTRO_TAC "lt" THEN
  TRANS_TAC REAL_LET_TRANS
    `sup {d (f x)::B g x | x::A \<in> topspace X}` THEN
  HYP SIMP_TAC "lt" [] THEN  MATCH_MP_TAC REAL_LE_SUP THEN
  HYP (DESTRUCT_TAC "@b. b" \<circ>
    MATCH_MP CFUNSPACE_IMP_BOUNDED2 \<circ> CONJ_LIST) "f g" [] THEN
  MAP_EVERY EXISTS_TAC [`b::real`; `d m (f (x::A):B,g x)`] THEN
  REWRITE_TAC[IN_ELIM_THM; REAL_LE_REFL] THEN HYP MESON_TAC "x b" []);;

lemma mdist_cfunspace_le:
   "     0 \<le> B \<and>
     (\<forall>x::A. x \<in> topspace X \<Longrightarrow> d (f x)::B g x \<le> B)
     \<Longrightarrow> d (cfunspace X m) (f,g) \<le> B"
oops
  INTRO_TAC "!X m B f g; Bpos bound" THEN
  REWRITE_TAC[CFUNSPACE] THEN COND_CASES_TAC THEN
  HYP REWRITE_TAC "Bpos" [] THEN MATCH_MP_TAC REAL_SUP_LE THEN
  CONJ_TAC THENL
  [POP_ASSUM MP_TAC THEN SET_TAC[];
   REWRITE_TAC[IN_ELIM_THM] THEN HYP MESON_TAC "bound" []]);;

lemma mdist_cfunspace_imp_mdist_le:
   "\<And>X m f g::A=>B a x.
     f \<in> mspace (cfunspace X m) \<and>
     g \<in> mspace (cfunspace X m) \<and>
     d (cfunspace X m) (f,g) \<le> a \<and>
     x \<in> topspace X
     \<Longrightarrow> d (f x) g x \<le> a"
oops
  MESON_TAC[MEMBER_NOT_EMPTY; CFUNSPACE_MDIST_LE]);;

lemma compact_in_mspace_cfunspace:
   "     compactin X (topspace X)
     \<Longrightarrow> mspace (cfunspace X m) =
          {f. (\<forall>x::A. x \<in> topspace X \<Longrightarrow> f x::B \<in> M) \<and>
               f \<in> EXTENSIONAL (topspace X) \<and>
               continuous_map X mtopology f}"
oops
  REWRITE_TAC[CFUNSPACE; EXTENSION; IN_ELIM_THM] THEN REPEAT STRIP_TAC THEN
  EQ_TAC THEN SIMP_TAC[] THEN INTRO_TAC "wd ext cont" THEN
  MATCH_MP_TAC COMPACT_IN_IMP_MBOUNDED THEN
  MATCH_MP_TAC (ISPEC `X::A topology` IMAGE_COMPACT_IN) THEN
  ASM_REWRITE_TAC[]);;

lemma mcomplete_cfunspace:
   "mcomplete \<Longrightarrow> mcomplete (cfunspace X m)"
oops
  INTRO_TAC "!X m; cpl" THEN REWRITE_TAC[cfunspace] THEN
  MATCH_MP_TAC SEQUENTIALLY_CLOSED_IN_MCOMPLETE_IMP_MCOMPLETE THEN
  ASM_SIMP_TAC[MCOMPLETE_FUNSPACE] THEN
  REWRITE_TAC[IN_ELIM_THM; LIMIT_METRIC_SEQUENTIALLY] THEN
  INTRO_TAC "![f] [g]; fcont g lim" THEN
  ASM_CASES_TAC `topspace X = {}:A=>bool` THENL
  [ASM_REWRITE_TAC[continuous_map; NOT_IN_EMPTY; EMPTY_GSPEC; OPEN_IN_EMPTY];
   POP_ASSUM (LABEL_TAC "nempty")] THEN
  REWRITE_TAC[CONTINUOUS_MAP_TO_METRIC; IN_MBALL] THEN
  INTRO_TAC "!x; x; ![e]; e" THEN CLAIM_TAC "e3pos" `0 < e / 3` THENL
  [REMOVE_THEN "e" MP_TAC THEN REAL_ARITH_TAC;
   USE_THEN "e3pos" (HYP_TAC "lim: @N. N" \<circ> C MATCH_MP)] THEN
  HYP_TAC "N: f lt" (C MATCH_MP (SPEC `N::num` LE_REFL)) THEN
  HYP_TAC "fcont" (REWRITE_RULE[CONTINUOUS_MAP_TO_METRIC]) THEN
  USE_THEN "x" (HYP_TAC "fcont" \<circ> C MATCH_MP) THEN
  USE_THEN "e3pos" (HYP_TAC "fcont" \<circ> C MATCH_MP) THEN
  HYP_TAC "fcont: @u. u x' inc" (SPEC `N::num`) THEN EXISTS_TAC `u::A=>bool` THEN
  HYP REWRITE_TAC "u x'" [] THEN INTRO_TAC "!y; y'" THEN
  CLAIM_TAC "uinc" `\<forall>x::A. x \<in> u \<Longrightarrow> x \<in> topspace X` THENL
  [REMOVE_THEN "u" (MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN SET_TAC[];
   ALL_TAC] THEN
  HYP_TAC "g -> gwd gext gbd" (REWRITE_RULE[FUNSPACE; IN_ELIM_THM]) THEN
  HYP_TAC "f -> fwd fext fbd" (REWRITE_RULE[FUNSPACE; IN_ELIM_THM]) THEN
  CLAIM_TAC "y" `y::A \<in> topspace X` THENL
  [HYP SIMP_TAC "uinc y'" [OPEN_IN_SUBSET]; HYP SIMP_TAC "gwd x y" []] THEN
  CLAIM_TAC "sup" `\<forall>x0::A. x0 \<in> topspace X
                          \<Longrightarrow> d m (f (N::num) x0::B,g x0) \<le> e / 3` THENL
  [INTRO_TAC "!x0; x0" THEN TRANS_TAC REAL_LE_TRANS
     `sup {d m (f (N::num) x,g x::B) | x::A \<in> topspace X}` THEN
   CONJ_TAC THENL
   [MATCH_MP_TAC REAL_LE_SUP THEN HYP (DESTRUCT_TAC "@b. b" \<circ>
      MATCH_MP FUNSPACE_IMP_BOUNDED2 \<circ> CONJ_LIST) "f g" [] THEN
    MAP_EVERY EXISTS_TAC [`b::real`; `d m (f (N::num) (x0::A), g x0::B)`] THEN
    REWRITE_TAC[IN_ELIM_THM; REAL_LE_REFL] THEN
    CONJ_TAC THENL [HYP SET_TAC "x0" []; HYP MESON_TAC "b" []];
    REMOVE_THEN "lt" MP_TAC THEN HYP REWRITE_TAC "nempty" [FUNSPACE] THEN
    MATCH_ACCEPT_TAC REAL_LT_IMP_LE];
   ALL_TAC] THEN
  TRANS_TAC REAL_LET_TRANS
    `d m (g (x::A):B, f (N::num) x) + d f N x g y` THEN
  HYP SIMP_TAC "gwd fwd x y" [MDIST_TRIANGLE] THEN
  SUBST1_TAC (ARITH_RULE `e = e / 3 + (e / 3 + e / 3)`) THEN
  MATCH_MP_TAC REAL_LET_ADD2 THEN HYP SIMP_TAC "gwd fwd x sup" [MDIST_SYM] THEN
  TRANS_TAC REAL_LET_TRANS
    `d m (f (N::num) (x::A):B, f N y) + d f N y g y` THEN
  HYP SIMP_TAC "fwd gwd x y" [MDIST_TRIANGLE] THEN
  MATCH_MP_TAC REAL_LTE_ADD2 THEN HYP SIMP_TAC "gwd fwd y sup" [] THEN
  REMOVE_THEN "inc" MP_TAC THEN HYP SIMP_TAC "fwd x y' uinc" [IN_MBALL]);;


subsection\<open>Existence of completion for any metric space M as a subspace of M=>R\<close>


lemma metric_completion_explicit:
   "\<exists>s f::A=>A->real.
      s \<subseteq> mspace(funspace (M) real_euclidean_metric) \<and>
      mcomplete(submetric (funspace (M) real_euclidean_metric) s) \<and>
      image f (M) \<subseteq> s \<and>
      mtopology(funspace (M) real_euclidean_metric) closure_of
      image f (M) = s \<and>
      \<forall>x y. x \<in> M \<and> y \<in> M
            \<Longrightarrow> d (funspace (M) real_euclidean_metric) (f x,f y) =
                d x y"
oops
  GEN_TAC THEN
  ABBREV_TAC `m' = funspace (M::A=>bool) real_euclidean_metric` THEN
  ASM_CASES_TAC `M::A=>bool = {}` THENL
   [EXISTS_TAC `{}:(A=>real)->bool` THEN
    ASM_REWRITE_TAC[NOT_IN_EMPTY; IMAGE_CLAUSES; CLOSURE_OF_EMPTY;
                 EMPTY_SUBSET; INTER_EMPTY; mcomplete; CAUCHY_IN_SUBMETRIC];
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY])] THEN
  DISCH_THEN(X_CHOOSE_TAC `a::A`) THEN
  ABBREV_TAC
    `f::A=>A->real =
     \<lambda>x. RESTRICTION (M) (\<lambda>u. d x u - d a u)` THEN
  EXISTS_TAC `mtopology(funspace (M) real_euclidean_metric) closure_of
              image (f::A=>A->real) (M)` THEN
  EXISTS_TAC `f::A=>A->real` THEN
  EXPAND_TAC "m'" THEN
 SUBGOAL_THEN `image (f::A=>A->real) (M) \<subseteq> mspace m'`
  ASSUME_TAC THENL
   [EXPAND_TAC "m'" THEN REWRITE_TAC[\<subseteq>; FUNSPACE] THEN
    REWRITE_TAC[FORALL_IN_IMAGE; IN_ELIM_THM; EXTENSIONAL] THEN
    REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV; mbounded; mcball] THEN
    X_GEN_TAC `b::A` THEN DISCH_TAC THEN
    EXPAND_TAC "f" THEN SIMP_TAC[RESTRICTION; \<subseteq>; FORALL_IN_IMAGE] THEN
    MAP_EVERY EXISTS_TAC [`0::real`; `d a::A b`] THEN
    REWRITE_TAC[IN_ELIM_THM; REAL_SUB_RZERO] THEN
    MAP_EVERY UNDISCH_TAC [`(a::A) \<in> M`; `(b::A) \<in> M`] THEN
    CONV_TAC METRIC_ARITH;
    ALL_TAC] THEN
  REWRITE_TAC[SUBMETRIC] THEN ASM_REWRITE_TAC[] THEN REPEAT CONJ_TAC THENL
   [REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY] THEN
    REWRITE_TAC[CLOSURE_OF_SUBSET_TOPSPACE];
    MATCH_MP_TAC CLOSED_IN_MCOMPLETE_IMP_MCOMPLETE THEN
    REWRITE_TAC[CLOSED_IN_CLOSURE_OF] THEN EXPAND_TAC "m'" THEN
    MATCH_MP_TAC MCOMPLETE_FUNSPACE THEN
    REWRITE_TAC[MCOMPLETE_REAL_EUCLIDEAN_METRIC];
    MATCH_MP_TAC CLOSURE_OF_SUBSET THEN
    ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY];
    MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
    EXPAND_TAC "m'" THEN REWRITE_TAC[FUNSPACE] THEN
    COND_CASES_TAC THENL [ASM_MESON_TAC[NOT_IN_EMPTY]; ALL_TAC] THEN
    MATCH_MP_TAC SUP_UNIQUE THEN SIMP_TAC[FORALL_IN_GSPEC] THEN
    X_GEN_TAC `b::real` THEN REWRITE_TAC[REAL_EUCLIDEAN_METRIC] THEN
    EXPAND_TAC "f" THEN REWRITE_TAC[RESTRICTION] THEN EQ_TAC THENL
     [DISCH_THEN(fun th -> MP_TAC(SPEC `x::A` th)) THEN EXPAND_TAC "f" THEN
      ASM_SIMP_TAC[MDIST_REFL; MDIST_SYM] THEN REAL_ARITH_TAC;
      MAP_EVERY UNDISCH_TAC [`(x::A) \<in> M`; `(y::A) \<in> M`] THEN
      CONV_TAC METRIC_ARITH]]);;

lemma metric_completion:
   "        ?m' f::A=>A->real.
                mcomplete m' \<and>
                image f (M) \<subseteq> mspace m' \<and>
                (mtopology m') closure_of (image f (M)) = mspace m' \<and>
                \<forall>x y. x \<in> M \<and> y \<in> M
                      \<Longrightarrow> d m' (f x,f y) = d x y"
oops
  GEN_TAC THEN
  MATCH_MP_TAC(MESON[]
   `(\<exists>s f. P (submetric (funspace (M) real_euclidean_metric) s) f)
    \<Longrightarrow> \<exists>n f. P n f`) THEN
  MP_TAC(SPEC `m::A metric` METRIC_COMPLETION_EXPLICIT) THEN
  REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
  REWRITE_TAC[SUBMETRIC; SUBSET_INTER] THEN
  REWRITE_TAC[MTOPOLOGY_SUBMETRIC; CLOSURE_OF_SUBTOPOLOGY] THEN
  SIMP_TAC[SET_RULE `t \<subseteq> s \<Longrightarrow> s \<inter> t = t`] THEN SET_TAC[]);;

lemma metrizable_space_completion:
   "        metrizable_space X
        \<Longrightarrow> ?top' (f::A=>A->real).
                completely_metrizable_space X' \<and>
                embedding_map X X' f \<and>
                X' closure_of (f ` (topspace X)) = topspace X'"
oops
  REWRITE_TAC[FORALL_METRIZABLE_SPACE; RIGHT_EXISTS_AND_THM] THEN
  X_GEN_TAC `m::A metric` THEN
  REWRITE_TAC[EXISTS_COMPLETELY_METRIZABLE_SPACE; RIGHT_AND_EXISTS_THM] THEN
  MP_TAC(ISPEC `m::A metric` METRIC_COMPLETION) THEN
  REPEAT(MATCH_MP_TAC MONO_EXISTS THEN GEN_TAC) THEN
  MESON_TAC[ISOMETRY_IMP_EMBEDDING_MAP]);;


text\<open> The Baire Category Theorem                                                \<close>


lemma metric_baire_category:
   "     mcomplete \<and>
     countable g \<and>
     (\<forall>t. t \<in> g \<Longrightarrow> openin mtopology t \<and>
                     mtopology closure_of t = M)
     \<Longrightarrow> mtopology closure_of \<Inter> g = M"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN INTRO_TAC "!m; m" THEN
  REWRITE_TAC[FORALL_COUNTABLE_AS_IMAGE; NOT_IN_EMPTY; CLOSURE_OF_UNIV;
  INTERS_0; TOPSPACE_MTOPOLOGY; FORALL_IN_IMAGE; IN_UNIV; FORALL_AND_THM] THEN
  INTRO_TAC "![u]; u_open u_dense" THEN
  REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY] THEN
  REWRITE_TAC[DENSE_INTERSECTS_OPEN] THEN
  INTRO_TAC "![w]; w_open w_ne" THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  CLAIM_TAC "@x0. x0" `\<exists>x0::A. x0 \<in> u 0 \<inter> w` THENL
  [REWRITE_TAC[MEMBER_NOT_EMPTY] THEN
   ASM_MESON_TAC[DENSE_INTERSECTS_OPEN; TOPSPACE_MTOPOLOGY];
   ALL_TAC] THEN
  CLAIM_TAC "@r0. r0pos r0lt1 sub"
    `\<exists>r. 0 < r \<and> r < 1 \<and> mcball m (x0::A,r) \<subseteq> u 0 \<inter> w` THENL
  [SUBGOAL_THEN `openin mtopology (u 0 \<inter> w::A=>bool)` MP_TAC THENL
   [HYP SIMP_TAC "u_open w_open" [OPEN_IN_INTER]; ALL_TAC] THEN
   REWRITE_TAC[OPEN_IN_MTOPOLOGY] THEN INTRO_TAC "u0w hp" THEN
   REMOVE_THEN "hp" (MP_TAC \<circ> SPEC `x0::A`) THEN
   ANTS_TAC THENL [HYP REWRITE_TAC "x0" []; ALL_TAC] THEN
   INTRO_TAC "@r. rpos ball" THEN EXISTS_TAC `min r 1 / 2` THEN
   CONJ_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
   CONJ_TAC THENL [REAL_ARITH_TAC; ALL_TAC] THEN
   TRANS_TAC SUBSET_TRANS `mball m (x0::A,r)` THEN
   HYP REWRITE_TAC "ball" [] THEN
   MATCH_MP_TAC MCBALL_SUBSET_MBALL_CONCENTRIC THEN
   ASM_REAL_ARITH_TAC; ALL_TAC] THEN
  (DESTRUCT_TAC "@b. b0 b1" \<circ> prove_general_recursive_function_exists)
    `\<exists>b::num->(A#real).
       b 0 = (x0::A,r0) \<and>
       (\<forall>n. b (Suc n) =
            @(x,r). 0 < r \<and> r < snd (b n) / 2 \<and> x \<in> M \<and>
                    mcball x r \<subseteq> mball m (b n) \<inter> u n)` THEN
  CLAIM_TAC "rmk"
    `\<forall>n. (\ (x::A,r). 0 < r \<and> r < snd (b n) / 2 \<and> x \<in> M \<and>
                   mcball x r \<subseteq> mball m (b n) \<inter> u n)
         (b (Suc n))` THENL
  [LABEL_INDUCT_TAC THENL
   [REMOVE_THEN "b1" (fun b1 -> REWRITE_TAC[b1]) THEN
    MATCH_MP_TAC CHOICE_PAIRED_THM THEN
    REMOVE_THEN "b0" (fun b0 -> REWRITE_TAC[b0]) THEN
    MAP_EVERY EXISTS_TAC [`x0::A`; `r0 / 4`] THEN
    CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
    CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
    CONJ_TAC THENL
    [CUT_TAC `u 0::A=>bool \<subseteq> M` THENL
     [HYP SET_TAC "x0" [];
      HYP SIMP_TAC "u_open" [GSYM TOPSPACE_MTOPOLOGY; OPEN_IN_SUBSET]];
     ALL_TAC] THEN
    TRANS_TAC SUBSET_TRANS `mball m (x0::A,r0)` THEN CONJ_TAC THENL
    [MATCH_MP_TAC MCBALL_SUBSET_MBALL_CONCENTRIC THEN ASM_REAL_ARITH_TAC;
     REWRITE_TAC[SUBSET_INTER; SUBSET_REFL] THEN
     TRANS_TAC SUBSET_TRANS `mcball m (x0::A,r0)` THEN
     REWRITE_TAC [MBALL_SUBSET_MCBALL] THEN HYP SET_TAC "sub" []];
    ALL_TAC] THEN
   USE_THEN "b1" (fun b1 -> GEN_REWRITE_TAC RAND_CONV [b1]) THEN
   MATCH_MP_TAC CHOICE_PAIRED_THM THEN REWRITE_TAC[] THEN
   HYP_TAC "ind_n: rpos rlt x subn" (REWRITE_RULE[LAMBDA_PAIR]) THEN
   USE_THEN "u_dense" (MP_TAC \<circ> SPEC `Suc n` \<circ>
     REWRITE_RULE[GSYM TOPSPACE_MTOPOLOGY]) THEN
   REWRITE_TAC[DENSE_INTERSECTS_OPEN] THEN
   DISCH_THEN (MP_TAC \<circ> SPEC `mball m (b (Suc n):A#real)`) THEN
   (DESTRUCT_TAC "@x1 r1. bsuc" \<circ> MESON[PAIR])
     `\<exists>x1::A r1::real. b (Suc n) = x1,r1` THEN
   HYP REWRITE_TAC "bsuc" [] THEN
   REMOVE_THEN "bsuc"
    (fun th -> RULE_ASSUM_TAC (REWRITE_RULE[th]) THEN LABEL_TAC "bsuc" th) THEN
   ANTS_TAC THENL
   [HYP REWRITE_TAC "x" [OPEN_IN_MBALL; MBALL_EQ_EMPTY; DE_MORGAN_THM] THEN
    ASM_REAL_ARITH_TAC; ALL_TAC] THEN
   REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN INTRO_TAC "@z. hp" THEN
   EXISTS_TAC `z::A` THEN
   SUBGOAL_THEN `openin mtopology (mball m (x1::A,r1) \<inter> u (Suc n))`
     (DESTRUCT_TAC "hp1 hp2" \<circ> REWRITE_RULE[OPEN_IN_MTOPOLOGY_MCBALL]) THENL
   [HYP SIMP_TAC "u_open" [OPEN_IN_INTER; OPEN_IN_MBALL]; ALL_TAC] THEN
   CLAIM_TAC "z" `z::A \<in> M` THENL
   [CUT_TAC `u (Suc n):A=>bool \<subseteq> M` THENL
    [HYP SET_TAC "hp" [];
     HYP SIMP_TAC "u_open" [GSYM TOPSPACE_MTOPOLOGY; OPEN_IN_SUBSET]];
    HYP REWRITE_TAC "z" []] THEN
   REMOVE_THEN "hp2" (MP_TAC \<circ> SPEC `z::A`) THEN
   ANTS_TAC THENL [HYP SET_TAC "hp" []; ALL_TAC] THEN
   INTRO_TAC "@r. rpos ball" THEN EXISTS_TAC `min r (r1 / 4)` THEN
   CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
   CONJ_TAC THENL [ASM_REAL_ARITH_TAC; ALL_TAC] THEN
   TRANS_TAC SUBSET_TRANS `mcball m (z::A,r)` THEN
   HYP SIMP_TAC "ball" [MCBALL_SUBSET_CONCENTRIC; REAL_MIN_MIN];
   ALL_TAC] THEN
  CLAIM_TAC "@x r. b" `\<exists>x r. \<forall>n::num. b n = x n::A, r n::real` THENL
  [MAP_EVERY EXISTS_TAC
     [`fst \<circ> (b::num=>A#real)`; `snd \<circ> (b::num=>A#real)`] THEN
   REWRITE_TAC[o_DEF]; ALL_TAC] THEN
  REMOVE_THEN "b"
    (fun b -> RULE_ASSUM_TAC (REWRITE_RULE[b]) THEN LABEL_TAC "b" b) THEN
  HYP_TAC "b0: x_0 r_0" (REWRITE_RULE[PAIR_EQ]) THEN
  REMOVE_THEN "x_0" (SUBST_ALL_TAC \<circ> GSYM) THEN
  REMOVE_THEN "r_0" (SUBST_ALL_TAC \<circ> GSYM) THEN
  HYP_TAC "rmk: r1pos r1lt x1 ball" (REWRITE_RULE[FORALL_AND_THM]) THEN
  CLAIM_TAC "x" `\<forall>n::num. x n::A \<in> M` THENL
  [LABEL_INDUCT_TAC THENL
   [CUT_TAC `u 0::A=>bool \<subseteq> M` THENL
    [HYP SET_TAC "x0" [];
     HYP SIMP_TAC "u_open" [GSYM TOPSPACE_MTOPOLOGY; OPEN_IN_SUBSET]];
    HYP REWRITE_TAC "x1" []];
   ALL_TAC] THEN
  CLAIM_TAC "rpos" `\<forall>n::num. 0 < r n` THENL
  [LABEL_INDUCT_TAC THENL
   [HYP REWRITE_TAC "r0pos" []; HYP REWRITE_TAC "r1pos" []];
   ALL_TAC] THEN
  CLAIM_TAC "rmono" `\<forall>p q::num. p \<le> q \<Longrightarrow> r q \<le> r p` THENL
  [MATCH_MP_TAC LE_INDUCT THEN REWRITE_TAC[REAL_LE_REFL] THEN
   INTRO_TAC "!p q; pq rpq" THEN
   REMOVE_THEN "r1lt" (MP_TAC \<circ> SPEC `q::num`) THEN
   REMOVE_THEN "rpos" (MP_TAC \<circ> SPEC `q::num`) THEN
   ASM_REAL_ARITH_TAC;
   ALL_TAC] THEN
  CLAIM_TAC "rlt" `\<forall>n::num. r n < inverse (2 ^ n)` THENL
  [LABEL_INDUCT_TAC THENL
   [CONV_TAC (RAND_CONV REAL_RAT_REDUCE_CONV) THEN HYP REWRITE_TAC "r0lt1" [];
    TRANS_TAC REAL_LTE_TRANS `r (n::num) / 2` THEN
    HYP REWRITE_TAC "r1lt" [real_pow] THEN REMOVE_THEN "ind_n" MP_TAC THEN
    REMOVE_THEN "rpos" (MP_TAC \<circ> SPEC `n::num`) THEN CONV_TAC REAL_FIELD];
   ALL_TAC] THEN
  CLAIM_TAC "nested"
    `\<forall>p q::num. p \<le> q \<Longrightarrow> mball m (x q::A, r q) \<subseteq> mball m (x p, r p)` THENL
  [MATCH_MP_TAC LE_INDUCT THEN REWRITE_TAC[SUBSET_REFL] THEN
   INTRO_TAC "!p q; pq sub" THEN
   TRANS_TAC SUBSET_TRANS `mball m (x (q::num):A,r q)` THEN
   HYP REWRITE_TAC "sub" [] THEN
   TRANS_TAC SUBSET_TRANS `mcball m (x (Suc q):A,r(Suc q))` THEN
   REWRITE_TAC[MBALL_SUBSET_MCBALL] THEN HYP SET_TAC "ball" [];
   ALL_TAC] THEN
  CLAIM_TAC "in_ball" `\<forall>p q::num. p \<le> q \<Longrightarrow> x q::A \<in> mball m (x p, r p)` THENL
  [INTRO_TAC "!p q; le" THEN CUT_TAC `x (q::num):A \<in> mball m (x q, r q)` THENL
   [HYP SET_TAC "nested le" []; HYP SIMP_TAC "x rpos" [CENTRE_IN_MBALL_EQ]];
   ALL_TAC] THEN
  CLAIM_TAC "@l. l" `\<exists>l::A. limitin mtopology x l sequentially` THENL
  [HYP_TAC "m" (REWRITE_RULE[mcomplete]) THEN REMOVE_THEN "m" MATCH_MP_TAC THEN
   HYP REWRITE_TAC "x" [MCauchy] THEN INTRO_TAC "!e; epos" THEN
   CLAIM_TAC "@N. N" `\<exists>N. inverse(2 ^ N) < e` THENL
   [REWRITE_TAC[REAL_INV_POW] THEN MATCH_MP_TAC REAL_ARCH_POW_INV THEN
    HYP REWRITE_TAC "epos" [] THEN REAL_ARITH_TAC;
    ALL_TAC] THEN
   EXISTS_TAC `N::num` THEN MATCH_MP_TAC WLOG_LE THEN CONJ_TAC THENL
   [HYP SIMP_TAC "x" [MDIST_SYM] THEN MESON_TAC[]; ALL_TAC] THEN
   INTRO_TAC "!n n'; le; n n'" THEN
   TRANS_TAC REAL_LT_TRANS `inverse (2 ^ N)` THEN HYP REWRITE_TAC "N" [] THEN
   TRANS_TAC REAL_LT_TRANS `r (N::num):real` THEN HYP REWRITE_TAC "rlt" [] THEN
   CUT_TAC `x (n':num):A \<in> mball m (x n, r n)` THENL
   [HYP REWRITE_TAC "x" [IN_MBALL] THEN INTRO_TAC "hp" THEN
    TRANS_TAC REAL_LTE_TRANS `r (n::num):real` THEN
    HYP SIMP_TAC "n rmono hp" [];
    HYP SIMP_TAC "in_ball le" []];
   ALL_TAC] THEN
  EXISTS_TAC `l::A` THEN
  CLAIM_TAC "in_mcball" `\<forall>n::num. l::A \<in> mcball m (x n, r n)` THENL
  [GEN_TAC THEN
   (MATCH_MP_TAC \<circ> ISPECL [`sequentially`; `mtopology (m::A metric)`])
   LIMIT_IN_CLOSED_IN THEN EXISTS_TAC `x::num=>A` THEN
   HYP REWRITE_TAC "l" [TRIVIAL_LIMIT_SEQUENTIALLY; CLOSED_IN_MCBALL] THEN
   REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC `n::num` THEN
   INTRO_TAC "![p]; p" THEN CUT_TAC `x (p::num):A \<in> mball m (x n, r n)` THENL
   [SET_TAC[MBALL_SUBSET_MCBALL]; HYP SIMP_TAC "in_ball p" []];
   ALL_TAC] THEN
  REWRITE_TAC[IN_INTER] THEN CONJ_TAC THENL
  [REWRITE_TAC[IN_INTERS; FORALL_IN_IMAGE; IN_UNIV] THEN
   LABEL_INDUCT_TAC THENL
   [HYP SET_TAC "in_mcball sub " []; HYP SET_TAC "in_mcball ball " []];
   HYP SET_TAC "sub in_mcball" []]);;

lemma metric_baire_category_alt:
   "\<And>m g:(A=>bool)->bool.
         mcomplete \<and>
         countable g \<and>
         (\<forall>t. t \<in> g
              \<Longrightarrow> closedin mtopology t \<and> mtopology interior_of t = {})
         \<Longrightarrow> mtopology interior_of (\<Union> g) = {}"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`m::A metric`; `image (\<lambda>u::A=>bool. M - u) g`]
        METRIC_BAIRE_CATEGORY) THEN
  ASM_SIMP_TAC[COUNTABLE_IMAGE; FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_MSPACE] THEN
  REWRITE_TAC[CLOSURE_OF_COMPLEMENT; GSYM TOPSPACE_MTOPOLOGY] THEN
  ASM_SIMP_TAC[DIFF_EMPTY] THEN REWRITE_TAC[CLOSURE_OF_INTERIOR_OF] THEN
  MATCH_MP_TAC(SET_RULE
    `s \<subseteq> u \<and> s' = s \<Longrightarrow> u - s' = u \<Longrightarrow> s = {}`) THEN
  REWRITE_TAC[INTERIOR_OF_SUBSET_TOPSPACE] THEN AP_TERM_TAC THEN
  REWRITE_TAC[DIFF_INTERS; SET_RULE
   `{f y | y \<in> g ` s} = {f(g x) | x \<in> s}`] THEN
  AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x = x) \<Longrightarrow> {f x | x \<in> s} = s`) THEN
  X_GEN_TAC `s::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `s::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN SET_TAC[]);;

lemma baire_category_alt:
   "\<And>X g:(A=>bool)->bool.
        (completely_metrizable_space X \<or>
         locally_compact_space X \<and>
         (Hausdorff_space X \<or> regular_space X)) \<and>
        countable g \<and>
        (\<forall>t. t \<in> g \<Longrightarrow> closedin X t \<and> X interior_of t = {})
        \<Longrightarrow> X interior_of (\<Union> g) = {}"
oops
  REWRITE_TAC[TAUT `(p \<or> q) \<and> r \<Longrightarrow> s \<longleftrightarrow>
                    (p \<Longrightarrow> r \<Longrightarrow> s) \<and> (q \<and> r \<Longrightarrow> s)`] THEN
  REWRITE_TAC[FORALL_AND_THM; RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[GSYM FORALL_MCOMPLETE_TOPOLOGY] THEN
  SIMP_TAC[METRIC_BAIRE_CATEGORY_ALT] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (TAUT `(p \<or> q) \<Longrightarrow> (p \<Longrightarrow> q) \<Longrightarrow> q`)) THEN
  ANTS_TAC THENL
   [ASM_MESON_TAC[LOCALLY_COMPACT_HAUSDORFF_IMP_REGULAR_SPACE]; DISCH_TAC] THEN
  ASM_CASES_TAC `g:(A=>bool)->bool = {}` THEN
  ASM_REWRITE_TAC[UNIONS_0; INTERIOR_OF_EMPTY] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        COUNTABLE_AS_IMAGE)) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `t::num=>A->bool` THEN DISCH_THEN SUBST_ALL_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [FORALL_IN_IMAGE]) THEN
  REWRITE_TAC[IN_UNIV; FORALL_AND_THM] THEN STRIP_TAC THEN
  REWRITE_TAC[interior_of; EXTENSION; IN_ELIM_THM; NOT_IN_EMPTY] THEN
  X_GEN_TAC `z::A` THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPEC `X::A topology`
        LOCALLY_COMPACT_SPACE_NEIGHBOURHOOD_BASE_CLOSED_IN) THEN
  ASM_REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
  FIRST_ASSUM(MP_TAC \<circ> SPEC `z::A` \<circ> REWRITE_RULE[\<subseteq>] \<circ> MATCH_MP
    OPEN_IN_SUBSET) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`u::A=>bool`; `z::A`]) THEN
  ASM_REWRITE_TAC[NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `k::A=>bool`] THEN STRIP_TAC THEN
  SUBGOAL_THEN
   `\<exists>c::num=>A->bool.
        (\<forall>n. c n \<subseteq> k \<and> closedin X (c n) \<and>
             \<not> (X interior_of c n = {}) \<and> disjnt (c n) (t n)) \<and>
        (\<forall>n. c (Suc n) \<subseteq> c n)`
  MP_TAC THENL
   [MATCH_MP_TAC DEPENDENT_CHOICE THEN CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id
       [GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN]) THEN
      REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC `v - (t::num=>A->bool) 0`) THEN
      ASM_SIMP_TAC[OPEN_IN_DIFF] THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP MONO_EXISTS) THEN ANTS_TAC THENL
       [REWRITE_TAC[SET_RULE `(\<exists>x. x \<in> s - t) \<longleftrightarrow> \<not> (s \<subseteq> t)`] THEN
        DISCH_TAC THEN
        SUBGOAL_THEN `X interior_of (t::num=>A->bool) 0 = {}` MP_TAC THENL
         [ASM_REWRITE_TAC[]; REWRITE_TAC[interior_of]] THEN
        REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; IN_ELIM_THM] THEN ASM_MESON_TAC[];
        REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
        MAP_EVERY X_GEN_TAC [`x::A`; `n::A=>bool`; `c::A=>bool`] THEN
        STRIP_TAC THEN EXISTS_TAC `c::A=>bool` THEN
        ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
        REPEAT CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC; ASM SET_TAC[]] THEN
        EXISTS_TAC `x::A` THEN REWRITE_TAC[interior_of; IN_ELIM_THM] THEN
        ASM_MESON_TAC[]];
      MAP_EVERY X_GEN_TAC [`n::num`; `c::A=>bool`] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id
       [GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN]) THEN
      REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
      DISCH_THEN(MP_TAC \<circ> SPEC
        `X interior_of c - (t::num=>A->bool) (Suc n)`) THEN
      ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_INTERIOR_OF] THEN
      DISCH_THEN(MP_TAC \<circ> MATCH_MP MONO_EXISTS) THEN ANTS_TAC THENL
       [REWRITE_TAC[SET_RULE `(\<exists>x. x \<in> s - t) \<longleftrightarrow> \<not> (s \<subseteq> t)`] THEN
        DISCH_TAC THEN
        SUBGOAL_THEN `X interior_of t(Suc n):A=>bool = {}` MP_TAC THENL
         [ASM_REWRITE_TAC[]; REWRITE_TAC[interior_of]] THEN
        REWRITE_TAC[GSYM MEMBER_NOT_EMPTY; IN_ELIM_THM] THEN
        ASM_MESON_TAC[OPEN_IN_INTERIOR_OF; MEMBER_NOT_EMPTY];
        REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
        MAP_EVERY X_GEN_TAC [`x::A`; `n::A=>bool`; `d::A=>bool`] THEN
        STRIP_TAC THEN EXISTS_TAC `d::A=>bool` THEN
        ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REPEAT CONJ_TAC THENL
         [MP_TAC(ISPECL[`X::A topology`; `c::A=>bool`] INTERIOR_OF_SUBSET) THEN
          ASM SET_TAC[];
          EXISTS_TAC `x::A` THEN REWRITE_TAC[interior_of; IN_ELIM_THM] THEN
          ASM_MESON_TAC[];
          ASM SET_TAC[];
          MP_TAC(ISPECL[`X::A topology`; `c::A=>bool`] INTERIOR_OF_SUBSET) THEN
          ASM SET_TAC[]]]];
    REWRITE_TAC[NOT_EXISTS_THM; FORALL_AND_THM]] THEN
  X_GEN_TAC `c::num=>A->bool` THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`subtopology X (k::A=>bool)`; `c::num=>A->bool`]
        COMPACT_SPACE_IMP_NEST) THEN
  ASM_SIMP_TAC[COMPACT_SPACE_SUBTOPOLOGY; CLOSED_IN_SUBSET_TOPSPACE] THEN
  REWRITE_TAC[NOT_IMP] THEN REPEAT CONJ_TAC THENL
   [ASM_MESON_TAC[INTERIOR_OF_SUBSET; CLOSED_IN_SUBSET; MEMBER_NOT_EMPTY;
                  \<subseteq>];
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM SET_TAC[];
    RULE_ASSUM_TAC(REWRITE_RULE[UNIONS_IMAGE; IN_UNIV]) THEN
    REWRITE_TAC[INTERS_GSPEC] THEN ASM SET_TAC[]]);;

lemma baire_category:
   "\<And>X g:(A=>bool)->bool.
        (completely_metrizable_space X \<or>
         locally_compact_space X \<and>
         (Hausdorff_space X \<or> regular_space X)) \<and>
        countable g \<and>
        (\<forall>t. t \<in> g \<Longrightarrow> openin X t \<and> X closure_of t = topspace X)
        \<Longrightarrow> X closure_of \<Inter> g = topspace X"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  ASM_CASES_TAC `g:(A=>bool)->bool = {}` THENL
   [ONCE_REWRITE_TAC[CLOSURE_OF_RESTRICT] THEN
    ASM_SIMP_TAC[INTERS_0; INTER_UNIV; CLOSURE_OF_TOPSPACE];
    ALL_TAC] THEN
  MP_TAC(ISPECL [`X::A topology`;
                 `image (\<lambda>u::A=>bool. topspace X - u) g`]
        BAIRE_CATEGORY_ALT) THEN
  ASM_SIMP_TAC[COUNTABLE_IMAGE; FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE] THEN
  ASM_SIMP_TAC[INTERIOR_OF_COMPLEMENT; DIFF_EQ_EMPTY] THEN
  REWRITE_TAC[INTERIOR_OF_CLOSURE_OF] THEN
  MATCH_MP_TAC(SET_RULE
    `s \<subseteq> u \<and> s' = s \<Longrightarrow> u - s' = {} \<Longrightarrow> s = u`) THEN
  REWRITE_TAC[CLOSURE_OF_SUBSET_TOPSPACE] THEN AP_TERM_TAC THEN
  REWRITE_TAC[DIFF_UNIONS; SET_RULE
   `{f y | y \<in> g ` s} = {f(g x) | x \<in> s}`] THEN
  MATCH_MP_TAC(SET_RULE `t \<subseteq> u \<and> s = t \<Longrightarrow> u \<inter> s = t`) THEN
  CONJ_TAC THENL [ASM_MESON_TAC[INTERS_SUBSET; OPEN_IN_SUBSET]; ALL_TAC] THEN
  AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
   `(\<forall>x. x \<in> s \<Longrightarrow> f x = x) \<Longrightarrow> {f x | x \<in> s} = s`) THEN
  X_GEN_TAC `s::A=>bool` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `s::A=>bool`) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN SET_TAC[]);;


subsection\<open>Sierpinski-Hausdorff type results about countable closed unions\<close>


lemma locally_connected_not_countable_closed_union:
   "\<And>X u:(A=>bool)->bool.
        \<not> (topspace X = {}) \<and>
        connected_space X \<and>
        locally_connected_space X \<and>
        (completely_metrizable_space X \<or>
         locally_compact_space X \<and> Hausdorff_space X) \<and>
        countable u \<and> pairwise disjnt u \<and>
        (\<forall>c. c \<in> u \<Longrightarrow> closedin X c \<and> (c \<noteq> {})) \<and>
        \<Union> u = topspace X
         \<Longrightarrow> u = {topspace X}"
oops
  lemma lemma:
   (`\<Union> (f ` s \<union> g ` s) =
     \<Union> (image (\<lambda>x. f x \<union> g x) s)"
oops
    REWRITE_TAC[UNIONS_UNION; UNIONS_IMAGE] THEN SET_TAC[])
in

  REWRITE_TAC[REAL_CLOSED_IN] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  ABBREV_TAC `v = image (\<lambda>c::A=>bool. X frontier_of c) u` THEN
  ABBREV_TAC `b::A=>bool = \<Union> v` THEN
  MATCH_MP_TAC(TAUT `(\<not> p \<Longrightarrow> False) \<Longrightarrow> p`) THEN DISCH_TAC THEN
  SUBGOAL_THEN `(b::A=>bool) \<subseteq> topspace X` ASSUME_TAC THENL
   [EXPAND_TAC "b" THEN REWRITE_TAC[UNIONS_SUBSET] THEN
    EXPAND_TAC "v" THEN REWRITE_TAC[FORALL_IN_IMAGE] THEN
    REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY; FRONTIER_OF_SUBSET_TOPSPACE];
    ALL_TAC] THEN
  MP_TAC(ISPECL [`subtopology X (b::A=>bool)`; `v:(A=>bool)->bool`]
        BAIRE_CATEGORY_ALT) THEN
  ASM_REWRITE_TAC[] THEN EXPAND_TAC "v" THEN REWRITE_TAC[FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC[COUNTABLE_IMAGE; NOT_IMP] THEN CONJ_TAC THENL
   [ALL_TAC;
    MP_TAC(ISPEC `subtopology X (b::A=>bool)`
        INTERIOR_OF_TOPSPACE) THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
    ASM_SIMP_TAC[TOPSPACE_MTOPOLOGY; SET_RULE
     `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
    DISCH_THEN SUBST1_TAC THEN EXPAND_TAC "b" THEN
    EXPAND_TAC "v" THEN MATCH_MP_TAC(SET_RULE
     `(\<forall>s. s \<in> u \<and> s \<subseteq> \<Union> u \<and> f s = {} \<Longrightarrow> s = {}) \<and>
      \<not> (\<Union> u = {})
      \<Longrightarrow> \<not> (\<Union>(f ` u) = {})`) THEN
    ASM_SIMP_TAC[IMP_CONJ; FRONTIER_OF_EQ_EMPTY; GSYM TOPSPACE_MTOPOLOGY] THEN
    ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN
    X_GEN_TAC `s::A=>bool` THEN REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [CONNECTED_SPACE_CLOPEN_IN]) THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `s::A=>bool`) THEN
    ASM_CASES_TAC `s::A=>bool = {}` THEN ASM_SIMP_TAC[] THEN
    ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN DISCH_THEN SUBST_ALL_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE
     `(u \<noteq> {a}) \<Longrightarrow> a \<in> u \<Longrightarrow> \<exists>b. b \<in> u \<and> (b \<noteq> a)`)) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN `t::A=>bool` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [pairwise]) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`topspace X::A=>bool`; `t::A=>bool`]) THEN
    ASM SET_TAC[]] THEN
  SUBGOAL_THEN `closedin X (b::A=>bool)` ASSUME_TAC THENL
   [SUBGOAL_THEN
     `b = topspace X -
          \<Union> (image (\<lambda>c::A=>bool. X interior_of c) u)`
    SUBST1_TAC THENL
     [MAP_EVERY EXPAND_TAC ["b"; "v"] THEN MATCH_MP_TAC(SET_RULE
       `s \<union> t = u \<and> disjnt s t \<Longrightarrow> s = u - t`) THEN
      CONJ_TAC THENL
       [REWRITE_TAC[GSYM UNIONS_UNION; lemma] THEN
        ONCE_REWRITE_TAC[UNION_COMM] THEN
        REWRITE_TAC[INTERIOR_OF_UNION_FRONTIER_OF] THEN
        FIRST_X_ASSUM(fun th -> GEN_REWRITE_TAC RAND_CONV [SYM th]) THEN
        AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
         `(\<forall>x. x \<in> s \<Longrightarrow> f x = x) \<Longrightarrow> f ` s = s`) THEN
        ASM_SIMP_TAC[CLOSURE_OF_EQ];
        REWRITE_TAC[SET_RULE
         `disjnt (\<Union> s) (\<Union> t) \<longleftrightarrow>
          \<forall>x. x \<in> s \<Longrightarrow> \<forall>y. y \<in> t \<Longrightarrow> disjnt x y`] THEN
        REWRITE_TAC[FORALL_IN_IMAGE] THEN
        X_GEN_TAC `s::A=>bool` THEN DISCH_TAC THEN
        X_GEN_TAC `t::A=>bool` THEN DISCH_TAC THEN
        ASM_CASES_TAC `s::A=>bool = t` THENL
         [ASM_REWRITE_TAC[frontier_of] THEN SET_TAC[];
          FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [pairwise])] THEN
        DISCH_THEN(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`]) THEN
        ASM_SIMP_TAC[frontier_of; CLOSURE_OF_CLOSED_IN] THEN
        MP_TAC(ISPECL [`X::A topology`; `t::A=>bool`]
          INTERIOR_OF_SUBSET) THEN
        SET_TAC[]];
      MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_TOPSPACE] THEN
      MATCH_MP_TAC OPEN_IN_UNIONS THEN
      REWRITE_TAC[FORALL_IN_IMAGE; OPEN_IN_INTERIOR_OF]];
      ALL_TAC] THEN
  CONJ_TAC THENL
   [ASM_MESON_TAC[COMPLETELY_METRIZABLE_SPACE_CLOSED_IN;
                  LOCALLY_COMPACT_SPACE_CLOSED_SUBSET;
                  HAUSDORFF_SPACE_SUBTOPOLOGY];
    ALL_TAC] THEN
  X_GEN_TAC `s::A=>bool` THEN DISCH_TAC THEN CONJ_TAC THENL
   [MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN
    REWRITE_TAC[CLOSED_IN_FRONTIER_OF; FRONTIER_OF_SUBSET_TOPSPACE] THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  REWRITE_TAC[EXTENSION; interior_of; IN_ELIM_THM; NOT_IN_EMPTY] THEN
  X_GEN_TAC `a::A` THEN
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; EXISTS_IN_GSPEC; IN_INTER] THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN `(a::A) \<in> X frontier_of s` ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  SUBGOAL_THEN `(a::A) \<in> s` ASSUME_TAC THENL
   [UNDISCH_TAC `(a::A) \<in> X frontier_of s` THEN
    REWRITE_TAC[frontier_of; IN_DIFF] THEN  ASM_SIMP_TAC[CLOSURE_OF_CLOSED_IN];
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [locally_connected_space]) THEN
  DISCH_THEN(MP_TAC \<circ> GEN_REWRITE_RULE id [NEIGHBOURHOOD_BASE_OF]) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`u::A=>bool`; `a::A`]) THEN
  REWRITE_TAC[GSYM TOPSPACE_MTOPOLOGY; SUBTOPOLOGY_TOPSPACE] THEN
  ASM_REWRITE_TAC[NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`w::A=>bool`; `c::A=>bool`] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`; `w::A=>bool`]
        FRONTIER_OF_OPEN_IN_STRADDLE_INTER) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  STRIP_TAC THEN
  SUBGOAL_THEN `\<exists>t::A=>bool. t \<in> u \<and> (t \<noteq> s) \<and> \<not> (w \<inter> t = {})`
  STRIP_ASSUME_TAC THENL
   [REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`] \<circ>
    GEN_REWRITE_RULE id [pairwise]) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `c::A=>bool`; `t::A=>bool`]
        CONNECTED_IN_INTER_FRONTIER_OF) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  SUBGOAL_THEN
   `X frontier_of (s::A=>bool) \<subseteq> s \<and>
    X frontier_of (t::A=>bool) \<subseteq> t`
  STRIP_ASSUME_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ASM_SIMP_TAC[FRONTIER_OF_SUBSET_CLOSED_IN]);;

lemma real_sierpinski_lemma:
   "        a \<le> b \<and>
        countable u \<and> pairwise disjnt u \<and>
        (\<forall>c. c \<in> u \<Longrightarrow> real_closed c \<and> (c \<noteq> {})) \<and>
        \<Union> u = real_interval[a,b]
         \<Longrightarrow> u = {real_interval[a,b]}"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC `subtopology euclideanreal (real_interval[a,b])`
    LOCALLY_CONNECTED_NOT_COUNTABLE_CLOSED_UNION) THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[REAL_INTERVAL_NE_EMPTY; REAL_POS] THEN
  ASM_SIMP_TAC[CONNECTED_SPACE_SUBTOPOLOGY;
               CONNECTED_IN_EUCLIDEANREAL_INTERVAL;
               LOCALLY_CONNECTED_REAL_INTERVAL] THEN
  CONJ_TAC THENL
   [DISJ1_TAC THEN MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_CLOSED_IN THEN
    REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_EUCLIDEANREAL] THEN
    REWRITE_TAC[GSYM REAL_CLOSED_IN; REAL_CLOSED_REAL_INTERVAL];
    REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSED_IN_SUBSET_TOPSPACE THEN
    ASM_SIMP_TAC[GSYM REAL_CLOSED_IN] THEN ASM SET_TAC[]]);;


subsection\<open>Size bounds on connected or path-connected spaces\<close>


lemma connected_space_imp_card_ge_alt:
   "
        connected_space X \<and> completely_regular_space X \<and>
        closedin X s \<and> (s \<noteq> {}) \<and> (s \<noteq> topspace X)
        \<Longrightarrow> UNIV \<lesssim> topspace X"
oops
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN
  SUBGOAL_THEN `\<exists>a::A. a \<in> topspace X \<and> (a \<notin> s)` STRIP_ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  TRANS_TAC CARD_LE_TRANS `real_interval[0,1]` THEN CONJ_TAC THENL
   [MATCH_MP_TAC CARD_EQ_IMP_LE THEN ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN
    MATCH_MP_TAC CARD_EQ_REAL_SUBSET THEN
    MAP_EVERY EXISTS_TAC [`0::real`; `1::real`] THEN
    ASM_SIMP_TAC[IN_REAL_INTERVAL; REAL_LT_01; REAL_LT_IMP_LE];
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [completely_regular_space]) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`s::A=>bool`; `a::A`]) THEN
  ASM_REWRITE_TAC[LE_C; IN_DIFF; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
  X_GEN_TAC `t::real` THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  FIRST_ASSUM
   (MP_TAC \<circ> SPEC `topspace X::A=>bool` \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
  ASM_REWRITE_TAC[CONNECTED_IN_TOPSPACE] THEN
  REWRITE_TAC[CONNECTED_IN_EUCLIDEANREAL; is_interval] THEN
  REWRITE_TAC[IN_IMAGE] THEN DISCH_THEN MATCH_MP_TAC THEN
  MAP_EVERY EXISTS_TAC [`0::real`; `1::real`] THEN
  REPEAT(FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
  ASM SET_TAC[]);;

lemma connected_space_imp_card_ge_gen:
   "\<And>X s t::A=>bool.
        connected_space X \<and> normal_space X \<and>
        closedin X s \<and> closedin X t \<and>
        (s \<noteq> {}) \<and> (t \<noteq> {}) \<and> disjnt s t
        \<Longrightarrow> UNIV \<lesssim> topspace X"
oops
  REPEAT STRIP_TAC THEN
  TRANS_TAC CARD_LE_TRANS `real_interval[0,1]` THEN CONJ_TAC THENL
   [MATCH_MP_TAC CARD_EQ_IMP_LE THEN ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN
    MATCH_MP_TAC CARD_EQ_REAL_SUBSET THEN
    MAP_EVERY EXISTS_TAC [`0::real`; `1::real`] THEN
    ASM_SIMP_TAC[IN_REAL_INTERVAL; REAL_LT_01; REAL_LT_IMP_LE];
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [NORMAL_SPACE_EQ_URYSOHN]) THEN
  DISCH_THEN(MP_TAC \<circ> SPECL [`s::A=>bool`; `t::A=>bool`]) THEN
  ASM_REWRITE_TAC[LE_C; CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN
  MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
  X_GEN_TAC `t::real` THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  FIRST_ASSUM
   (MP_TAC \<circ> SPEC `topspace X::A=>bool` \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        CONNECTED_IN_CONTINUOUS_MAP_IMAGE)) THEN
  ASM_REWRITE_TAC[CONNECTED_IN_TOPSPACE] THEN
  REWRITE_TAC[CONNECTED_IN_EUCLIDEANREAL; is_interval] THEN
  REWRITE_TAC[IN_IMAGE] THEN DISCH_THEN MATCH_MP_TAC THEN
  MAP_EVERY EXISTS_TAC [`0::real`; `1::real`] THEN
  REPEAT(FIRST_X_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET)) THEN
  ASM SET_TAC[]);;

lemma connected_space_imp_card_ge:
   "        connected_space X \<and> normal_space X \<and>
        (t1_space X \<or> Hausdorff_space X) \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> UNIV \<lesssim> topspace X"
oops
  GEN_TAC THEN REWRITE_TAC[T1_OR_HAUSDORFF_SPACE] THEN STRIP_TAC THEN
  MATCH_MP_TAC CONNECTED_SPACE_IMP_CARD_GE_ALT THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE
   `\<not> (\<exists>a. s \<subseteq> {a}) \<Longrightarrow> \<exists>a b. a \<in> s \<and> b \<in> s \<and> (a \<noteq> b)`)) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `b::A`] THEN STRIP_TAC THEN
  EXISTS_TAC `{a::A}` THEN
  ASM_SIMP_TAC[NORMAL_IMP_COMPLETELY_REGULAR_SPACE_GEN] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[T1_SPACE_CLOSED_IN_SING]; ASM SET_TAC[]]);;

lemma connected_space_imp_infinite_gen:
   "        connected_space X \<and> t1_space X \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> infinite(topspace X)"
oops
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFINITE_PERFECT_SET_GEN THEN
  EXISTS_TAC `X::A topology` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  MATCH_MP_TAC CONNECTED_IN_IMP_PERFECT_GEN THEN
  ASM_REWRITE_TAC[CONNECTED_IN_TOPSPACE] THEN ASM SET_TAC[]);;

lemma connected_space_imp_infinite:
   "        connected_space X \<and> Hausdorff_space X \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> infinite(topspace X)"
oops
    MESON_TAC[CONNECTED_SPACE_IMP_INFINITE_GEN; HAUSDORFF_IMP_T1_SPACE]);;

lemma connected_space_imp_infinite_alt:
   "
        connected_space X \<and> regular_space X \<and>
        closedin X s \<and> (s \<noteq> {}) \<and> (s \<noteq> topspace X)
        \<Longrightarrow> infinite(topspace X)"
oops
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN
  SUBGOAL_THEN `\<exists>a::A. a \<in> topspace X \<and> (a \<notin> s)` STRIP_ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  SUBGOAL_THEN
   `\<exists>u. (\<forall>n. disjnt (u n) s \<and> (a::A) \<in> u n \<and> openin X (u n)) \<and>
        (\<forall>n. u(Suc n) \<subset> u n)`
  STRIP_ASSUME_TAC THENL
   [MATCH_MP_TAC DEPENDENT_CHOICE THEN CONJ_TAC THENL
     [EXISTS_TAC `topspace X - s::A=>bool` THEN
      ASM_SIMP_TAC[IN_DIFF; OPEN_IN_DIFF; OPEN_IN_TOPSPACE] THEN
      SET_TAC[];
      ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [`n::num`; `v::A=>bool`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ>
      GEN_REWRITE_RULE id [GSYM NEIGHBOURHOOD_BASE_OF_CLOSED_IN]) THEN
    REWRITE_TAC[NEIGHBOURHOOD_BASE_OF] THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`v::A=>bool`; `a::A`]) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
    X_GEN_TAC `u::A=>bool` THEN
    DISCH_THEN(X_CHOOSE_THEN `c::A=>bool` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[] THEN
    ASM_CASES_TAC `c::A=>bool = u` THENL
     [FIRST_X_ASSUM SUBST_ALL_TAC; ASM SET_TAC[]] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC `u::A=>bool` \<circ>
        GEN_REWRITE_RULE id [CONNECTED_SPACE_CLOPEN_IN]) THEN
    ASM_REWRITE_TAC[] THEN ASM SET_TAC[];
    SUBGOAL_THEN `\<forall>n. \<exists>x::A. x \<in> u n \<and> (x \<notin> u(Suc n))` MP_TAC THENL
     [ASM SET_TAC[]; REWRITE_TAC[SKOLEM_THM]] THEN
    REWRITE_TAC[INFINITE_CARD_LE; le_c; IN_UNIV; FORALL_AND_THM] THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `f::num=>A` THEN STRIP_TAC THEN
    CONJ_TAC THENL [ASM_MESON_TAC[\<subseteq>; OPEN_IN_SUBSET]; ALL_TAC] THEN
    MATCH_MP_TAC WLOG_LT THEN
    SUBGOAL_THEN `\<forall>m n. m < n \<Longrightarrow> \<not> (f m \<in> u n)` MP_TAC THENL
     [X_GEN_TAC `m::num`; ASM SET_TAC[]] THEN
    REWRITE_TAC[GSYM LE_SUC_LT] THEN
    SUBGOAL_THEN `\<forall>m n. m \<le> n \<Longrightarrow> (u::num=>A->bool) n \<subseteq> u m`
    MP_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM SET_TAC[]]);;

lemma path_connected_space_imp_card_ge:
   "        path_connected_space X \<and> Hausdorff_space X \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> UNIV \<lesssim> topspace X"
oops
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE
   `\<not> (\<exists>a. s \<subseteq> {a}) \<Longrightarrow> \<exists>a b. a \<in> s \<and> b \<in> s \<and> (a \<noteq> b)`)) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `b::A`] THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> SPECL [`a::A`; `b::A`] \<circ>
    REWRITE_RULE[path_connected_space]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::real=>A` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CARD_LE_SUBSET \<circ>
    MATCH_MP PATH_IMAGE_SUBSET_TOPSPACE) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] CARD_LE_TRANS) THEN
  MP_TAC(ISPEC
   `subtopology (X::A topology)
     (image g (topspace (subtopology euclideanreal (real_interval [0,1]))))`
   CONNECTED_SPACE_IMP_CARD_GE) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP PATH_IMAGE_SUBSET_TOPSPACE) THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; TOPSPACE_EUCLIDEANREAL; INTER_UNIV] THEN
  SIMP_TAC[SET_RULE `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  DISCH_TAC THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[CONNECTED_SPACE_SUBTOPOLOGY; CONNECTED_IN_PATH_IMAGE] THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC COMPACT_HAUSDORFF_OR_REGULAR_IMP_NORMAL_SPACE THEN
    ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY] THEN
    ASM_SIMP_TAC[COMPACT_IN_PATH_IMAGE; COMPACT_SPACE_SUBTOPOLOGY];
    MP_TAC ENDS_IN_UNIT_REAL_INTERVAL THEN ASM SET_TAC[]]);;

lemma connected_space_imp_uncountable:
   "        connected_space X \<and> regular_space X \<and> Hausdorff_space X \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> \<not> countable(topspace X)"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC `X::A topology` CONNECTED_SPACE_IMP_CARD_GE) THEN
  ASM_SIMP_TAC[NOT_IMP; CARD_NOT_LE; COUNTABLE_IMP_CARD_LT_REAL] THEN
  MATCH_MP_TAC REGULAR_LINDELOF_IMP_NORMAL_SPACE THEN
  ASM_SIMP_TAC[COUNTABLE_IMP_LINDELOF_SPACE]);;

lemma path_connected_space_imp_uncountable:
   "        path_connected_space X \<and> t1_space X \<and>
        \<not> (\<exists>a. topspace X \<subseteq> {a})
        \<Longrightarrow> \<not> countable(topspace X)"
oops
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP (SET_RULE
   `\<not> (\<exists>a. s \<subseteq> {a}) \<Longrightarrow> \<exists>a b. a \<in> s \<and> b \<in> s \<and> (a \<noteq> b)`)) THEN
  REWRITE_TAC[NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`a::A`; `b::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`a::A`; `b::A`] \<circ>
    REWRITE_RULE[path_connected_space]) THEN
  ASM_REWRITE_TAC[NOT_EXISTS_THM; path_in] THEN
  X_GEN_TAC `g::real=>A` THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [`0::real`; `1::real`;
   `{{x. x \<in> topspace(subtopology euclideanreal (real_interval[0,1])) \<and>
          (g::real=>A) x \<in> {a}} |
     a \<in> topspace X} DELETE {}`] REAL_SIERPINSKI_LEMMA) THEN
  ASM_SIMP_TAC[SIMPLE_IMAGE; COUNTABLE_IMAGE; COUNTABLE_DELETE] THEN
  REWRITE_TAC[IMP_CONJ; FORALL_IN_IMAGE; IN_DELETE] THEN
  REWRITE_TAC[REAL_POS; NOT_IMP] THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC(MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT] PAIRWISE_MONO)
     (SET_RULE `s - {a} \<subseteq> s`)) THEN
    REWRITE_TAC[PAIRWISE_IMAGE] THEN REWRITE_TAC[pairwise] THEN SET_TAC[];
    X_GEN_TAC `x::A` THEN REWRITE_TAC[IMP_IMP] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[REAL_CLOSED_IN] THEN
    MATCH_MP_TAC CLOSED_IN_TRANS_FULL THEN
    EXISTS_TAC `real_interval[0,1]` THEN
    REWRITE_TAC[GSYM REAL_CLOSED_IN; REAL_CLOSED_REAL_INTERVAL] THEN
    FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
        CLOSED_IN_CONTINUOUS_MAP_PREIMAGE)) THEN
    ASM_MESON_TAC[T1_SPACE_CLOSED_IN_SING];
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
    REWRITE_TAC[UNIONS_IMAGE; TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
    REWRITE_TAC[UNIONS_DELETE_EMPTY; UNIONS_IMAGE] THEN ASM SET_TAC[];
    MATCH_MP_TAC(SET_RULE
     `\<forall>a b. a \<in> s \<and> b \<in> s \<and> \<not> (f a = z) \<and> \<not> (f b = z) \<and> \<not> (f a = f b)
            \<Longrightarrow> \<not> (f ` s - {z} = {c})`) THEN
    MAP_EVERY EXISTS_TAC [`a::A`; `b::A`] THEN
    ASM_REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
    MATCH_MP_TAC(SET_RULE `(p \<and> q \<Longrightarrow> r) \<and> p \<and> q \<Longrightarrow> p \<and> q \<and> r`) THEN
    CONJ_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[GSYM MEMBER_NOT_EMPTY]] THEN
    CONJ_TAC THENL [EXISTS_TAC `0::real`; EXISTS_TAC `1::real`] THEN
    ASM_REWRITE_TAC[IN_ELIM_THM; IN_SING] THEN
    REWRITE_TAC[ENDS_IN_REAL_INTERVAL; REAL_INTERVAL_NE_EMPTY; REAL_POS]]);;


subsection\<open>The Tychonoff embedding\<close>


lemma completely_regular_space_cube_embedding_explicit:
   "        completely_regular_space X \<and> Hausdorff_space X
        \<Longrightarrow> embedding_map
             (X,
              product_topology
                (mspace (submetric (cfunspace X real_euclidean_metric)
                  {f. f ` (topspace X) \<subseteq> real_interval [0,1]}))
                (\<lambda>f. subtopology euclideanreal (real_interval [0,1])))
             (\<lambda>x. RESTRICTION
                  (mspace (submetric (cfunspace X real_euclidean_metric)
                    {f. f ` (topspace X) \<subseteq> real_interval [0,1]}))
                  (\<lambda>f. f x))"
oops
  REPEAT STRIP_TAC THEN
  MAP_EVERY ABBREV_TAC
   [`k = mspace(submetric (cfunspace X real_euclidean_metric)
                          {f. image f (topspace X::A=>bool) \<subseteq>
                               real_interval[0,1]})`;
    `e = \<lambda>x. RESTRICTION k (\<lambda>f::A=>real. f x)`] THEN
  SUBGOAL_THEN
   `\<forall>x y. x \<in> topspace X \<and> y \<in> topspace X
          \<Longrightarrow> ((e::A->(A=>real)->real) x = e y \<longleftrightarrow> x = y)`
  ASSUME_TAC THENL
   [MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN STRIP_TAC THEN
    EQ_TAC THEN SIMP_TAC[] THEN GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
    DISCH_TAC THEN EXPAND_TAC "e" THEN REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [completely_regular_space]) THEN
    DISCH_THEN(MP_TAC \<circ> SPECL [`{x::A}`; `y::A`]) THEN
    ASM_SIMP_TAC[IN_DIFF; IN_SING; CLOSED_IN_HAUSDORFF_SING] THEN
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; FORALL_UNWIND_THM2] THEN
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `f::A=>real`THEN REWRITE_TAC[IN_REAL_INTERVAL] THEN STRIP_TAC THEN
    DISCH_THEN(MP_TAC \<circ> C AP_THM `RESTRICTION(topspace X) (f::A=>real)`) THEN
    ASM_REWRITE_TAC[RESTRICTION] THEN COND_CASES_TAC THEN
    ASM_REWRITE_TAC[] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
    FIRST_X_ASSUM(MP_TAC \<circ> check (is_neg \<circ> concl)) THEN
    EXPAND_TAC "k" THEN REWRITE_TAC[SUBMETRIC] THEN
    SIMP_TAC[CFUNSPACE; IN_ELIM_THM; IN_INTER; RESTRICTION_IN_EXTENSIONAL] THEN
    REWRITE_TAC[REAL_EUCLIDEAN_METRIC; IN_UNIV] THEN
    SIMP_TAC[IMAGE_RESTRICTION; RESTRICTION_CONTINUOUS_MAP; SUBSET_REFL] THEN
    ASM_REWRITE_TAC[MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
    ASM_SIMP_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
    REWRITE_TAC[MBOUNDED_REAL_EUCLIDEAN_METRIC; real_bounded] THEN
    EXISTS_TAC `1` THEN REWRITE_TAC[FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC[real_abs];
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM INJECTIVE_ON_ALT])] THEN
  REWRITE_TAC[INJECTIVE_ON_LEFT_INVERSE] THEN
  DISCH_THEN(X_CHOOSE_TAC `e':((A=>real)->real)->A`) THEN
  REWRITE_TAC[embedding_map; HOMEOMORPHIC_MAP_MAPS] THEN
  EXISTS_TAC `e':((A=>real)->real)->A` THEN
  ASM_REWRITE_TAC[homeomorphic_maps; TOPSPACE_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[IN_INTER; IMP_CONJ_ALT; FORALL_IN_IMAGE] THEN CONJ_TAC THENL
   [REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
    REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE; \<subseteq>; FORALL_IN_IMAGE] THEN
    EXPAND_TAC "e" THEN REWRITE_TAC[RESTRICTION_IN_EXTENSIONAL] THEN
    X_GEN_TAC `f::A=>real` THEN SIMP_TAC[RESTRICTION] THEN EXPAND_TAC "k" THEN
    REWRITE_TAC[SUBMETRIC; CFUNSPACE; IN_ELIM_THM] THEN
    SIMP_TAC[IN_ELIM_THM; CONTINUOUS_MAP_IN_SUBTOPOLOGY; ETA_AX; IN_INTER;
             MTOPOLOGY_REAL_EUCLIDEAN_METRIC];
    ALL_TAC] THEN
  REWRITE_TAC[CONTINUOUS_MAP_ATPOINTOF; TOPSPACE_SUBTOPOLOGY] THEN
  REWRITE_TAC[IN_INTER; IMP_CONJ_ALT; FORALL_IN_IMAGE] THEN
  X_GEN_TAC `x::A` THEN ASM_SIMP_TAC[] THEN REPEAT DISCH_TAC THEN
  ASM_REWRITE_TAC[LIMIT_ATPOINTOF] THEN DISCH_THEN(K ALL_TAC) THEN
  X_GEN_TAC `u::A=>bool` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`topspace X - u::A=>bool`; `x::A`] \<circ>
        GEN_REWRITE_RULE id [completely_regular_space]) THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE; IN_DIFF] THEN
  DISCH_THEN(X_CHOOSE_THEN `g::A=>real` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_ALT; EXISTS_IN_GSPEC] THEN
  EXISTS_TAC
   `PiE (k:(A=>real)->bool)
      (\<lambda>f. if f = RESTRICTION (topspace X) g
           then real_interval[0,1] DELETE 1
           else real_interval[0,1])` THEN
  REWRITE_TAC[OPEN_IN_CARTESIAN_PRODUCT_GEN] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
  REPEAT(CONJ_TAC ORELSE DISJ2_TAC) THENL
   [MATCH_MP_TAC FINITE_SUBSET THEN
    EXISTS_TAC `{RESTRICTION (topspace X) (g::A=>real)}` THEN
    REWRITE_TAC[FINITE_SING; \<subseteq>; IN_ELIM_THM; IN_SING] THEN MESON_TAC[];
    REPEAT STRIP_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
    TRY(MATCH_MP_TAC OPEN_IN_HAUSDORFF_DELETE) THEN
    ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY;
                 HAUSDORFF_SPACE_EUCLIDEANREAL] THEN
    MESON_TAC[OPEN_IN_TOPSPACE; TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY];
    ASM_SIMP_TAC[IN_INTER; FUN_IN_IMAGE] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE RAND_CONV
     [TOPSPACE_PRODUCT_TOPOLOGY]) THEN
    REWRITE_TAC[PiE; IN_ELIM_THM; o_THM;
                TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY] THEN
    REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN COND_CASES_TAC THEN
    ASM_SIMP_TAC[IN_DELETE] THEN FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP
     (REAL_ARITH `y = 0 \<Longrightarrow> x = y \<Longrightarrow> (x \<noteq> 1)`)) THEN
    FIRST_X_ASSUM SUBST_ALL_TAC THEN EXPAND_TAC "e" THEN
    REWRITE_TAC[RESTRICTION] THEN ASM_REWRITE_TAC[];
    REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE; IN_DELETE; IN_INTER; IMP_CONJ] THEN
    X_GEN_TAC `y::A` THEN ASM_SIMP_TAC[] THEN DISCH_TAC THEN
    REWRITE_TAC[PiE; IN_ELIM_THM] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC \<circ> SPEC `RESTRICTION (topspace X) (g::A=>real)`)) THEN
    REWRITE_TAC[] THEN EXPAND_TAC "e" THEN REWRITE_TAC[] THEN
    SIMP_TAC[RESTRICTION] THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    ANTS_TAC THENL [EXPAND_TAC "k"; ASM_MESON_TAC[]] THEN
    REWRITE_TAC[SUBMETRIC; CFUNSPACE; IN_ELIM_THM; IN_INTER] THEN
    REWRITE_TAC[RESTRICTION_IN_EXTENSIONAL] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
    SIMP_TAC[RESTRICTION_CONTINUOUS_MAP; SUBSET_REFL] THEN
    ASM_SIMP_TAC[IMAGE_RESTRICTION; SUBSET_REFL] THEN
    ASM_REWRITE_TAC[REAL_EUCLIDEAN_METRIC; MTOPOLOGY_REAL_EUCLIDEAN_METRIC;
                    IN_UNIV] THEN
    MATCH_MP_TAC MBOUNDED_SUBSET THEN EXISTS_TAC `real_interval[0,1]` THEN
    ASM_REWRITE_TAC[MBOUNDED_REAL_EUCLIDEAN_METRIC;
                    REAL_BOUNDED_REAL_INTERVAL]]);;

lemma completely_regular_space_cube_embedding:
   "        completely_regular_space X \<and> Hausdorff_space X
        \<Longrightarrow> \<exists>k:((A=>real)->bool) e.
               embedding_map
                (X,
                 product_topology k
                  (\<lambda>f. subtopology euclideanreal (real_interval[0,1])))
                e"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC \<circ> MATCH_MP
    COMPLETELY_REGULAR_SPACE_CUBE_EMBEDDING_EXPLICIT) THEN
  MESON_TAC[]);;


(* Urysohn and Tietze analogs for completely regular spaces if (()) set is  *)
(* assumed compact instead of closed. Note that Hausdorffness is *not*       *)
text\<open> required: inside () proof we factor through the Kolmogorov quotient.     \<close>


lemma urysohn_completely_regular_closed_compact:
   "\<And>X s (t::A=>bool) a b.
        a \<le> b \<and> completely_regular_space X \<and>
        closedin X s \<and> compactin X t \<and> disjnt s t
        \<Longrightarrow> \<exists>f. continuous_map
                  (X,subtopology euclideanreal (real_interval[a,b])) f \<and>
                (\<forall>x. x \<in> t \<Longrightarrow> f x = a) \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   `\<exists>f. continuous_map
          (X,subtopology euclideanreal (real_interval[0,1])) f \<and>
        (\<forall>x. x \<in> t \<Longrightarrow> f x = 0) \<and>
        (\<forall>x::A. x \<in> s \<Longrightarrow> f x = 1)`
  MP_TAC THENL
   [ALL_TAC;
    REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>] THEN
    REWRITE_TAC[FORALL_IN_IMAGE; IN_REAL_INTERVAL; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `f::A=>real` THEN STRIP_TAC THEN
    EXISTS_TAC `\<lambda>x. a + (b - a) * (f::A=>real) x` THEN
    ASM_SIMP_TAC[] THEN CONJ_TAC THENL [ALL_TAC; REAL_ARITH_TAC] THEN
    ASM_SIMP_TAC[CONTINUOUS_MAP_REAL_ADD; CONTINUOUS_MAP_REAL_LMUL;
                 CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    REWRITE_TAC[IN_REAL_INTERVAL; REAL_LE_ADDR] THEN
    REWRITE_TAC[REAL_ARITH
      `a + (b - a) * y \<le> b \<longleftrightarrow> 0 \<le> (b - a) * (1 - y)`] THEN
    ASM_SIMP_TAC[REAL_LE_MUL; REAL_SUB_LE]] THEN
  ASM_CASES_TAC `t::A=>bool = {}` THENL
   [EXISTS_TAC `(\<lambda>x. 1):A=>real` THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_CONST; NOT_IN_EMPTY] THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEANREAL_SUBTOPOLOGY; IN_REAL_INTERVAL] THEN
    CONV_TAC REAL_RAT_REDUCE_CONV;
    ALL_TAC] THEN
  SUBGOAL_THEN
   `\<forall>a. a \<in> t
        \<Longrightarrow> \<exists>f. continuous_map
                  (X,subtopology euclideanreal (real_interval[0,1])) f \<and>
                f a = 0 \<and> \<forall>x. x \<in> s \<Longrightarrow> (f::A=>real) x = 1`
  MP_TAC THENL
   [REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC \<circ> REWRITE_RULE[completely_regular_space]) THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
    ASM SET_TAC[];
    GEN_REWRITE_TAC (LAND_CONV \<circ> BINDER_CONV) [RIGHT_IMP_EXISTS_THM]] THEN
  REWRITE_TAC[SKOLEM_THM; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::A=>A->real` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [compactin]) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC \<circ> SPEC
    `{{x \<in> topspace X. (g::A=>A->real) a x \<in> {t. t < 1 / 2}} |
      a \<in> t}`)) THEN
  REWRITE_TAC[SIMPLE_IMAGE; EXISTS_FINITE_SUBSET_IMAGE; FORALL_IN_IMAGE] THEN
  ANTS_TAC THENL
   [CONJ_TAC THENL
     [X_GEN_TAC `a::A` THEN DISCH_TAC THEN
      MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
      EXISTS_TAC `euclideanreal` THEN REWRITE_TAC[GSYM REAL_OPEN_IN] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
      ASM_SIMP_TAC[REAL_OPEN_HALFSPACE_LT; ETA_AX];
      MATCH_MP_TAC(SET_RULE
       `(\<forall>a. a \<in> s \<Longrightarrow> a \<in> f a) \<Longrightarrow> s \<subseteq> \<Union>(f ` s)`) THEN
      ASM_SIMP_TAC[IN_ELIM_THM] THEN CONV_TAC REAL_RAT_REDUCE_CONV THEN
      ASM SET_TAC[]];
    DISCH_THEN(X_CHOOSE_THEN `k::A=>bool` MP_TAC)] THEN
  ASM_CASES_TAC `k::A=>bool = {}` THEN
  ASM_REWRITE_TAC[IMAGE_CLAUSES; UNIONS_0; SUBSET_EMPTY] THEN STRIP_TAC THEN
  EXISTS_TAC
   `\<lambda>x. 2 * max 0 (inf {(g::A=>A->real) a x | a \<in> k} - 1 / 2)` THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
  REWRITE_TAC[REAL_ARITH `2 * max 0 (x - 1 / 2) = 0 \<longleftrightarrow> x \<le> 1 / 2`;
              REAL_ARITH `2 * max 0 (x - 1 / 2) = 1 \<longleftrightarrow> x = 1`] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
  REWRITE_TAC[IN_REAL_INTERVAL] THEN
  REWRITE_TAC[REAL_ARITH `0 \<le> 2 * max 0 a`;
              REAL_ARITH  `2 * max 0 (x - 1 / 2) \<le> 1 \<longleftrightarrow> x \<le> 1`] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_MAP_REAL_LMUL THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_MAX THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_REAL_SUB THEN
    REWRITE_TAC[CONTINUOUS_MAP_CONST; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
    MATCH_MP_TAC CONTINUOUS_MAP_INF THEN REWRITE_TAC[ETA_AX] THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN CONJ_TAC THENL
   [X_GEN_TAC `x::A` THEN DISCH_TAC THEN
    MATCH_MP_TAC REAL_INF_LE THEN REWRITE_TAC[EXISTS_IN_GSPEC] THEN
    EXISTS_TAC `0` THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [GSYM MEMBER_NOT_EMPTY]) THEN
    MATCH_MP_TAC MONO_EXISTS THEN X_GEN_TAC `a::A` THEN
    RULE_ASSUM_TAC(REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY;
     \<subseteq>; FORALL_IN_IMAGE; IN_REAL_INTERVAL]) THEN
    ASM SET_TAC[];
    DISCH_TAC] THEN
  CONJ_TAC THEN X_GEN_TAC `x::A` THEN DISCH_TAC THENL
   [MATCH_MP_TAC REAL_INF_LE THEN REWRITE_TAC[EXISTS_IN_GSPEC] THEN
    EXISTS_TAC `0`;
    REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
     [ASM_MESON_TAC[\<subseteq>; CLOSED_IN_SUBSET]; ALL_TAC] THEN
    MATCH_MP_TAC REAL_LE_INF THEN
    ASM_REWRITE_TAC[SIMPLE_IMAGE; IMAGE_EQ_EMPTY; FORALL_IN_IMAGE]] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>;
   FORALL_IN_IMAGE; IN_REAL_INTERVAL; UNIONS_IMAGE; IN_ELIM_THM]) THEN
  REWRITE_TAC[FORALL_IN_GSPEC] THEN
  ASM_MESON_TAC[REAL_LT_IMP_LE; REAL_LE_REFL]);;

lemma urysohn_completely_regular_compact_closed:
   "\<And>X s (t::A=>bool) a b.
        a \<le> b \<and> completely_regular_space X \<and>
        compactin X s \<and> closedin X t \<and> disjnt s t
        \<Longrightarrow> \<exists>f. continuous_map
                  (X,subtopology euclideanreal (real_interval[a,b])) f \<and>
                (\<forall>x. x \<in> t \<Longrightarrow> f x = a) \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
     [`X::A topology`; `t::A=>bool`; `s::A=>bool`;`-b::real`; `-a::real`]
    URYSOHN_COMPLETELY_REGULAR_CLOSED_COMPACT) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; REAL_LE_NEG2] THEN
  ONCE_REWRITE_TAC[DISJOINT_SYM] THEN
  ASM_REWRITE_TAC[FORALL_IN_IMAGE; IN_REAL_INTERVAL] THEN
  REWRITE_TAC[REAL_ARITH `-b \<le> x \<and> x \<le>-a \<longleftrightarrow> a \<le>-x \<and>-x \<le> b`] THEN
  REWRITE_TAC[REAL_ARITH `x::real =-a \<longleftrightarrow>-x = a`] THEN
  DISCH_THEN(X_CHOOSE_THEN `f::A=>real` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `\<lambda>x. --((f::A=>real) x)` THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_REAL_NEG_EQ]);;

lemma urysohn_completely_regular_compact_closed_alt:
   "\<And>X s (t::A=>bool) a b.
        completely_regular_space X \<and>
        compactin X s \<and> closedin X t \<and> disjnt s t
        \<Longrightarrow> \<exists>f. continuous_map X euclideanreal f \<and>
                (\<forall>x. x \<in> t \<Longrightarrow> f x = a) \<and>
                (\<forall>x. x \<in> s \<Longrightarrow> f x = b)"
oops
  REPEAT STRIP_TAC THEN DISJ_CASES_TAC(REAL_ARITH `a \<le> b \<or> b \<le> a`) THENL
   [MP_TAC(ISPECL
     [`X::A topology`; `s::A=>bool`; `t::A=>bool`; `a::real`; `b::real`]
     URYSOHN_COMPLETELY_REGULAR_COMPACT_CLOSED);
    MP_TAC(ISPECL
     [`X::A topology`; `t::A=>bool`; `s::A=>bool`; `b::real`; `a::real`]
     URYSOHN_COMPLETELY_REGULAR_CLOSED_COMPACT)] THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[DISJOINT_SYM] THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN MESON_TAC[]);;

lemma tietze_extension_completely_regular:
   "\<And>X (f::A=>real) s t.
         completely_regular_space X \<and>
         compactin X s \<and> is_interval t \<and> (t \<noteq> {}) \<and>
         continuous_map (subtopology X s,euclideanreal) f \<and>
         (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> t)
         \<Longrightarrow> \<exists>g. continuous_map X euclideanreal g \<and>
                 (\<forall>x. x \<in> topspace X \<Longrightarrow> g x \<in> t) \<and>
                 (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
  lemma lemma:
   "\<And>X (f::A=>real) s t.
           completely_regular_space X \<and> Hausdorff_space X \<and>
           compactin X s \<and> is_interval t \<and> (t \<noteq> {}) \<and>
           continuous_map (subtopology X s,euclideanreal) f \<and>
           (\<forall>x. x \<in> s \<Longrightarrow> f x \<in> t)
           \<Longrightarrow> \<exists>g. continuous_map X euclideanreal g \<and>
                   (\<forall>x. x \<in> topspace X \<Longrightarrow> g x \<in> t) \<and>
                   (\<forall>x. x \<in> s \<Longrightarrow> g x = f x)"
oops
    REPEAT STRIP_TAC THEN
    MP_TAC(ISPEC `X::A topology` COMPLETELY_REGULAR_SPACE_CUBE_EMBEDDING) THEN
    ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`k:((A=>real)->bool)`; `e::A->(A=>real)->real`] THEN
    REWRITE_TAC[embedding_map; HOMEOMORPHIC_MAP_MAPS; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `e':((A=>real)->real)->A` THEN ABBREV_TAC
     `cube:((A=>real)->real)topology =
      product_topology k
       (\<lambda>f. subtopology euclideanreal (real_interval [0,1]))` THEN
    REWRITE_TAC[homeomorphic_maps] THEN STRIP_TAC THEN
    MP_TAC(ISPECL
     [`cube:((A=>real)->real)topology`;
      `(f::A=>real) \<circ> (e':((A=>real)->real)->A)`;
      `image (e::A->(A=>real)->real) s`;
      `t::real=>bool`] TIETZE_EXTENSION_REALINTERVAL) THEN
    ASM_SIMP_TAC[FORALL_IN_IMAGE; o_THM] THEN ANTS_TAC THENL
     [REPEAT CONJ_TAC THENL
       [MATCH_MP_TAC COMPACT_HAUSDORFF_OR_REGULAR_IMP_NORMAL_SPACE THEN
        EXPAND_TAC "cube" THEN
        REWRITE_TAC[COMPACT_SPACE_PRODUCT_TOPOLOGY;
                    HAUSDORFF_SPACE_PRODUCT_TOPOLOGY] THEN
        SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY;
                 HAUSDORFF_SPACE_EUCLIDEANREAL] THEN
        SIMP_TAC[COMPACT_IN_EUCLIDEANREAL_INTERVAL; COMPACT_SPACE_SUBTOPOLOGY];
        MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN THEN CONJ_TAC THENL
         [EXPAND_TAC "cube" THEN
          SIMP_TAC[HAUSDORFF_SPACE_PRODUCT_TOPOLOGY;
                   HAUSDORFF_SPACE_SUBTOPOLOGY;
                   HAUSDORFF_SPACE_EUCLIDEANREAL];
          MATCH_MP_TAC IMAGE_COMPACT_IN THEN EXISTS_TAC `X::A topology` THEN
          ASM_MESON_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY]];
        MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
        EXISTS_TAC `subtopology X (s::A=>bool)` THEN
        ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN CONJ_TAC THENL
         [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ]
            CONTINUOUS_MAP_FROM_SUBTOPOLOGY_MONO)) THEN
          ASM_SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; IMAGE_SUBSET];
          REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN
          MATCH_MP_TAC(SET_RULE
           `(\<forall>x. x \<in> s \<Longrightarrow> f(g x) = x)
            \<Longrightarrow> image f (u \<inter> g ` s) \<subseteq> s`) THEN
          FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
          ASM SET_TAC[]];
        FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
        ASM SET_TAC[]];
      DISCH_THEN(X_CHOOSE_THEN `g:((A=>real)->real)->real`
        STRIP_ASSUME_TAC) THEN
      EXISTS_TAC `(g:((A=>real)->real)->real) \<circ> (e::A->(A=>real)->real)` THEN
      CONJ_TAC THENL
       [ASM_MESON_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; CONTINUOUS_MAP_COMPOSE];
        REWRITE_TAC[o_THM] THEN
        FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP COMPACT_IN_SUBSET_TOPSPACE) THEN
        REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP
          CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE)) THEN
        REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[]]])
in

  REPEAT STRIP_TAC THEN
  ABBREV_TAC `q::A=>bool = image (Kolmogorov_quotient X) (topspace X)` THEN
  MP_TAC(ISPECL
   [`X::A topology`; `euclideanreal`; `f::A=>real`; `s::A=>bool`]
   KOLMOGOROV_QUOTIENT_LIFT_EXISTS) THEN
  SIMP_TAC[HAUSDORFF_IMP_T0_SPACE; HAUSDORFF_SPACE_EUCLIDEANREAL] THEN
  ASM_SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `g::A=>real` THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [`subtopology X (q::A=>bool)`; `g::A=>real`;
    `image (Kolmogorov_quotient X) (s::A=>bool)`;
    `t::real=>bool`]
   lemma) THEN
  ASM_SIMP_TAC[COMPLETELY_REGULAR_SPACE_SUBTOPOLOGY; FORALL_IN_IMAGE] THEN
  REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; SUBTOPOLOGY_SUBTOPOLOGY] THEN
  EXPAND_TAC "q" THEN REWRITE_TAC[IN_INTER; IMP_CONJ_ALT; FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC[COMPACT_IN_SUBSET_TOPSPACE; SET_RULE
   `s \<subseteq> u \<Longrightarrow> f ` u \<inter> f ` s = f ` s`] THEN
  SIMP_TAC[KOLMOGOROV_QUOTIENT_IN_TOPSPACE] THEN
  REWRITE_TAC[IMP_IMP] THEN ANTS_TAC THENL
   [CONJ_TAC THENL
     [MATCH_MP_TAC IMAGE_COMPACT_IN THEN
      EXISTS_TAC `X::A topology` THEN
      ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
      REWRITE_TAC[CONTINUOUS_MAP_KOLMOGOROV_QUOTIENT];
      MATCH_MP_TAC REGULAR_T0_IMP_HAUSDORFF_SPACE THEN
      ASM_SIMP_TAC[REGULAR_SPACE_SUBTOPOLOGY;
                   COMPLETELY_REGULAR_IMP_REGULAR_SPACE] THEN
      EXPAND_TAC "q" THEN REWRITE_TAC[T0_SPACE_KOLMOGOROV_QUOTIENT]];
    DISCH_THEN(X_CHOOSE_THEN `h::A=>real` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC `(h::A=>real) \<circ> Kolmogorov_quotient X` THEN
    ASM_REWRITE_TAC[o_THM] THEN MATCH_MP_TAC CONTINUOUS_MAP_COMPOSE THEN
    EXISTS_TAC `subtopology X (q::A=>bool)` THEN
    ASM_REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; SUBSET_REFL] THEN
    REWRITE_TAC[CONTINUOUS_MAP_KOLMOGOROV_QUOTIENT]]);;


subsection\<open>Embedding in products and hence more about completely metrizable spaces\<close>


lemma gdelta_homeomorphic_space_closedin_product:
   "\<And>X (s::K=>A->bool) k.
        metrizable_space X \<and> (\<forall>i. i \<in> k \<Longrightarrow> openin X(s i))
        \<Longrightarrow> \<exists>t. closedin
                 (prod_topology X (product_topology k (\<lambda>i. euclideanreal)))
                 t \<and>
                 subtopology X (\<Inter> {s i | i \<in> k}) homeomorphic_space
                 subtopology
                  (prod_topology X (product_topology k (\<lambda>i. euclideanreal)))
                  t"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; FORALL_METRIZABLE_SPACE] THEN
  MAP_EVERY X_GEN_TAC [`m::A metric`; `s::K=>A->bool`; `k::K=>bool`] THEN
  DISCH_TAC THEN ASM_CASES_TAC `k::K=>bool = {}` THENL
   [ASM_REWRITE_TAC[NOT_IN_EMPTY; SET_RULE `{f x |x| False} = {}`] THEN
    REWRITE_TAC[INTERS_0; SUBTOPOLOGY_UNIV;
                PRODUCT_TOPOLOGY_EMPTY_DISCRETE] THEN
    EXISTS_TAC
     `(M::A=>bool) \<times> {(\<lambda>x. undefined):K=>real}` THEN
    REWRITE_TAC[CLOSED_IN_CROSS; CLOSED_IN_MSPACE] THEN
    REWRITE_TAC[CLOSED_IN_DISCRETE_TOPOLOGY; SUBSET_REFL] THEN
    REWRITE_TAC[SUBTOPOLOGY_CROSS; SUBTOPOLOGY_MSPACE] THEN
    MATCH_MP_TAC(CONJUNCT1 HOMEOMORPHIC_SPACE_PROD_TOPOLOGY_SING) THEN
    REWRITE_TAC[TOPSPACE_DISCRETE_TOPOLOGY; IN_SING];
    ALL_TAC] THEN
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN `\<forall>i. i \<in> k \<Longrightarrow> (s::K=>A->bool) i \<subseteq> M`
  ASSUME_TAC THENL
   [ASM_MESON_TAC[OPEN_IN_SUBSET; TOPSPACE_MTOPOLOGY]; ALL_TAC] THEN
  SUBGOAL_THEN `\<Inter> {(s::K=>A->bool) i | i \<in> k} \<subseteq> M`
  ASSUME_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN ABBREV_TAC
   `d::K=>A->real =
    \<lambda>i. if (i \<notin> k) \<or> s i = M then \<lambda>a. 1
        else \<lambda>a. inf {d a x |x| x \<in> M - s i}` THEN
  SUBGOAL_THEN
   `\<forall>i. continuous_map (subtopology mtopology (s i),euclideanreal)
        ((d::K=>A->real) i)`
  ASSUME_TAC THENL
   [X_GEN_TAC `i::K` THEN EXPAND_TAC "d" THEN REWRITE_TAC[] THEN
    COND_CASES_TAC THEN REWRITE_TAC[CONTINUOUS_MAP_REAL_CONST] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [DE_MORGAN_THM]) THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET; IMP_CONJ; GSYM TOPSPACE_MTOPOLOGY; SET_RULE
                  `s \<subseteq> u \<Longrightarrow> ((s \<noteq> u) \<longleftrightarrow> \<not> (u - s = {}))`] THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN REPEAT STRIP_TAC THEN
    REWRITE_TAC[GSYM MTOPOLOGY_SUBMETRIC;
                GSYM MTOPOLOGY_REAL_EUCLIDEAN_METRIC] THEN
    MATCH_MP_TAC LIPSCHITZ_CONTINUOUS_IMP_CONTINUOUS_MAP THEN
    REWRITE_TAC[lipschitz_continuous_map; REAL_EUCLIDEAN_METRIC] THEN
    REWRITE_TAC[SUBSET_UNIV; SUBMETRIC] THEN EXISTS_TAC `1::real` THEN
    MAP_EVERY X_GEN_TAC [`x::A`; `y::A`] THEN
    REWRITE_TAC[IN_INTER; REAL_MUL_LID] THEN STRIP_TAC THEN
    EXPAND_TAC "d" THEN REWRITE_TAC[REAL_ARITH
     `abs(x - y) \<le> d \<longleftrightarrow> x - d \<le> y \<and> y - d \<le> x`] THEN
    CONJ_TAC THEN
    W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) REAL_LE_INF_EQ \<circ> snd) THEN
    ASM_SIMP_TAC[SIMPLE_IMAGE; IMAGE_EQ_EMPTY; FORALL_IN_IMAGE; IN_DIFF] THEN
    (ANTS_TAC THENL [ASM_MESON_TAC[MDIST_POS_LE]; DISCH_THEN SUBST1_TAC]) THEN
    X_GEN_TAC `z::A` THEN STRIP_TAC THEN REWRITE_TAC[REAL_LE_SUB_RADD] THENL
     [TRANS_TAC REAL_LE_TRANS `d y::A z`;
      TRANS_TAC REAL_LE_TRANS `d x::A z`] THEN
    (CONJ_TAC THENL
      [MATCH_MP_TAC INF_LE_ELEMENT THEN
       CONJ_TAC THENL [EXISTS_TAC `0`; ASM SET_TAC[]] THEN
       ASM_SIMP_TAC[FORALL_IN_IMAGE; IN_DIFF; MDIST_POS_LE];
       MAP_EVERY UNDISCH_TAC
        [`(x::A) \<in> M`; `(y::A) \<in> M`; `(z::A) \<in> M`] THEN
       CONV_TAC METRIC_ARITH]);
    ALL_TAC] THEN
  SUBGOAL_THEN `\<forall>i x. x \<in> s i \<Longrightarrow> 0 < (d::K=>A->real) i x`
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN EXPAND_TAC "d" THEN REWRITE_TAC[] THEN
    COND_CASES_TAC THEN REWRITE_TAC[REAL_LT_01] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [DE_MORGAN_THM]) THEN
    ASM_SIMP_TAC[OPEN_IN_SUBSET; IMP_CONJ; GSYM TOPSPACE_MTOPOLOGY; SET_RULE
                  `s \<subseteq> u \<Longrightarrow> ((s \<noteq> u) \<longleftrightarrow> \<not> (u - s = {}))`] THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN REPEAT STRIP_TAC THEN
    MP_TAC(ISPECL
     [`m::A metric`; `(s::K=>A->bool) i`] OPEN_IN_MTOPOLOGY) THEN
    ASM_SIMP_TAC[] THEN
    DISCH_THEN(MP_TAC \<circ> SPEC `x::A`) THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[\<subseteq>; IN_MBALL; LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC `r::real` THEN STRIP_TAC THEN
    TRANS_TAC REAL_LTE_TRANS `r::real` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC REAL_LE_INF THEN
    ASM_REWRITE_TAC[FORALL_IN_GSPEC; GSYM REAL_NOT_LT] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> SPEC `i::K`) THEN ASM_REWRITE_TAC[]) THEN
    REPEAT DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN ASM SET_TAC[];
    ALL_TAC] THEN
  ABBREV_TAC `f = \<lambda>x. x,(\<lambda>i\<in>k. inverse((d::K=>A->real) i x))` THEN
  EXISTS_TAC `image (f::A=>A#(K=>real)) (\<Inter> {s(i::K) | i \<in> k})` THEN
  CONJ_TAC THENL
   [ALL_TAC;
    MP_TAC(snd(EQ_IMP_RULE(ISPECL
     [`subtopology mtopology (\<Inter> {(s::K=>A->bool) i | i \<in> k})`;
      `product_topology (k::K=>bool) (\<lambda>i. euclideanreal)`;
      `\<lambda>x. (\<lambda>i\<in>k. inverse((d::K=>A->real) i x))`]
        EMBEDDING_MAP_GRAPH))) THEN
    ASM_REWRITE_TAC[] THEN ANTS_TAC THENL
     [REWRITE_TAC[CONTINUOUS_MAP_COMPONENTWISE; \<subseteq>; FORALL_IN_IMAGE] THEN
      REWRITE_TAC[RESTRICTION_IN_EXTENSIONAL] THEN X_GEN_TAC `i::K` THEN
      SIMP_TAC[RESTRICTION] THEN DISCH_TAC THEN
      MATCH_MP_TAC CONTINUOUS_MAP_REAL_INV THEN CONJ_TAC THENL
       [REWRITE_TAC[ETA_AX] THEN FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP
         (REWRITE_RULE[IMP_CONJ] CONTINUOUS_MAP_FROM_SUBTOPOLOGY_MONO) \<circ>
         SPEC `i::K`) THEN
        ASM SET_TAC[];
        REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; IN_INTER; INTERS_GSPEC] THEN
        ASM_SIMP_TAC[IN_ELIM_THM; REAL_LT_IMP_NZ]];
      DISCH_THEN(MP_TAC \<circ> MATCH_MP EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE) THEN
      MATCH_MP_TAC EQ_IMP THEN AP_TERM_TAC THEN
      ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; TOPSPACE_MTOPOLOGY] THEN
      REWRITE_TAC[PROD_TOPOLOGY_SUBTOPOLOGY; SUBTOPOLOGY_SUBTOPOLOGY] THEN
      AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
       `(\<forall>x. x \<in> s \<Longrightarrow> f x \<in> t) \<Longrightarrow> t \<inter> f ` s = f ` s`) THEN
      SIMP_TAC[TOPSPACE_PRODUCT_TOPOLOGY; o_DEF; TOPSPACE_EUCLIDEANREAL] THEN
      EXPAND_TAC "f" THEN SIMP_TAC[IN_CROSS] THEN
      REWRITE_TAC[RESTRICTION_IN_CARTESIAN_PRODUCT; IN_UNIV]]] THEN
  REWRITE_TAC[GSYM CLOSURE_OF_SUBSET_EQ] THEN CONJ_TAC THENL
   [EXPAND_TAC "f" THEN REWRITE_TAC[\<subseteq>; FORALL_IN_IMAGE] THEN
    REWRITE_TAC[TOPSPACE_PROD_TOPOLOGY; TOPSPACE_PRODUCT_TOPOLOGY] THEN
    REWRITE_TAC[o_DEF; TOPSPACE_EUCLIDEANREAL; IN_CROSS] THEN
    REWRITE_TAC[RESTRICTION_IN_CARTESIAN_PRODUCT; IN_UNIV] THEN
    ASM_REWRITE_TAC[GSYM \<subseteq>; TOPSPACE_MTOPOLOGY];
    ALL_TAC] THEN
  GEN_REWRITE_TAC id [\<subseteq>] THEN REWRITE_TAC[closure_of] THEN
  REWRITE_TAC[FORALL_PAIR_THM; IN_ELIM_THM; TOPSPACE_PROD_TOPOLOGY] THEN
  MAP_EVERY X_GEN_TAC [`x::A`; `ds::K=>real`] THEN
  REWRITE_TAC[IN_CROSS; TOPSPACE_MTOPOLOGY; TOPSPACE_PRODUCT_TOPOLOGY] THEN
  REWRITE_TAC[o_THM; TOPSPACE_EUCLIDEANREAL; IN_UNIV; PiE] THEN
  REWRITE_TAC[IN_ELIM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(MP_TAC \<circ> GENL [`u::A=>bool`; `v:(K=>real)->bool`] \<circ>
    SPEC `(u::A=>bool) \<times> (v:(K=>real)->bool)`) THEN
  REWRITE_TAC[IN_CROSS; OPEN_IN_CROSS; SET_RULE
   `(x \<in> s \<and> y \<in> t) \<and> (s = {} \<or> t = {} \<or> R s t) \<longleftrightarrow>
    x \<in> s \<and> y \<in> t \<and> R s t`] THEN
  REWRITE_TAC[EXISTS_IN_IMAGE] THEN DISCH_TAC THEN
  SUBGOAL_THEN `x \<in> \<Inter> {(s::K=>A->bool) i | i \<in> k}` ASSUME_TAC THENL
   [REWRITE_TAC[INTERS_GSPEC; IN_ELIM_THM] THEN
    X_GEN_TAC `i::K` THEN DISCH_TAC THEN
    GEN_REWRITE_TAC id [TAUT `p \<longleftrightarrow> \<not> p \<Longrightarrow> False`] THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL
     [`mball m (x::A,inverse(abs(ds(i::K)) + 1))`;
      `{z. z \<in> topspace(product_topology k (\<lambda>i. euclideanreal)) \<and>
            (z::K=>real) i \<in> real_interval(ds i - 1,ds i + 1)}`]) THEN
    REWRITE_TAC[IN_ELIM_THM; NOT_IMP] THEN REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC CENTRE_IN_MBALL THEN
      ASM_REWRITE_TAC[REAL_LT_INV_EQ] THEN REAL_ARITH_TAC;
      ASM_REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; TOPSPACE_EUCLIDEANREAL; o_DEF;
                      PiE; IN_ELIM_THM; IN_UNIV];
      REWRITE_TAC[IN_REAL_INTERVAL] THEN REAL_ARITH_TAC;
      REWRITE_TAC[OPEN_IN_MBALL];
      MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
      EXISTS_TAC `euclideanreal` THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION] THEN
      REWRITE_TAC[GSYM REAL_OPEN_IN; REAL_OPEN_REAL_INTERVAL];
      ALL_TAC] THEN
    EXPAND_TAC "f" THEN REWRITE_TAC[INTERS_GSPEC; IN_ELIM_THM] THEN
    REWRITE_TAC[NOT_EXISTS_THM; IN_CROSS; IN_ELIM_THM] THEN
    X_GEN_TAC `y::A` THEN
    DISCH_THEN(CONJUNCTS_THEN2 (MP_TAC \<circ> SPEC `i::K`) ASSUME_TAC) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
    FIRST_X_ASSUM(CONJUNCTS_THEN MP_TAC) THEN
    DISCH_THEN(MP_TAC \<circ> CONJUNCT2) THEN ASM_REWRITE_TAC[RESTRICTION] THEN
    DISCH_TAC THEN ASM_REWRITE_TAC[IN_MBALL] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    REWRITE_TAC[REAL_NOT_LT] THEN
    TRANS_TAC REAL_LE_TRANS `(d::K=>A->real) i y` THEN CONJ_TAC THENL
     [MATCH_MP_TAC REAL_LE_LINV THEN ASM_SIMP_TAC[] THEN
      FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [IN_REAL_INTERVAL]) THEN
      REAL_ARITH_TAC;
      EXPAND_TAC "d" THEN REWRITE_TAC[] THEN
      COND_CASES_TAC THENL [ASM SET_TAC[]; REWRITE_TAC[]] THEN
      MATCH_MP_TAC INF_LE_ELEMENT THEN CONJ_TAC THENL
       [EXISTS_TAC `0` THEN
        ASM_SIMP_TAC[FORALL_IN_GSPEC; IN_DIFF; MDIST_POS_LE];
        REWRITE_TAC[IN_ELIM_THM] THEN EXISTS_TAC `x::A` THEN
        ASM_REWRITE_TAC[IN_DIFF] THEN ASM_MESON_TAC[MDIST_SYM]]];
    REWRITE_TAC[IN_IMAGE] THEN EXISTS_TAC `x::A` THEN
    ASM_REWRITE_TAC[] THEN EXPAND_TAC "f" THEN REWRITE_TAC[PAIR_EQ] THEN
    GEN_REWRITE_TAC id [FUN_EQ_THM] THEN X_GEN_TAC `i::K` THEN
    REWRITE_TAC[RESTRICTION] THEN
    COND_CASES_TAC THENL
     [ALL_TAC;
      RULE_ASSUM_TAC(REWRITE_RULE[EXTENSIONAL]) THEN ASM SET_TAC[]] THEN
    REWRITE_TAC[REAL_ARITH `x = y \<longleftrightarrow> \<not> (0 < abs(x - y))`] THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ>
      MATCH_MP (REWRITE_RULE[IMP_CONJ] CONTINUOUS_MAP_REAL_INV) \<circ>
      SPEC `i::K`) THEN
    ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY; REAL_LT_IMP_NZ; IN_INTER] THEN
    ABBREV_TAC `e = abs (ds i - inverse((d::K=>A->real) i x))` THEN
    REWRITE_TAC[continuous_map] THEN DISCH_THEN(MP_TAC \<circ> SPEC
     `real_interval(inverse((d::K=>A->real) i x) - e / 2,inverse(d i x) + e / 2)` \<circ>
     CONJUNCT2) THEN
    REWRITE_TAC[GSYM REAL_OPEN_IN; REAL_OPEN_REAL_INTERVAL] THEN
    ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; TOPSPACE_MTOPOLOGY] THEN
    REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN
    DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL
     [`u::A=>bool`;
      `{z. z \<in> topspace(product_topology k (\<lambda>i::K. euclideanreal)) \<and>
            z i \<in> real_interval(ds i - e / 2,ds i + e / 2)}`]) THEN
    ASM_REWRITE_TAC[IN_ELIM_THM; NOT_IMP] THEN REPEAT CONJ_TAC THENL
     [FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
       `s = u \<inter> t \<Longrightarrow> x \<in> s \<Longrightarrow>  x \<in> u`)) THEN
      REWRITE_TAC[IN_REAL_INTERVAL; IN_ELIM_THM] THEN
      CONJ_TAC THENL [ASM SET_TAC[]; ASM_REAL_ARITH_TAC];
      REWRITE_TAC[TOPSPACE_PRODUCT_TOPOLOGY; PiE] THEN
      ASM_REWRITE_TAC[o_THM; TOPSPACE_EUCLIDEANREAL; IN_UNIV; IN_ELIM_THM];
      REWRITE_TAC[IN_REAL_INTERVAL] THEN ASM_REAL_ARITH_TAC;
      MATCH_MP_TAC OPEN_IN_CONTINUOUS_MAP_PREIMAGE THEN
      EXISTS_TAC `euclideanreal` THEN
      ASM_SIMP_TAC[CONTINUOUS_MAP_PRODUCT_PROJECTION] THEN
      REWRITE_TAC[GSYM REAL_OPEN_IN; REAL_OPEN_REAL_INTERVAL];
      ALL_TAC] THEN
    EXPAND_TAC "f" THEN REWRITE_TAC[IN_CROSS; IN_ELIM_THM] THEN
    ASM_REWRITE_TAC[RESTRICTION; NOT_EXISTS_THM] THEN X_GEN_TAC `y::A` THEN
    GEN_REWRITE_TAC RAND_CONV [CONJ_ASSOC] THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    FIRST_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (SET_RULE
     `t = u \<inter> s i
      \<Longrightarrow> i \<in> k \<and> (y \<notin> t)
          \<Longrightarrow> y \<in> \<Inter> {s i | i  \<in> k} \<and> y \<in> u \<Longrightarrow> False`)) THEN
    ASM_REWRITE_TAC[IN_ELIM_THM] THEN
    DISCH_THEN(MP_TAC \<circ> CONJUNCT2) THEN
    FIRST_X_ASSUM(MP_TAC \<circ> CONJUNCT2) THEN
    REWRITE_TAC[IN_REAL_INTERVAL] THEN
    EXPAND_TAC "e" THEN REAL_ARITH_TAC]);;

lemma open_homeomorphic_space_closedin_product:
   "\<And>X (s::A=>bool).
        metrizable_space X \<and> openin X s
        \<Longrightarrow> \<exists>t. closedin (prod_topology X euclideanreal) t \<and>
                subtopology X s homeomorphic_space
                subtopology (prod_topology X euclideanreal) t"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `(\<lambda>x. s):1=>A->bool`; `{()}`]
        GDELTA_HOMEOMORPHIC_SPACE_CLOSED_IN_PRODUCT) THEN
  ASM_REWRITE_TAC[SET_RULE `\<Inter> {s.i| i \<in> {a}} = s`] THEN
  DISCH_THEN(X_CHOOSE_THEN `t::A#(1=>real)->bool` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   `prod_topology (X::A topology) (product_topology {()} (\<lambda>i. euclideanreal))
    homeomorphic_space prod_topology X euclideanreal`
  MP_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHIC_SPACE_PROD_TOPOLOGY THEN
    REWRITE_TAC[HOMEOMORPHIC_SPACE_SINGLETON_PRODUCT; HOMEOMORPHIC_SPACE_REFL];
    REWRITE_TAC[HOMEOMORPHIC_SPACE; LEFT_IMP_EXISTS_THM]] THEN
  X_GEN_TAC `f::A#(1=>real)->A#real` THEN DISCH_TAC THEN
  EXISTS_TAC `image (f::A#(1=>real)->A#real) t` THEN CONJ_TAC THENL
   [ASM_MESON_TAC[HOMEOMORPHIC_MAP_CLOSEDNESS_EQ]; ALL_TAC] THEN
  REWRITE_TAC[GSYM HOMEOMORPHIC_SPACE] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC \<circ> MATCH_MP (ONCE_REWRITE_RULE[IMP_CONJ]
      HOMEOMORPHIC_SPACE_TRANS)) THEN
  REWRITE_TAC[HOMEOMORPHIC_SPACE] THEN EXISTS_TAC `f::A#(1=>real)->A#real` THEN
  MATCH_MP_TAC HOMEOMORPHIC_MAP_SUBTOPOLOGIES THEN
  ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP]) THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CLOSED_IN_SUBSET) THEN ASM SET_TAC[]);;

lemma completely_metrizable_space_gdelta_in_alt:
   "
        completely_metrizable_space X \<and>
        (countable intersection_of openin X) s
        \<Longrightarrow> completely_metrizable_space (subtopology X s)"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM; FORALL_INTERSECTION_OF] THEN
  X_GEN_TAC `X::A topology` THEN DISCH_TAC THEN
  X_GEN_TAC `u:(A=>bool)->bool` THEN REPEAT DISCH_TAC THEN
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `(\<lambda>x::A=>bool. x)`; `u:(A=>bool)->bool`]
        GDELTA_HOMEOMORPHIC_SPACE_CLOSED_IN_PRODUCT) THEN
  ASM_SIMP_TAC[COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE; IN_GSPEC] THEN
  DISCH_THEN(X_CHOOSE_THEN `c::A#((A=>bool)->real)->bool` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(SUBST1_TAC \<circ>
    MATCH_MP HOMEOMORPHIC_COMPLETELY_METRIZABLE_SPACE) THEN
  MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_CLOSED_IN THEN
  ASM_REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_PROD_TOPOLOGY] THEN
  REWRITE_TAC[COMPLETELY_METRIZABLE_SPACE_EUCLIDEANREAL;
              COMPLETELY_METRIZABLE_SPACE_PRODUCT_TOPOLOGY] THEN
  ASM_SIMP_TAC[COUNTABLE_RESTRICT]);;

lemma completely_metrizable_space_gdelta_in:
   "
        completely_metrizable_space X \<and> gdelta_in X s
        \<Longrightarrow> completely_metrizable_space (subtopology X s)"
oops
  SIMP_TAC[GDELTA_IN_ALT; COMPLETELY_METRIZABLE_SPACE_GDELTA_IN_ALT]);;

lemma completely_metrizable_space_openin:
   "
        completely_metrizable_space X \<and> openin X s
        \<Longrightarrow> completely_metrizable_space (subtopology X s)"
oops
  SIMP_TAC[COMPLETELY_METRIZABLE_SPACE_GDELTA_IN; OPEN_IMP_GDELTA_IN]);;

lemma locally_compact_imp_completely_metrizable_space:
   "        metrizable_space X \<and> locally_compact_space X
        \<Longrightarrow> completely_metrizable_space X"
oops
  REWRITE_TAC[IMP_CONJ; FORALL_METRIZABLE_SPACE] THEN
  X_GEN_TAC `m::A metric` THEN DISCH_TAC THEN
  MP_TAC(ISPEC `m::A metric` METRIC_COMPLETION) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`m':(A=>real)metric`; `f::A=>A->real`] THEN
  STRIP_TAC THEN
  SUBGOAL_THEN
   `mtopology homeomorphic_space
    subtopology (mtopology m') (image (f::A=>A->real) (M))`
  ASSUME_TAC THENL
   [MP_TAC(ISPECL [`m::A metric`; `m':(A=>real)metric`; `f::A=>A->real`]
        ISOMETRY_IMP_EMBEDDING_MAP) THEN
    ASM_SIMP_TAC[SUBSET_REFL] THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP EMBEDDING_MAP_IMP_HOMEOMORPHIC_SPACE) THEN
    REWRITE_TAC[TOPSPACE_MTOPOLOGY];
    ALL_TAC] THEN
  FIRST_ASSUM(SUBST1_TAC \<circ>
    MATCH_MP HOMEOMORPHIC_COMPLETELY_METRIZABLE_SPACE) THEN
  FIRST_X_ASSUM(MP_TAC \<circ>
    MATCH_MP HOMEOMORPHIC_LOCALLY_COMPACT_SPACE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC \<circ> MATCH_MP
   (ONCE_REWRITE_RULE[IMP_CONJ_ALT] (REWRITE_RULE[CONJ_ASSOC]
        LOCALLY_COMPACT_SUBSPACE_OPEN_IN_CLOSURE_OF))) THEN
  ASM_REWRITE_TAC[HAUSDORFF_SPACE_MTOPOLOGY; SUBTOPOLOGY_MSPACE] THEN
  ASM_REWRITE_TAC[TOPSPACE_MTOPOLOGY] THEN DISCH_TAC THEN
  MATCH_MP_TAC COMPLETELY_METRIZABLE_SPACE_OPEN_IN THEN
  ASM_SIMP_TAC[COMPLETELY_METRIZABLE_SPACE_MTOPOLOGY]);;

lemma completely_metrizable_space_imp_gdelta_in:
   "
        metrizable_space X \<and> s \<subseteq> topspace X \<and>
        completely_metrizable_space (subtopology X s)
        \<Longrightarrow> gdelta_in X s"
oops
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`;
                 `subtopology X s::A topology`; `\<lambda>x::A. x`]
        LAVRENTIEV_EXTENSION) THEN
  ASM_REWRITE_TAC[CONTINUOUS_MAP_ID; LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [`u::A=>bool`; `f::A=>A`] THEN STRIP_TAC THEN
  SUBGOAL_THEN `s::A=>bool = u` (fun th -> ASM_REWRITE_TAC[th]) THEN
  ASM_REWRITE_TAC[GSYM SUBSET_ANTISYM_EQ] THEN
  FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CONTINUOUS_MAP_IMAGE_SUBSET_TOPSPACE) THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET; GDELTA_IN_SUBSET] THEN
  MATCH_MP_TAC(SET_RULE
    `(\<forall>x. x \<in> u \<Longrightarrow> f x = x) \<Longrightarrow> f ` u \<subseteq> s \<Longrightarrow> u \<subseteq> s`) THEN
  MP_TAC(ISPECL
   [`subtopology X u::A topology`; `subtopology X u::A topology`;
   `f::A=>A`; `\<lambda>x::A. x`] FORALL_IN_CLOSURE_OF_EQ) THEN
  ASM_SIMP_TAC[CLOSURE_OF_SUBTOPOLOGY; CONTINUOUS_MAP_ID; SET_RULE
   `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  ANTS_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  ASM_SIMP_TAC[HAUSDORFF_SPACE_SUBTOPOLOGY;
               METRIZABLE_IMP_HAUSDORFF_SPACE] THEN
  UNDISCH_TAC
   `continuous_map (subtopology X u,subtopology X s) (f::A=>A)` THEN
  SIMP_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY] THEN ASM SET_TAC[]);;

lemma completely_metrizable_space_eq_gdelta_in:
   "
        completely_metrizable_space X \<and> s \<subseteq> topspace X
        \<Longrightarrow> (completely_metrizable_space (subtopology X s) \<longleftrightarrow>
             gdelta_in X s)"
oops
  MESON_TAC[COMPLETELY_METRIZABLE_SPACE_GDELTA_IN;
            COMPLETELY_METRIZABLE_SPACE_IMP_GDELTA_IN;
            COMPLETELY_METRIZABLE_IMP_METRIZABLE_SPACE]);;

lemma gdelta_in_eq_completely_metrizable_space:
   "
        completely_metrizable_space X
        \<Longrightarrow> (gdelta_in X s \<longleftrightarrow>
             s \<subseteq> topspace X \<and>
             completely_metrizable_space (subtopology X s))"
oops
  MESON_TAC[GDELTA_IN_ALT; COMPLETELY_METRIZABLE_SPACE_EQ_GDELTA_IN]);;


text\<open> Basic definition of the small inductive dimension relation ind t \<le> n.    \<close>
text\<open> We plan to prove most of the theorems in R^n so this is as good a         \<close>
text\<open> definition as any other, but the present stuff works in any X space.    \<close>


parse_as_infix("dimension_le",(12,"right"));;

let DIMENSION_LE_RULES,DIMENSION_LE_INDUCT,DIMENSION_LE_CASES =
  new_inductive_definition
  `\<forall>X n.-1 \<le> n \<and>
           (\<forall>v a. openin X v \<and> a \<in> v
                  \<Longrightarrow> \<exists>u. a \<in> u \<and> u \<subseteq> v \<and> openin X u \<and>
                          subtopology X (X frontier_of u)
                          dimension_le (n - 1))
            \<Longrightarrow> (X::A topology) dimension_le (n::int)`;;

lemma dimension_le_neighbourhood_base:
   "\<And>(X::A topology) n.
        X dimension_le n \<longleftrightarrow>
 -1 \<le> n \<and>
        neighbourhood_base_of
         (\<lambda>u. openin X u \<and>
              (subtopology X (X frontier_of u))
              dimension_le (n - 1)) X"
oops
  REPEAT GEN_TAC THEN SIMP_TAC[OPEN_NEIGHBOURHOOD_BASE_OF] THEN
  GEN_REWRITE_TAC LAND_CONV [DIMENSION_LE_CASES] THEN MESON_TAC[]);;

lemma dimension_le_bound:
   "\<And>X: Atopology n. X dimension_le n \<Longrightarrow>-1 \<le> n"
oops
  MATCH_MP_TAC DIMENSION_LE_INDUCT THEN SIMP_TAC[]);;

lemma dimension_le_mono:
   "\<And>X: Atopology m n. X dimension_le m \<and> m \<le> n \<Longrightarrow> X dimension_le n"
oops
  REWRITE_TAC[IMP_CONJ; RIGHT_FORALL_IMP_THM] THEN
  MATCH_MP_TAC DIMENSION_LE_INDUCT THEN
  MAP_EVERY X_GEN_TAC [`X: Atopology`; `m::int`] THEN STRIP_TAC THEN
  X_GEN_TAC `n::int` THEN DISCH_TAC THEN
  GEN_REWRITE_TAC id [DIMENSION_LE_CASES] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[INT_LE_TRANS]; ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [`v::A=>bool`; `a::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`v::A=>bool`; `a::A`]) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC MONO_EXISTS THEN
  GEN_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_INT_ARITH_TAC);;

lemma dimension_le_eq_empty:
   "\<And>X: Atopology. X dimension_le (-1) \<longleftrightarrow> topspace X = {}"
oops
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[DIMENSION_LE_CASES] THEN
  CONV_TAC INT_REDUCE_CONV THEN
  SUBGOAL_THEN `\<forall>X::A topology. \<not> (X dimension_le -- 2)`
   (fun th -> REWRITE_TAC[th])
  THENL
   [GEN_TAC THEN DISCH_THEN(MP_TAC \<circ> MATCH_MP DIMENSION_LE_BOUND) THEN
    INT_ARITH_TAC;
    EQ_TAC THENL
     [DISCH_THEN(MP_TAC \<circ> SPEC `topspace X::A=>bool`) THEN
      REWRITE_TAC[OPEN_IN_TOPSPACE] THEN SET_TAC[];
      REPEAT STRIP_TAC THEN
      FIRST_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN
      ASM SET_TAC[]]]);;

lemma dimension_le_0_neighbourhood_base_of_clopen:
   "        X dimension_le 0 \<longleftrightarrow>
        neighbourhood_base_of (\<lambda>u. closedin X u \<and> openin X u) X"
oops
  GEN_TAC THEN GEN_REWRITE_TAC LAND_CONV [DIMENSION_LE_NEIGHBOURHOOD_BASE] THEN
  CONV_TAC INT_REDUCE_CONV THEN
  REWRITE_TAC[DIMENSION_LE_EQ_EMPTY; TOPSPACE_SUBTOPOLOGY] THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  SIMP_TAC[FRONTIER_OF_SUBSET_TOPSPACE; SET_RULE
   `s \<subseteq> u \<Longrightarrow> u \<inter> s = s`] THEN
  MESON_TAC[FRONTIER_OF_EQ_EMPTY; OPEN_IN_SUBSET]);;

lemma dimension_le_subtopology:
   "\<And>X n s::A=>bool.
        X dimension_le n \<Longrightarrow> (subtopology X s) dimension_le n"
oops
  REWRITE_TAC[RIGHT_FORALL_IMP_THM] THEN MATCH_MP_TAC DIMENSION_LE_INDUCT THEN
  MAP_EVERY X_GEN_TAC [`X::A topology`; `n::int`] THEN STRIP_TAC THEN
  X_GEN_TAC `s::A=>bool` THEN GEN_REWRITE_TAC id [DIMENSION_LE_CASES] THEN
  ASM_REWRITE_TAC[] THEN MAP_EVERY X_GEN_TAC [`u':A=>bool`; `a::A`] THEN
  GEN_REWRITE_TAC (LAND_CONV \<circ> LAND_CONV) [OPEN_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[IMP_CONJ; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `u::A=>bool` THEN DISCH_TAC THEN DISCH_THEN SUBST1_TAC THEN
  REWRITE_TAC[IN_INTER] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`u::A=>bool`; `a::A`]) THEN
  ASM_REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `v::A=>bool` THEN STRIP_TAC THEN
  EXISTS_TAC `s \<inter> v::A=>bool` THEN
  ASM_REWRITE_TAC[IN_INTER] THEN REPEAT CONJ_TAC THENL
   [ASM SET_TAC[];
    REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN ASM_MESON_TAC[INTER_COMM];
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC
     `subtopology X s frontier_of (s \<inter> v):A=>bool`) THEN
    REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
    MATCH_MP_TAC EQ_IMP THEN AP_THM_TAC THEN AP_TERM_TAC THEN
    AP_TERM_TAC THEN MATCH_MP_TAC(SET_RULE
     `s \<subseteq> u \<and> s \<subseteq> t \<Longrightarrow> t \<inter> s = u \<inter> s`) THEN
    REWRITE_TAC[FRONTIER_OF_SUBSET_SUBTOPOLOGY] THEN
    REWRITE_TAC[FRONTIER_OF_CLOSURES; CLOSURE_OF_SUBTOPOLOGY] THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY; INTER_ASSOC] THEN
    MATCH_MP_TAC(SET_RULE
     `t \<subseteq> u \<and> v \<subseteq> w
      \<Longrightarrow> s \<inter> t \<inter> s \<inter> v \<subseteq> u \<inter> w`) THEN
    CONJ_TAC THEN MATCH_MP_TAC CLOSURE_OF_MONO THEN SET_TAC[]]);;

lemma dimension_le_subtopologies:
   "\<And>X n s t::A=>bool.
        s \<subseteq> t \<and>
        subtopology X t dimension_le n
        \<Longrightarrow> (subtopology X s) dimension_le n"
oops
  REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC \<circ>
    ISPEC `s::A=>bool` \<circ> MATCH_MP DIMENSION_LE_SUBTOPOLOGY) THEN
  REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
  ASM_SIMP_TAC[SET_RULE `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`]);;

lemma dimension_le_eq_subtopology:
   "\<And>X s::A=>bool n.
        (subtopology X s) dimension_le n \<longleftrightarrow>
 -1 \<le> n \<and>
        \<forall>v a. openin X v \<and> a \<in> v \<and> a \<in> s
              \<Longrightarrow> \<exists>u. a \<in> u \<and> u \<subseteq> v \<and> openin X u \<and>
                      subtopology X
                       ((subtopology X s frontier_of (s \<inter> u)))
                      dimension_le (n - 1)"
oops
  REPEAT GEN_TAC THEN
  GEN_REWRITE_TAC LAND_CONV [DIMENSION_LE_CASES] THEN
  REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY; OPEN_IN_SUBTOPOLOGY] THEN
  REWRITE_TAC[LEFT_AND_EXISTS_THM; LEFT_IMP_EXISTS_THM] THEN
  ONCE_REWRITE_TAC[MESON[]
   `(\<forall>v a t. (P t \<and> Q v t) \<and> R a v t \<Longrightarrow> S a v t) \<longleftrightarrow>
    (\<forall>t a v. Q v t \<Longrightarrow> P t \<and> R a v t \<Longrightarrow> S a v t)`] THEN
  REWRITE_TAC[FORALL_UNWIND_THM2] THEN AP_TERM_TAC THEN
  AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `v::A=>bool` THEN REWRITE_TAC[] THEN
  AP_TERM_TAC THEN GEN_REWRITE_TAC id [FUN_EQ_THM] THEN
  X_GEN_TAC `a::A` THEN REWRITE_TAC[IN_INTER] THEN
  MATCH_MP_TAC(TAUT `(p \<Longrightarrow> (q \<longleftrightarrow> r)) \<Longrightarrow> (p \<Longrightarrow> q \<longleftrightarrow> p \<Longrightarrow> r)`) THEN
  STRIP_TAC THEN REWRITE_TAC[RIGHT_AND_EXISTS_THM] THEN
  GEN_REWRITE_TAC LAND_CONV [SWAP_EXISTS_THM] THEN
  ONCE_REWRITE_TAC[TAUT
    `p \<and> q \<and> (r \<and> s) \<and> t \<longleftrightarrow> s \<and> p \<and> q \<and> r \<and> t`] THEN
  ASM_REWRITE_TAC[UNWIND_THM2; IN_INTER] THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `u \<inter> v::A=>bool` THEN
  ASM_SIMP_TAC[IN_INTER; OPEN_IN_INTER] THEN
  (CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
  ASM_SIMP_TAC[SET_RULE `u \<subseteq> v \<Longrightarrow> u \<inter> v = u`;
               SET_RULE `u \<inter> s \<subseteq> v \<inter> s
                         \<Longrightarrow> s \<inter> u \<inter> v = s \<inter> u`] THEN
  POP_ASSUM_LIST(MP_TAC \<circ> end_itlist CONJ \<circ> rev) THEN
  ASM_SIMP_TAC[FRONTIER_OF_SUBSET_SUBTOPOLOGY;
               SET_RULE `v \<subseteq> u \<Longrightarrow> u \<inter> v = v`] THEN
  STRIP_TAC THEN ONCE_REWRITE_TAC[INTER_COMM] THEN ASM_REWRITE_TAC[]);;

lemma homeomorphic_space_dimension_le:
   "\<And>(X::A topology) (X':B topology) n.
        X homeomorphic_space X'
        \<Longrightarrow> (X dimension_le n \<longleftrightarrow> X' dimension_le n)"
oops
  lemma lemma:
   "\<And>n (X::A topology) (X':B topology).
        X homeomorphic_space X' \<and> X dimension_le (n - 1)
        \<Longrightarrow> X' dimension_le (n - 1)"
oops
    INDUCT_TAC THENL
     [CONV_TAC INT_REDUCE_CONV THEN REWRITE_TAC[DIMENSION_LE_EQ_EMPTY] THEN
      MESON_TAC[HOMEOMORPHIC_EMPTY_SPACE];
      REWRITE_TAC[GSYM INT_OF_NUM_SUC; INT_ARITH `(x + y) - y::int = x`]] THEN
    MAP_EVERY X_GEN_TAC [`X::A topology`; `X':B topology`] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    ONCE_REWRITE_TAC[DIMENSION_LE_CASES] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [homeomorphic_space]) THEN
    REWRITE_TAC[LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [`f::A=>B`; `g::B=>A`] THEN STRIP_TAC THEN
    MAP_EVERY X_GEN_TAC [`v::B=>bool`; `b::B`] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`image (g::B=>A) v`; `(g::B=>A) b`]) THEN
    ANTS_TAC THENL
     [ASM_MESON_TAC[HOMEOMORPHIC_MAPS_MAP; HOMEOMORPHIC_IMP_OPEN_MAP;
                    open_map; FUN_IN_IMAGE];
      DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC)] THEN
    EXISTS_TAC `image f u` THEN REPEAT CONJ_TAC THENL
     [REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
      RULE_ASSUM_TAC(REWRITE_RULE[homeomorphic_maps; continuous_map]) THEN
      ASM SET_TAC[];
      REPEAT(FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET)) THEN
      RULE_ASSUM_TAC(REWRITE_RULE[homeomorphic_maps; continuous_map]) THEN
      ASM SET_TAC[];
      ASM_MESON_TAC[HOMEOMORPHIC_MAPS_MAP; HOMEOMORPHIC_MAP_OPENNESS_EQ];
      FIRST_X_ASSUM MATCH_MP_TAC THEN
      EXISTS_TAC `subtopology X (X frontier_of u::A=>bool)` THEN
      ASM_REWRITE_TAC[homeomorphic_space] THEN
      MAP_EVERY EXISTS_TAC [`f::A=>B`; `g::B=>A`] THEN
      MATCH_MP_TAC HOMEOMORPHIC_MAPS_SUBTOPOLOGIES THEN
      ASM_SIMP_TAC[FRONTIER_OF_SUBSET_TOPSPACE; SET_RULE
       `s \<subseteq> t \<Longrightarrow> t \<inter> s = s`] THEN
      CONV_TAC SYM_CONV THEN MATCH_MP_TAC HOMEOMORPHIC_MAP_FRONTIER_OF THEN
      ASM_MESON_TAC[OPEN_IN_SUBSET; HOMEOMORPHIC_MAPS_MAP]])
in

  REPEAT STRIP_TAC THEN ASM_CASES_TAC `-1::int \<le> n` THENL
   [ALL_TAC; ASM_MESON_TAC[DIMENSION_LE_BOUND]] THEN
  SUBST1_TAC(INT_ARITH `n::int = (Suc n) - 1`) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> MATCH_MP
   (INT_ARITH `-x::int \<le> y \<Longrightarrow> 0 \<le> y + x`)) THEN
  REWRITE_TAC[GSYM INT_OF_NUM_EXISTS; LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC `n::num` THEN DISCH_THEN SUBST1_TAC THEN
  EQ_TAC THEN MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ] lemma) THEN
  ASM_MESON_TAC[HOMEOMORPHIC_SPACE_SYM]);;

lemma dimension_le_retraction_map_image:
   "\<And>X X' n (r::A=>B).
        retraction_map X X' r \<and> X dimension_le n
        \<Longrightarrow> X' dimension_le n"
oops
  GEN_REWRITE_TAC id [MESON[] `(\<forall>x y z. P x y z) \<longleftrightarrow> (\<forall>z x y. P x y z)`] THEN
  GEN_TAC THEN MATCH_MP_TAC HEREDITARY_IMP_RETRACTIVE_PROPERTY THEN
  REWRITE_TAC[DIMENSION_LE_SUBTOPOLOGY; HOMEOMORPHIC_SPACE_DIMENSION_LE]);;

lemma dimension_le_discrete_topology:
   "\<And>u::A=>bool. (discrete_topology u) dimension_le 0"
oops
  GEN_TAC THEN ONCE_REWRITE_TAC[DIMENSION_LE_CASES] THEN
  CONV_TAC INT_REDUCE_CONV THEN
  REWRITE_TAC[OPEN_IN_DISCRETE_TOPOLOGY; DISCRETE_TOPOLOGY_FRONTIER_OF] THEN
  REWRITE_TAC[DIMENSION_LE_EQ_EMPTY; TOPSPACE_SUBTOPOLOGY; INTER_EMPTY] THEN
  SET_TAC[]);;

lemma zero_dimensional_imp_completely_regular_space:
   "X dimension_le 0 \<Longrightarrow> completely_regular_space X"
oops
  GEN_TAC THEN REWRITE_TAC[DIMENSION_LE_0_NEIGHBOURHOOD_BASE_OF_CLOPEN] THEN
  SIMP_TAC[OPEN_NEIGHBOURHOOD_BASE_OF] THEN DISCH_TAC THEN
  REWRITE_TAC[completely_regular_space; IN_DIFF] THEN
  MAP_EVERY X_GEN_TAC [`c::A=>bool`; `a::A`] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPECL [`topspace X - c::A=>bool`; `a::A`]) THEN
  ASM_SIMP_TAC[IN_DIFF; OPEN_IN_DIFF; OPEN_IN_TOPSPACE] THEN
  DISCH_THEN(X_CHOOSE_THEN `u::A=>bool` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC `(\<lambda>x. if x \<in> u then 0 else 1):A=>real` THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
  REWRITE_TAC[CONTINUOUS_MAP_IN_SUBTOPOLOGY; \<subseteq>; FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC; ASM_MESON_TAC[ENDS_IN_UNIT_REAL_INTERVAL]] THEN
  REWRITE_TAC[continuous_map; TOPSPACE_EUCLIDEANREAL; IN_UNIV] THEN
  X_GEN_TAC `r::real=>bool` THEN DISCH_TAC THEN REWRITE_TAC[TAUT
    `(if p then a else b) \<in> r \<longleftrightarrow> p \<and> a \<in> r \<or> \<not> p \<and> b \<in> r`] THEN
  MAP_EVERY ASM_CASES_TAC [`(0::real) \<in> r`; `(1::real) \<in> r`] THEN
  ASM_REWRITE_TAC[EMPTY_GSPEC; OPEN_IN_EMPTY; OPEN_IN_TOPSPACE;
                  IN_GSPEC; TAUT `p \<or> \<not> p`] THEN
  ASM_REWRITE_TAC[GSYM -; GSYM \<inter>] THEN
  ASM_SIMP_TAC[OPEN_IN_TOPSPACE; OPEN_IN_INTER; OPEN_IN_DIFF]);;

lemma zero_dimensional_imp_regular_space:
   "X dimension_le 0 \<Longrightarrow> regular_space X"
oops
  MESON_TAC[COMPLETELY_REGULAR_IMP_REGULAR_SPACE;
            ZERO_DIMENSIONAL_IMP_COMPLETELY_REGULAR_SPACE]);;


text\<open> Theorems from Kuratowski's "Remark on an Invariance Theorem", Fundamenta  \<close>
(* Mathematicae vol 37 (1950), pp. 251-252. The idea is that in suitable     *)
(* spaces, to show "number of components of the complement" (without         *)
(* distinguishing orders of infinity) is a homeomorphic invariant, it        *)
text\<open> suffices to show it for closed subsets. Kuratowski states the main result \<close>
text\<open> for a "locally connected continuum", and seems clearly to be implicitly   \<close>
text\<open> assuming that means metrizable. We call out the general topological       \<close>
text\<open> hypotheses more explicitly, which do not however include connectedness.   \<close>


lemma separation_by_closed_intermediates_count:
   "\<And>(X::A topology) s n.
        hereditarily normal_space X \<and>
        (\<exists>u. u HAS_SIZE n \<and>
             pairwise (separatedin X) u \<and>
             (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
             \<Union> u = topspace X - s)
        \<Longrightarrow>  \<exists>c. closedin X c \<and> c \<subseteq> s \<and>
                 \<forall>d. closedin X d \<and> c \<subseteq> d \<and> d \<subseteq> s
                     \<Longrightarrow> \<exists>u. u HAS_SIZE n \<and>
                             pairwise (separatedin X) u \<and>
                             (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
                             \<Union> u = topspace X - d"
oops
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC
   (X_CHOOSE_THEN `u:(A=>bool)->bool` STRIP_ASSUME_TAC)) THEN
  FIRST_X_ASSUM(MP_TAC \<circ> SPEC `u:(A=>bool)->bool` \<circ>
    GEN_REWRITE_RULE id [HEREDITARILY_NORMAL_SEPARATION_PAIRWISE]) THEN
  ASM_REWRITE_TAC[] THEN ANTS_TAC THENL
   [CONJ_TAC THENL [ASM_MESON_TAC[HAS_SIZE]; ASM SET_TAC[]];
    DISCH_THEN(X_CHOOSE_THEN `f:(A=>bool)->(A=>bool)` STRIP_ASSUME_TAC)] THEN
  EXISTS_TAC
   `topspace X - \<Union> (image (f:(A=>bool)->(A=>bool)) u)` THEN
  ASM_SIMP_TAC[CLOSED_IN_DIFF; CLOSED_IN_TOPSPACE; OPEN_IN_UNIONS;
               FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  X_GEN_TAC `c::A=>bool` THEN STRIP_TAC THEN
  EXISTS_TAC `image (\<lambda>s. (f:(A=>bool)->(A=>bool)) s - c) u` THEN
  REWRITE_TAC[PAIRWISE_IMAGE; FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC[pairwise; SEPARATED_IN_OPEN_SETS; OPEN_IN_DIFF] THEN
  MATCH_MP_TAC(TAUT `d \<and> c \<and> b \<and> (c \<Longrightarrow> a) \<Longrightarrow> a \<and> b \<and> c \<and> d`) THEN
  REPEAT CONJ_TAC THENL
   [RULE_ASSUM_TAC(REWRITE_RULE[UNIONS_IMAGE; OPEN_IN_CLOSED_IN_EQ]) THEN
    REWRITE_TAC[UNIONS_IMAGE] THEN ASM SET_TAC[];
    ASM SET_TAC[];
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [pairwise]) THEN
    REWRITE_TAC[] THEN ASM SET_TAC[];
    STRIP_TAC THEN MATCH_MP_TAC HAS_SIZE_IMAGE_INJ THEN
    ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [pairwise]) THEN
    ASM SET_TAC[]]);;

lemma separation_by_closed_intermediates_gen:
   "\<And>(X::A topology) s.
        hereditarily normal_space X \<and>
        \<not> connectedin X (topspace X - s)
        \<Longrightarrow>  \<exists>c. closedin X c \<and> c \<subseteq> s \<and>
                 \<forall>d. closedin X d \<and> c \<subseteq> d \<and> d \<subseteq> s
                     \<Longrightarrow> \<not> connectedin X (topspace X - d)"
oops
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`; `2`]
    SEPARATION_BY_CLOSED_INTERMEDIATES_COUNT) THEN
  REWRITE_TAC[MESON[HAS_SIZE_CONV `s HAS_SIZE 2`]
   `(\<exists>s. s HAS_SIZE 2 \<and> P s) \<longleftrightarrow> (\<exists>a b. (a \<noteq> b) \<and> P{a,b})`] THEN
  REWRITE_TAC[PAIRWISE_INSERT; UNIONS_2; FORALL_IN_INSERT; NOT_IN_EMPTY;
              IMP_CONJ; NOT_IN_EMPTY; PAIRWISE_EMPTY] THEN
  REWRITE_TAC[MESON[SEPARATED_IN_SYM]
   `(a \<noteq> b) \<and>
    ((b \<noteq> a) \<Longrightarrow> separatedin X a b \<and> separatedin X b a) \<and> Q \<longleftrightarrow>
    (a \<noteq> b) \<and> separatedin X a b \<and> Q`] THEN
  REWRITE_TAC[MESON[SEPARATED_IN_REFL]
   `(a \<noteq> b) \<and> separatedin X a b \<and>
    ((a \<noteq> {}) \<and> (b \<noteq> {})) \<and> a \<union> b = s \<longleftrightarrow>
    a \<union> b = s \<and> (a \<noteq> {}) \<and> (b \<noteq> {}) \<and> separatedin X a b`] THEN
  REWRITE_TAC[CONNECTED_IN_EQ_NOT_SEPARATED; IMP_IMP; SUBSET_DIFF] THEN
  SIMP_TAC[]);;

lemma separation_by_closed_intermediates_eq_count:
   "\<And>(X::A topology) s n.
        locally_connected_space X \<and> hereditarily normal_space X
        \<Longrightarrow> ((\<exists>u. u HAS_SIZE n \<and>
                  pairwise (separatedin X) u \<and>
                  (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
                  \<Union> u = topspace X - s) \<longleftrightarrow>
             (\<exists>c. closedin X c \<and> c \<subseteq> s \<and>
                  \<forall>d. closedin X d \<and> c \<subseteq> d \<and> d \<subseteq> s
                      \<Longrightarrow> \<exists>u. u HAS_SIZE n \<and>
                              pairwise (separatedin X) u \<and>
                              (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
                              \<Union> u = topspace X - d))"
oops
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [MATCH_MP_TAC(ONCE_REWRITE_RULE [IMP_CONJ]
        SEPARATION_BY_CLOSED_INTERMEDIATES_COUNT) THEN
    ASM_REWRITE_TAC[];
    ALL_TAC] THEN
  ASM_CASES_TAC `n = 0` THENL
   [ASM_REWRITE_TAC[HAS_SIZE_0; UNWIND_THM2; NOT_IN_EMPTY; UNIONS_0] THEN
    REWRITE_TAC[PAIRWISE_EMPTY] THEN SET_TAC[];
    ALL_TAC] THEN
  GEN_REWRITE_TAC id [GSYM CONTRAPOS_THM] THEN
  REWRITE_TAC[NOT_EXISTS_THM] THEN STRIP_TAC THEN
  X_GEN_TAC `c::A=>bool` THEN
  REPLICATE_TAC 2 (DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(LABEL_TAC "*") THEN
  ABBREV_TAC
   `u = {d::A=>bool | d \<in> connected_components_of
                           (subtopology X (topspace X - c)) \<and>
                     \<not> (d - s = {})}` THEN
  SUBGOAL_THEN `\<forall>t::A=>bool. t \<in> u \<Longrightarrow> openin X t` ASSUME_TAC THENL
   [EXPAND_TAC "u" THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
    X_GEN_TAC `d::A=>bool` THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
      OPEN_IN_CONNECTED_COMPONENTS_OF_LOCALLY_CONNECTED_SPACE) \<circ>
     CONJUNCT1) THEN
    ASM_SIMP_TAC[OPEN_IN_OPEN_SUBTOPOLOGY; OPEN_IN_DIFF;
                 OPEN_IN_TOPSPACE] THEN
    ANTS_TAC THENL [ALL_TAC; SIMP_TAC[]] THEN
    MATCH_MP_TAC LOCALLY_CONNECTED_SPACE_OPEN_SUBSET THEN
    ASM_SIMP_TAC[OPEN_IN_DIFF; OPEN_IN_TOPSPACE];
    ALL_TAC] THEN
  SUBGOAL_THEN `\<forall>t::A=>bool. t \<in> u \<Longrightarrow> (t \<noteq> {})` ASSUME_TAC THENL
   [ASM SET_TAC[]; ALL_TAC] THEN
  SUBGOAL_THEN `pairwise disjnt (u:(A=>bool)->bool)` ASSUME_TAC THENL
   [EXPAND_TAC "u" THEN MP_TAC(ISPEC
     `subtopology X (topspace X - c):A topology`
        PAIRWISE_DISJOINT_CONNECTED_COMPONENTS_OF) THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] PAIRWISE_MONO) THEN
    REWRITE_TAC[SUBSET_RESTRICT];
    ALL_TAC] THEN
  SUBGOAL_THEN `finite(u:(A=>bool)->bool) \<and> card u < n`
  STRIP_ASSUME_TAC THENL
   [ONCE_REWRITE_TAC[TAUT `p \<and> q \<longleftrightarrow> (p \<noteq>=> \<not> q)`] THEN
    REWRITE_TAC[NOT_LT] THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC \<circ> MATCH_MP CHOOSE_SUBSET_STRONG) THEN
    DISCH_THEN(X_CHOOSE_THEN `v:(A=>bool)->bool` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN `\<exists>t::A=>bool. t \<in> v` STRIP_ASSUME_TAC THENL
     [REWRITE_TAC[MEMBER_NOT_EMPTY] THEN ASM_MESON_TAC[HAS_SIZE_0; HAS_SIZE];
      ALL_TAC] THEN
    FIRST_X_ASSUM(MP_TAC \<circ> SPEC
     `(topspace X - s - \<Union> (v - {t})) insert
      image (\<lambda>d::A=>bool. d - s) (v - {t})`) THEN
    REWRITE_TAC[] THEN
    MATCH_MP_TAC(TAUT
     `d \<and> c \<and> b \<and> (b \<and> c \<Longrightarrow> a) \<Longrightarrow> a \<and> b \<and> c \<and> d`) THEN
    REPEAT CONJ_TAC THENL
     [RULE_ASSUM_TAC(REWRITE_RULE[UNIONS_IMAGE; OPEN_IN_CLOSED_IN_EQ]) THEN
      REWRITE_TAC[UNIONS_IMAGE; UNIONS_INSERT] THEN ASM SET_TAC[];
      REWRITE_TAC[FORALL_IN_INSERT; FORALL_IN_IMAGE] THEN
      CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
      SUBGOAL_THEN `\<exists>a::A. a \<in> t \<and> (a \<notin> s)` STRIP_ASSUME_TAC THENL
       [ASM SET_TAC[]; ALL_TAC] THEN
      REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN EXISTS_TAC `a::A` THEN
      ASM_REWRITE_TAC[IN_DIFF] THEN CONJ_TAC THENL
       [MP_TAC(ISPEC `subtopology X (topspace X - c::A=>bool)`
         CONNECTED_COMPONENTS_OF_SUBSET) THEN
        REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[];
        ALL_TAC] THEN
      MP_TAC(SPECL [`v:(A=>bool)->bool`; `{t::A=>bool}`]
        DIFF_UNIONS_PAIRWISE_DISJOINT) THEN
      ASM_REWRITE_TAC[SING_SUBSET; SET_RULE `s - {a} = s - {a}`] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[pairwise]) THEN
      REWRITE_TAC[pairwise] THEN ASM SET_TAC[];
      MATCH_MP_TAC PAIRWISE_IMP THEN EXISTS_TAC
       `separatedin (subtopology X (topspace X - s):A topology)` THEN
      CONJ_TAC THENL [ALL_TAC; SIMP_TAC[SEPARATED_IN_SUBTOPOLOGY]] THEN
      MATCH_MP_TAC PAIRWISE_IMP THEN
      EXISTS_TAC `disjnt:(A=>bool)->(A=>bool)->bool` THEN CONJ_TAC THENL
       [REWRITE_TAC[PAIRWISE_INSERT; PAIRWISE_IMAGE] THEN
        REWRITE_TAC[IMP_CONJ; FORALL_IN_IMAGE; pairwise] THEN
        RULE_ASSUM_TAC(REWRITE_RULE[pairwise]) THEN ASM SET_TAC[];
        MATCH_MP_TAC(MESON[]
         `\<forall>P. (\<forall>x y. P x \<and> P y \<Longrightarrow> (R x y \<longleftrightarrow> Q x y)) \<and> (\<forall>x. x \<in> s \<Longrightarrow> P x)
          \<Longrightarrow> \<forall>x y. x \<in> s \<and> y \<in> s \<and> Q x y \<and> (x \<noteq> y) \<Longrightarrow> R x y`) THEN
        EXISTS_TAC
         `openin (subtopology X (topspace X - s):A topology)` THEN
        REWRITE_TAC[SEPARATED_IN_OPEN_SETS; FORALL_IN_INSERT] THEN
        REWRITE_TAC[FORALL_IN_IMAGE] THEN CONJ_TAC THENL
         [REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ; TOPSPACE_SUBTOPOLOGY] THEN
          SIMP_TAC[SET_RULE `s \<inter> (s - t) = s - t`; SUBSET_DIFF] THEN
          REWRITE_TAC[SET_RULE `s - (s - t) = s \<inter> t`] THEN
          SUBGOAL_THEN
           `closedin (subtopology X (topspace X - c))
                      (\<Union>(v DELETE (t::A=>bool)))`
          MP_TAC THENL
           [MATCH_MP_TAC CLOSED_IN_UNIONS THEN CONJ_TAC THENL
             [ASM_MESON_TAC[FINITE_DELETE; HAS_SIZE]; ALL_TAC] THEN
            X_GEN_TAC `t':A=>bool` THEN STRIP_TAC THEN
            MATCH_MP_TAC CLOSED_IN_CONNECTED_COMPONENTS_OF THEN
            ASM SET_TAC[];
            REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY] THEN
            MATCH_MP_TAC MONO_EXISTS THEN ASM SET_TAC[]];
          X_GEN_TAC `t':A=>bool` THEN DISCH_TAC THEN
          REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN EXISTS_TAC `t':A=>bool` THEN
          MATCH_MP_TAC(TAUT `p \<and> (p \<Longrightarrow> q) \<Longrightarrow> p \<and> q`) THEN
          CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
          DISCH_THEN(MP_TAC \<circ> MATCH_MP OPEN_IN_SUBSET) THEN SET_TAC[]]];
      STRIP_TAC THEN
      FIRST_ASSUM(SUBST1_TAC \<circ> MATCH_MP (ARITH_RULE
       `(n \<noteq> 0) \<Longrightarrow> n = Suc(n - 1)`)) THEN
      REWRITE_TAC[HAS_SIZE_CLAUSES] THEN MATCH_MP_TAC(MESON[]
       `P s \<and> Q a s \<Longrightarrow> (\<exists>b t. P t \<and> Q b t \<and> insert a s = insert b t)`) THEN
      CONJ_TAC THENL
       [MATCH_MP_TAC HAS_SIZE_IMAGE_INJ THEN CONJ_TAC THENL
         [RULE_ASSUM_TAC(REWRITE_RULE[pairwise]) THEN ASM SET_TAC[];
          RULE_ASSUM_TAC(REWRITE_RULE[HAS_SIZE]) THEN
          ASM_SIMP_TAC[CARD_DELETE; HAS_SIZE; FINITE_DELETE]];
        REWRITE_TAC[SET_RULE
         `(y \<notin> f ` s) \<longleftrightarrow> \<forall>x. x \<in> s \<Longrightarrow> \<not> (f x = y)`] THEN
        GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC(SET_RULE
         `disjnt s t \<and> (s \<noteq> {}) \<Longrightarrow> (s \<noteq> t)`) THEN
        CONJ_TAC THENL [ALL_TAC; ASM SET_TAC[]] THEN
        MATCH_MP_TAC SEPARATED_IN_IMP_DISJOINT THEN
        EXISTS_TAC `X::A topology` THEN
        RULE_ASSUM_TAC(REWRITE_RULE[pairwise]) THEN
        FIRST_X_ASSUM MATCH_MP_TAC THEN ASM SET_TAC[]]];
    ALL_TAC] THEN
  REMOVE_THEN "*" (MP_TAC \<circ> SPEC `topspace X - \<Union> u::A=>bool`) THEN
  REWRITE_TAC[NOT_IMP] THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC CLOSED_IN_DIFF THEN
    ASM_SIMP_TAC[OPEN_IN_UNIONS; CLOSED_IN_TOPSPACE];
    ASM_SIMP_TAC[CLOSED_IN_SUBSET; SET_RULE
     `c \<subseteq> u - s \<longleftrightarrow> c \<subseteq> u \<and> s \<inter> c = {}`] THEN
    REWRITE_TAC[INTER_UNIONS; EMPTY_UNIONS; FORALL_IN_GSPEC] THEN
    EXPAND_TAC "u" THEN REWRITE_TAC[IN_ELIM_THM; IMP_CONJ] THEN GEN_TAC THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP CONNECTED_COMPONENTS_OF_SUBSET) THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN SET_TAC[];
    EXPAND_TAC "u" THEN REWRITE_TAC[UNIONS_GSPEC] THEN
    MP_TAC(ISPEC `subtopology X (topspace X - c):A topology`
        UNIONS_CONNECTED_COMPONENTS_OF) THEN
    REWRITE_TAC[TOPSPACE_SUBTOPOLOGY] THEN ASM SET_TAC[];
    ASM_SIMP_TAC[SET_RULE `s \<subseteq> u \<Longrightarrow> u - (u - s) = s`;
                 UNIONS_SUBSET; OPEN_IN_SUBSET] THEN
    DISCH_THEN(X_CHOOSE_THEN `v:(A=>bool)->bool` STRIP_ASSUME_TAC)] THEN
  SUBGOAL_THEN `(v:(A=>bool)->bool) \<lesssim> (u:(A=>bool)->bool)` MP_TAC THENL
   [ALL_TAC;
    RULE_ASSUM_TAC(REWRITE_RULE[HAS_SIZE]) THEN
    ASM_SIMP_TAC[CARD_LE_CARD; NOT_LE]] THEN
  MATCH_MP_TAC CARD_LE_RELATIONAL_FULL THEN
  EXISTS_TAC `\<lambda>(u::A=>bool) v. \<not> disjnt u v` THEN
  REWRITE_TAC[] THEN CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [`t::A=>bool`; `c1::A=>bool`; `c2::A=>bool`] THEN
  STRIP_TAC THEN ASM_CASES_TAC `c1::A=>bool = c2` THEN ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN `connectedin X (t::A=>bool)` MP_TAC THENL
   [UNDISCH_TAC `(t::A=>bool) \<in> u` THEN EXPAND_TAC "u" THEN
    REWRITE_TAC[IN_ELIM_THM; IMP_CONJ_ALT] THEN DISCH_THEN(K ALL_TAC) THEN
    DISCH_THEN(MP_TAC \<circ> MATCH_MP CONNECTED_IN_CONNECTED_COMPONENTS_OF) THEN
    SIMP_TAC[CONNECTED_IN_SUBTOPOLOGY];
    REWRITE_TAC[CONNECTED_IN_EQ_NOT_SEPARATED_SUBSET]] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN REWRITE_TAC[] THEN
  MAP_EVERY EXISTS_TAC [`c1::A=>bool`; `\<Union>(v DELETE (c1::A=>bool))`] THEN
  REPEAT(CONJ_TAC THENL [ASM SET_TAC[]; ALL_TAC]) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[HAS_SIZE]) THEN
  ASM_SIMP_TAC[SEPARATED_IN_UNIONS; FINITE_DELETE] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[pairwise]) THEN
  REWRITE_TAC[IN_DELETE] THEN ASM_MESON_TAC[separatedin]);;

lemma separation_by_closed_intermediates_eq_gen:
   "\<And>(X::A topology) s.
        locally_connected_space X \<and> hereditarily normal_space X
        \<Longrightarrow> (\<not> connectedin X (topspace X - s) \<longleftrightarrow>
             \<exists>c. closedin X c \<and> c \<subseteq> s \<and>
                 \<forall>d. closedin X d \<and> c \<subseteq> d \<and> d \<subseteq> s
                     \<Longrightarrow> \<not> connectedin X (topspace X - d))"
oops
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [`X::A topology`; `s::A=>bool`; `2`]
    SEPARATION_BY_CLOSED_INTERMEDIATES_EQ_COUNT) THEN
  REWRITE_TAC[MESON[HAS_SIZE_CONV `s HAS_SIZE 2`]
   `(\<exists>s. s HAS_SIZE 2 \<and> P s) \<longleftrightarrow> (\<exists>a b. (a \<noteq> b) \<and> P{a,b})`] THEN
  REWRITE_TAC[PAIRWISE_INSERT; UNIONS_2; FORALL_IN_INSERT; NOT_IN_EMPTY;
              IMP_CONJ; NOT_IN_EMPTY; PAIRWISE_EMPTY] THEN
  REWRITE_TAC[MESON[SEPARATED_IN_SYM]
   `(a \<noteq> b) \<and>
    ((b \<noteq> a) \<Longrightarrow> separatedin X a b \<and> separatedin X b a) \<and> Q \<longleftrightarrow>
    (a \<noteq> b) \<and> separatedin X a b \<and> Q`] THEN
  REWRITE_TAC[MESON[SEPARATED_IN_REFL]
   `(a \<noteq> b) \<and> separatedin X a b \<and>
    ((a \<noteq> {}) \<and> (b \<noteq> {})) \<and> a \<union> b = s \<longleftrightarrow>
    a \<union> b = s \<and> (a \<noteq> {}) \<and> (b \<noteq> {}) \<and> separatedin X a b`] THEN
  REWRITE_TAC[CONNECTED_IN_EQ_NOT_SEPARATED; IMP_IMP; SUBSET_DIFF] THEN
  SIMP_TAC[]);;

lemma kuratowski_component_number_invariance:
   "      compact_space X \<and>
      Hausdorff_space X \<and>
      locally_connected_space X \<and>
      hereditarily normal_space X
      \<Longrightarrow> ((\<forall>s t n.
              closedin X s \<and> closedin X t \<and>
              (subtopology X s) homeomorphic_space (subtopology X t)
              \<Longrightarrow> (connected_components_of
                    (subtopology X (topspace X - s)) HAS_SIZE n \<longleftrightarrow>
                   connected_components_of
                    (subtopology X (topspace X - t)) HAS_SIZE n)) \<longleftrightarrow>
           (\<forall>s t n.
              (subtopology X s) homeomorphic_space (subtopology X t)
              \<Longrightarrow> (connected_components_of
                    (subtopology X (topspace X - s)) HAS_SIZE n \<longleftrightarrow>
                   connected_components_of
                    (subtopology X (topspace X - t)) HAS_SIZE n)))"
oops
  lemma lemma:
   "\<And>(R::A=>A->bool) (f::A=>B->bool).
          (\<forall>s t. R s t \<Longrightarrow> R t s)
          \<Longrightarrow> ((\<forall>s t n. R s t \<Longrightarrow> (f s HAS_SIZE n \<longleftrightarrow> f t HAS_SIZE n)) \<longleftrightarrow>
               (\<forall>n s t. R s t \<Longrightarrow> 1..n \<lesssim> f s \<Longrightarrow> 1..n \<lesssim> f t))"
oops
    REPEAT STRIP_TAC THEN TRANS_TAC EQ_TRANS
     `\<forall>s t n. R s t \<Longrightarrow> (1..n \<lesssim> (f::A=>B->bool) s \<longleftrightarrow> 1..n \<lesssim> f t)` THEN
    CONJ_TAC THENL [POP_ASSUM(K ALL_TAC); ASM_MESON_TAC[]] THEN
    REWRITE_TAC[HAS_SIZE; NUMSEG_CARD_LE] THEN EQ_TAC THENL
     [MESON_TAC[];
      REWRITE_TAC[ARITH_RULE `a = n \<longleftrightarrow> n \<le> a \<and> \<not> (n + 1 \<le> a)`] THEN
      MESON_TAC[]])
  and lemur = prove
   (`pairwise (separatedin (subtopology X (topspace X - s))) u \<and>
     (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
     \<Union> u = topspace(subtopology X (topspace X - s)) \<longleftrightarrow>
     pairwise (separatedin X) u \<and>
     (\<forall>t. t \<in> u \<Longrightarrow> (t \<noteq> {})) \<and>
     \<Union> u = topspace X - s"
oops
    REWRITE_TAC[pairwise; SEPARATED_IN_SUBTOPOLOGY; TOPSPACE_SUBTOPOLOGY] THEN
    SET_TAC[])
in

  REPEAT STRIP_TAC THEN EQ_TAC THENL [ALL_TAC; MESON_TAC[]] THEN
  W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) lemma \<circ> lhand \<circ> snd) THEN ANTS_TAC THENL
   [MESON_TAC[HOMEOMORPHIC_SPACE_SYM]; DISCH_THEN SUBST1_TAC] THEN
  W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand) lemma \<circ> rand \<circ> snd) THEN ANTS_TAC THENL
   [MESON_TAC[HOMEOMORPHIC_SPACE_SYM]; DISCH_THEN SUBST1_TAC] THEN
  MATCH_MP_TAC MONO_FORALL THEN X_GEN_TAC `n::num` THEN
  REWRITE_TAC[CARD_LE_CONNECTED_COMPONENTS_ALT] THEN
  ASM_CASES_TAC `n = 0` THEN ASM_REWRITE_TAC[lemur] THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [`s::A=>bool`; `t::A=>bool`] THEN
  ONCE_REWRITE_TAC[SUBTOPOLOGY_RESTRICT] THEN
  ONCE_REWRITE_TAC[SET_RULE `s - t = s - s \<inter> t`] THEN
  MP_TAC(SET_RULE
   `topspace X \<inter> (s::A=>bool) \<subseteq> topspace X \<and>
    topspace X \<inter> (t::A=>bool) \<subseteq> topspace X`) THEN
  SPEC_TAC(`topspace X \<inter> (t::A=>bool)`,`t::A=>bool`) THEN
  SPEC_TAC(`topspace X \<inter> (s::A=>bool)`,`s::A=>bool`) THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN DISCH_TAC THEN
  W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand)
    SEPARATION_BY_CLOSED_INTERMEDIATES_EQ_COUNT \<circ> lhand \<circ> snd) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN SUBST1_TAC THEN
  W(MP_TAC \<circ> PART_MATCH (lhand \<circ> rand)
    SEPARATION_BY_CLOSED_INTERMEDIATES_EQ_COUNT \<circ> rand \<circ> snd) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN SUBST1_TAC THEN
  FIRST_ASSUM(MP_TAC \<circ> GEN_REWRITE_RULE id [homeomorphic_space]) THEN
  REWRITE_TAC[LEFT_IMP_EXISTS_THM; HOMEOMORPHIC_MAPS_MAP] THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET] THEN
  MAP_EVERY X_GEN_TAC [`f::A=>A`; `g::A=>A`] THEN STRIP_TAC THEN
  X_GEN_TAC `c::A=>bool` THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(LABEL_TAC "*") THEN EXISTS_TAC `image (f::A=>A) c` THEN
  REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC IMAGE_COMPACT_IN THEN
    EXISTS_TAC `subtopology X (s::A=>bool)` THEN
    ASM_SIMP_TAC[COMPACT_IN_SUBTOPOLOGY; CLOSED_IN_COMPACT_SPACE] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP;
                                CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
    ASM_REWRITE_TAC[];
    RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP;
                                CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
    RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_SUBTOPOLOGY]) THEN
    ASM SET_TAC[];
    X_GEN_TAC `d':A=>bool` THEN STRIP_TAC] THEN
  ABBREV_TAC `d = image (g::A=>A) d'` THEN
  SUBGOAL_THEN `closedin X (d::A=>bool)` ASSUME_TAC THENL
   [MATCH_MP_TAC COMPACT_IN_IMP_CLOSED_IN THEN ASM_REWRITE_TAC[] THEN
    EXPAND_TAC "d" THEN MATCH_MP_TAC IMAGE_COMPACT_IN THEN
    EXISTS_TAC `subtopology X (t::A=>bool)` THEN
    ASM_SIMP_TAC[COMPACT_IN_SUBTOPOLOGY; CLOSED_IN_COMPACT_SPACE] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP;
                                CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
    ASM_REWRITE_TAC[];
    ALL_TAC] THEN
  SUBGOAL_THEN `(c::A=>bool) \<subseteq> d \<and> d \<subseteq> s` STRIP_ASSUME_TAC THENL
   [EXPAND_TAC "d" THEN
    RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP;
                                CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
    RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_SUBTOPOLOGY]) THEN
    ASM SET_TAC[];
    ALL_TAC] THEN
  REMOVE_THEN "*" (MP_TAC \<circ> SPEC `d::A=>bool`) THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[homeomorphic_space] THEN
  MAP_EVERY EXISTS_TAC [`f::A=>A`; `g::A=>A`] THEN
  SUBGOAL_THEN
   `subtopology X d::A topology = subtopology (subtopology X s) d \<and>
    subtopology X d':A topology = subtopology (subtopology X t) d'`
  (CONJUNCTS_THEN SUBST1_TAC) THENL
   [REWRITE_TAC[SUBTOPOLOGY_SUBTOPOLOGY] THEN
    CONJ_TAC THEN AP_TERM_TAC THEN ASM SET_TAC[];
    MATCH_MP_TAC HOMEOMORPHIC_MAPS_SUBTOPOLOGIES] THEN
  ASM_REWRITE_TAC[HOMEOMORPHIC_MAPS_MAP] THEN
  ASM_SIMP_TAC[TOPSPACE_SUBTOPOLOGY_SUBSET] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[HOMEOMORPHIC_EQ_EVERYTHING_MAP;
                              CONTINUOUS_MAP_IN_SUBTOPOLOGY]) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[TOPSPACE_SUBTOPOLOGY]) THEN
  ASM SET_TAC[]);;
